---
title: (基础1)变量（变量提升,暂时性死区）、执行上下文、执行栈、作用域
categories: "(基础1)变量（变量提升,暂时性死区）、执行上下文、执行栈、作用域"
tags:
  - JavaScript
  - 基础
---
### 一·变量提升
首先两个打印例子
```
a = 'ghostwu';
var a;
console.log( a );   //ghostwu
```
```
console.log( a );
var a = 'ghostwu'; //undefined
```
**why?**
>首先:明确两点
* javascript代码并不是一行一行往下执行的.
* javascript执行分为2个步骤:
      1.编译(词法解释/预解释)
      2.执行

> 其次:当我们碰到 var a = "ghostwu" 定义一个变量的时候， 其实js把这句话看成是2个阶段的事,  var a 发生在==编译==阶段， a = 'ghostwu'发生在执行阶段. 然后 var a会被提升到当前作用域的最前面,  a = 'ghostwu'留在原地==等待执行==阶段，所以：

```
a = 'ghostwu';
var a;
console.log( a );
// 上面这段代码经过编译之后，变成下面这样
var a;  //被提升到当前作用域的最前面
a = 'ghostwu'; //留在原地，等待执行
console.log( a );
```
```
console.log( a );
var a = 'ghostwu';
//上面这段代码,经过编译之后，变成下面这样
var a;
console.log( a );
a = 'ghostwu';
```
**明确函数定义的两种方式**

```
//函数声明, 形如:
function show(){
    console.log( '函数声明方式' );
}
//函数表达式, 形如:
var show = function(){
    console.log( '表达式方式' );
}
```
> 因为表达式和函数声明，在编译阶段，会产生不同的解释效果。
```
show(); //undefined
function show(){
    console.log( a );
    var a = 'ghostwu';
}
```
**函数声明会被提升**
> 所以，上面的代码，经过编译之后，就变成了下面这样：

```
function show(){    //函数声明被提升到 当前作用域的最前面
    var a;    //var声明被提升到当前作用域的最前面, 注意，它不会提升到函数的外面, 因为当前的作用域是在函数中
    console.log( a );
    a = 'ghostwu';
}
show();
```
**函数表达式，是不会提升的**, 看下面的例子:
```
 show(); //报错,show is not a function
 var show = function(){
 console.log( 'ghostwu' );
 }
 //对于上面这段表达式代码，经过编译之后:
 var show;
 show();  //执行之后就是 undefined, 所以在表达式定义之前，调用函数报错了
 show = function(){
 console.log( 'ghostwu' );
 ```

 ```
 show(); //你好
 var show;
 function show(){
     console.log( '你好' );
 }
 show = function(){
     console.log( 'hello' );
 }
```
> 上面的例子**为什么**是你好？
因为： 当出现同名的函数声明，变量声明的时候， 函数声明会被优先提升，变量声明会被忽略。 所以经过编译之后，就变成:
```
function show(){
    console.log( '你好' );
}
show(); //你好
show = function(){
    console.log( 'hello' );
}
show();//如果这里在调用一次，就是hello, 因为show函数体在执行阶段 被 重新赋值了    
```
> 如果有同名的函数声明，后面的会覆盖前面的，如下:
```
show(); //how are you
var show;
function show(){
    console.log( 'hello' );
}    
show = function(){
    console.log( '你好' );
}
function show(){
    console.log( 'how are you!' );
}
//上面的代码经过编译之后，变成如下形式:
function show(){
    console.log( 'how are you!' );
}
show(); //how are you
show = function(){
    console.log( '你好' );
}
show(); //如果在这里再执行一次，结果：你好
```
**暂时性死区**
我们都知道，var声明的变量会有变量提升的作用，如下
```
console.log(a);  //1
var a=1;
console.log(b);  //undefined
var b;
```
>可以看出，虽然代码中console调用a在前，声明a在后，但是由于在js中，函数及变量的声明都将被提升到函数的最顶部，也就是说（var声明的）变量可以先使用再声明。

> 然后，使用let，const（后面会提及）声明的变量却不存在变量提升。
```
console.log(foo); // Uncaught ReferenceError: foo is not defined
let foo = 2;

console.log(foo1); // Uncaught ReferenceError: foo1 is not defined
let foo1;
```
> **ES6明确规定**，如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。所以在代码块内，使用let,const命令声明变量之前，该变量都是**不可用**的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

> 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

注：“暂时性死区”也意味着typeof不再是一个百分之百安全的操作，因为会使typeof报错。
> 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 **let和 const**的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。
**let不允许在相同作用域内，重复声明同一个变量。**
```
if (true) {
  let aa;
  let aa; // Uncaught SyntaxError: Identifier 'aa' has already been declared
}

if (true) {
  var _aa;
  let _aa; // Uncaught SyntaxError: Identifier '_aa' has already been declared
}

if (true) {
  let aa_;
  var aa_; // Uncaught SyntaxError: Identifier 'aa_' has already been declared
}
```
**全局变量 vs 全局对象的属性**

> ES5中全局对象的属性与全局变量基本是等价的，但是也有区别，比如通过var声明的全局变量不能使用delete从 window/global （ global是针对与node环境）上删除，不过在变量的访问上基本等价。

> ES6 中做了严格的区分，使用 var 和 function 声明的全局变量依旧作为全局对象的属性，使用 let, const 命令声明的全局变量**不属于全局对象的属性**。
```
let let_test = 'test';
console.log(window.let_test);   // undefined
console.log(this.let_test);   // undefined

var var_test = 'test';
console.log(window.var_test);  // test
console.log(this.var_test);  // test
```
**const**
> 除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是**固定的（常量）。使用const声明变量的时候，必须同时赋值，否则会报错。并且之后任何试图修改值的操作都会引起错误**.
```
const data;  //Uncaught SyntaxError: Missing initializer in const declaration
```
```
if (true) {
    var a = 2;
    const b = 3; // 包含在 if 中的块作用域常量
    a = 3; // 正常 !
    b = 4; // Uncaught TypeError: Assignment to constant variable.
}
console.log( a ); // 3
console.log( b ); // Uncaught ReferenceError: b is not defined
```
 > 注：复合类型const变量保存的是引用。因为复合类型的常量不指向数据，而是指向数据(heap)所在的地址(stack)，所以通过 const 声明的复合类型只能保证其地址引用不变，但不能保证其数据不变。
```
const arr= [1, 2];
// 修改数据而不修改引用地址，正确执行
arr.push(3);  // [1, 2, 3]
// 修改 arr 常量所保存的地址的值，报错
arr = [];     // Uncaught TypeError: Assignment to constant variable.
```
> 简单的使用const无法完成对象的冻结。可以通过**Object.freeze**()方法实现对对象的冻结。使用Object.freeze()方法返回的对象将不能对其属性进行配置(definedProperty()不可用)同时**不能添加新的属性和移除(remove)已有属性**。彻底冻结对象时需要递归的对它的对象属性进行冻结。
```
let obj = {
  a: 1,
  b: {
    b1: 2
  }
};
obj.b.b1 = 3;
console.log(obj.b.b1 ); //3
function freeze(obj){
  Object.freeze(obj);
  Object.values(obj).forEach(function (value,index) {
    if(typeof value === 'object'){
      freeze(value);
    }
  })
}
freeze(obj);
obj.b.b1 = 4;
console.log(obj.b.b1); //3
```
