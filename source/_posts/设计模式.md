---
title: 设计模式
categories: "设计模式"
tags:
  - JavaScript
  - 设计模式
---
### 基础知识
#### 什么是设计模式？
> 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。
通俗理解:==给好的设计取个名字。==
#### 设计模式的作用？
> 当某个类似的场景出现的时候，很快的找到某种模式作为解决方案。

*javaScript和其他静态类型的语言有差异，不应照搬设计模式。*
#### 多态
##### 什么是多态
> 同一操作作用于不同对象的上面，可以产生不同的解释和不同的执行效果。
通俗理解：主人说发出叫的命令，不同动物发出不同的叫声。
代码理解多态：
```
var makeSound=function(animal) {
    animal.sound()
}
var Duck = function(){}
Dunk.prototype.sound = function() {
    console.log('嘎嘎嘎')
}
var Dog = function(){}
Dog.prototype.sound = function() {
    console.log('汪汪汪')
}
mackSound(new Duck)
mackSound(new Dog)

还有其他动物就简单追加一些代码就可以了。
```
> 多态思想是把"做什么"和"谁去做"分开，
那如何分开？消除类型之间的耦合关系。
如果makeSound指定了发出叫声的对向是某个类型，那就不能被替换另一类型所以:==静态类型语言的多态==：涉及到类型检查，所以像（java）通过向上转型，通过继承来实现多态。
==javaScript的多态==：由于变量类型在运行期间是可变的，不存在类型耦合，所以它的多态是与生俱来的。

>javaScript函数也是对象，函数用来封装行为并到处传递，当对函数发出“调用”的消息时，这些函数会返回不同的执行效果。这是多态的一种体现。这也是很多设计模式在JavaScript中使用高阶函数来实现的原因。
#### 封装
> 封装的目的是将信息影藏。
广义上包括封装数据和封装实现，封装类型和封装变化。
##### 封装数据
> 许多语言封装数据是通过语法解析来实现的，用（private,public,protect）等关键字来提供不同的访问权限。
JavaScript没有这些关键字的支持，只能通过==变量的作用域==来实现封装特性而且只能模拟public和private两种封装性
```
var myObject = (function() {
    var _name = "haha"      //私有变量（'private'）
    return {
        getName: function(){ // 公开方法（'public'）
            return _name
        }
    }
})();
console.log(myObject._name)  // 输出：haha
console.log(myObject.getName()) // 输出undefined
```
##### 封装实现
封装使得对象之间的耦合变松散，对象之间只通过暴露api接口来通信。
##### 封装类型
> 它是静态类型语言的一种重要的封装方式。一般通过抽象类和接口来进行的。
JavaScript是类型模糊的语言没有抽象类和接口的支持，所以在封装类型方面没有能力也没必要做的更多。
##### 封装变化
找到系统稳定不变的部分和容易变化的部分隔离开，系统演变的过程中只需要替换容易变化的部分。

#### 原型模式和基于原型模式的JavaScript对象系统。
##### 第一个设计模式————原型模式
###### 使用克隆的原型模式
> es5提供了Object.created()来克隆对象。
```
var Plane = function() {
	this.aa = 11
}
var plane = new Plane()
plane.aa = 22
var clonePlane = Object.create(plane)
console.log(clonePlane.aa)  // 22
plane.aa = 33
console.log(clonePlane.aa) // 33
```
##### 克隆是创建对象的手段
在javaScript创建对象非常容易，不存在类型耦合，所以原型模式的意义并不大，但是他的对象系统就是使用原型模式来搭建的。
##### 原型编程泛型
> object是animal的原型，而animal是Dog原型，他们之间形成了一个原型链，这个原型链很有用处当调用Dog对象的某个方法时，它本身没有，Dog对象会把这个请求委托給它的原型animal对象这样顺着原型链一直委托下去，便得到继承的效果。
==这样基于原型链的委托机制就是原型继承的本质==。
#### JavaScript中的原型继承
==原型编程的基本规则：==
1. 所有数据都是对象
2. 要得到一个对象不是通过实例化类，而是找到一个对象并克隆它
3. 对象会记住它的原型
4. 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型

##### 1，所有数据都是对象
javascrit模仿java有两套类型机制：基本类型和对象类型。
javaScript并不是所有数据都是对象，按设计者本意除undefined外一切都应是对象，为了实现这个number，boolean,string这几种基本类型也可以通过“包装类”的方式变成对象类型的数据处理。
>   javaSript中的根对象是object.prototype对象（一个空对象）。javascripty中遇到的每个对象都是从Object.prototype对象克隆而来的。Object.prototype对象就是他们的原型，比如：
```
var obj1 = new Object();
var obj2 = {};
查看这两个对象的原型(es5的Object.getPrototypeOf)
console.log(Object.getPrototypeOf(obj1)===Object.prototype) //true
console.log(Object.getPrototypeOf(obj2)===Object.prototype) //true
```
##### 2.要得到一个对象不是通过实例化类，而是找到一个对象并克隆它
JavaScript引擎内部负责实现克隆，
调用var obj1 = new Object()和var obj2 = {};时内部会从Object.prototype上克隆一个对象；一段熟悉的代码：
```
funtion Person(name){
    this.name = name
}
Person.prototype.getName = function(){
    return this.name
}
var a = new Person('seven')
console.log(a.name) //seven
console.log(a.getName())
console.log(Object.getPrototypeOf(a)===Person.prototype)
```
==javascript没有类的概念==这里的Person不是类而是函数构造器，因为js的函数既可以作为普通函数调用也可以作为构造器被调用，用new运算符调用时就是一个构造器，创建对象的过程就是先克隆Object.prototype对象，再进行一些其他额外的操作的过程（实际上并不是真的克隆了一个新对象《内存方面出发还做了其他处理，参考js精髓和编程实战）
