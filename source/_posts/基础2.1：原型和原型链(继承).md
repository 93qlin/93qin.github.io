---
title: 2.1原型与原型链(继承)
categories: "2.1原型与原型链(继承)"
tags:
  - javascript
  - 基础
---
<html>
<h2>目录</h2>
</html>

&emsp;[1. 原型](#j1)

&emsp;[2. 原型链](#j2)

&emsp;[2. 继承](#j2)

**前因后果**

**原因**
OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际方法。由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，
**所以**
其实现 **继承** 主要是依靠原型链
**继续**
> 原型链是用来实现继承的，因為沒有類的結構，用prototype實現有類語言的繼承特性(創建構造器，指向對象)原型的作用，则是实现对象的继承

<h5 id='j1'>1. 原型</h5>

原型[传送门](http://www.93lin.cn/2019/02/28/%E5%9F%BA%E7%A1%801.4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%83%E7%A7%8D%E6%A8%A1%E5%BC%8F/)

<h5 id='j2'>2. 原型链</h5>

![image](https://raw.githubusercontent.com/93qlin/93qlin.github.io/master/img/yuanxinlian.png)

原型链是实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

**概念：**

每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个指向原型对象的指针。假如原型对象是另一个构造函数的实例，那么原型对象也包含一个指向另一个原型的指针，如此层层递进，就叫原型链。
简而言之：因为没有类的结构，用prototype实现有类语言的继承特性（创建构造器，指向对象）

注：所有引用类型都默认继承自 object ，object 的原型为null。

确定原型与实例之间的关系：instanceof isPrototypeOf

<h5 id='j3'>3. 继承</h5>

七种继承的方式[传送门](http://www.93lin.cn/2019/02/28/%E5%9F%BA%E7%A1%801.5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E5%BC%8F/)

**使用原型继承的缺陷**

缺陷一：引用类型值的原型属性会被所有实例共享

举个例：

```
function SuperType() {
    this.colors = ["red", "blue", "green"];
}

function SubType() {

}

SubType.prototype = new SuperType();

var instance1 = new SuperType();
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"

var instance2 = new SubType();
alert(instance2.colors); //"red,blue,green,black"
```

例子中，SubType（子类）通过原型链继承了SuperType，SubType.prototype就变成了SuperType（超类，也就是我们所说的父类）的一个实例。也就是说，SubType.prototype中会有一个colors的数组，SubType的所有实例都将共享colors这个数组（引用类型值）。因此只要SubType其中一个实例对colors做了修改，就会影响到其他所有SubType的实例。

缺陷二：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。

针对问题二中的第一句话，“在创建子类型的实例时，不能向超类型的构造函数中传递参数”，我举个例子：
```
function SuperType(name) { // 超类型
    this.name = name;
}

function SubType(age) { //子类型
    this.age = age;
}

SubType.prototype = new SuperType("Allan");

var instance1 = new SubType(10);
console.log(instance1.name); // Allan
console.log(instance1.age); // 10

var instance2 = new SubType(20);
console.log(instance2.name); // 10
```
上面代码中构造函数SuperType完全等价于下面声明的形式。

```
function SuperType() {
    name = "Allan";
}
```
instance1通过原型链继承的name属性值，在instance1创建之前就已经被确定为Allan了。无论怎么new SuperType()都更改不了name属性值，这就是所谓的“在创建子类型的实例时，不能向超类型的构造函数中传递参数”。

针对问题二中的第二句话，“实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数”,这句话应该怎么理解？

其实在上面的代码中，我在创建SuperType实例的时候，向它传递了一个”Allan”的字符串参数。但是我们看到后面所有的SubType的实例，无论是instance1还是instance2的name属性都是Allan，也就是说SuperType创建实例时传递的参数，影响了后面所有SubType的实例。这就是所谓“没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数”。

**js通过沿着作用域链还是原型链查找变量?**
