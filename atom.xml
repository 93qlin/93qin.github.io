<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>永不言弃</title>
  <icon>https://www.gravatar.com/avatar/bbe27288b4117e44ba424127b240b1a0</icon>
  <subtitle>一步一脚印，一岁一枯荣，never never give up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://93qlin.github.io/"/>
  <updated>2019-02-28T03:27:11.065Z</updated>
  <id>https://93qlin.github.io/</id>
  
  <author>
    <name>lin</name>
    <email>925697386@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试</title>
    <link href="https://93qlin.github.io/2019/02/28/%E9%9D%A2%E8%AF%95/"/>
    <id>https://93qlin.github.io/2019/02/28/面试/</id>
    <published>2019-02-28T03:12:12.522Z</published>
    <updated>2019-02-28T03:27:11.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="1-CSS3选择器-nth-child和-nth-of-type之间的差异"><a href="#1-CSS3选择器-nth-child和-nth-of-type之间的差异" class="headerlink" title="1.CSS3选择器:nth-child和:nth-of-type之间的差异"></a>1.CSS3选择器:nth-child和:nth-of-type之间的差异</h2><blockquote><p>p:nth-child(2)表示这个元素要是p标签，且是第二个子元素，是两个必须满足的条件<br>而p:nth-of-type(2)表示父标签下的第二个p元素</p></blockquote><h2 id="JS获取URL中参数值（QueryString）"><a href="#JS获取URL中参数值（QueryString）" class="headerlink" title="JS获取URL中参数值（QueryString）:"></a>JS获取URL中参数值（QueryString）:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getQueryString(name) &#123;</span><br><span class="line">    var reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;, &apos;i&apos;);</span><br><span class="line">    var r = window.location.search.substr(1).match(reg);</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        return unescape(r[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">// 这样调用：</span><br><span class="line">alert(GetQueryString(&quot;参数名1&quot;));</span><br><span class="line">alert(GetQueryString(&quot;参数名2&quot;));</span><br><span class="line">alert(GetQueryString(&quot;参数名3&quot;));</span><br></pre></td></tr></table></figure><h2 id="HTML5头部meta整理"><a href="#HTML5头部meta整理" class="headerlink" title="HTML5头部meta整理"></a>HTML5头部meta整理</h2><p>1.<strong>页面关键词</strong><br><code>&#39;&lt;&#39;meta name=&quot;keywords&quot; content=&quot;关键字，多个关键字用，隔开&quot; /&gt;</code><br>2.<strong>页面描述</strong><br><code>&#39;&lt;&#39;meta name=&quot;description&quot; content=&quot;150个字符以内&quot; /&gt;</code><br>3.<strong>搜索引擎索引方式</strong><br><code>&#39;&lt;&#39;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;</code><br><code>以下是content里面可以有的索引值，多个索引方式用，隔开！！</code></p><blockquote><p>all：文件将被检索，且页面上的链接可以被查询；<br>none：文件将不被检索，且页面上的链接不可以被查询；<br>index：文件将被检索；<br>follow：页面上的链接可以被查询；<br>noindex：文件将不被检索；<br>nofollow：页面上的链接不可以被查询。</p></blockquote><p> 4.<strong>页面重定向和刷新</strong><br><code>&#39; &lt;&#39;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;</code><br>注：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。<br>5.<strong>其他</strong></p><blockquote><p>&lt;’meta name=”author” content=”author name” /&gt; <!-- 定义网页作者 --><br>&lt;’meta name=”google” content=”index,follow” /&gt;<br>&lt;’meta name=”googlebot” content=”index,follow” /&gt;<br>&lt;’meta name=”verify” content=”index,follow” /&gt;</p></blockquote><p>6.<strong>移动设备</strong><br><code>viewport：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。</code></p><blockquote><p>&lt;’meta name=”viewport” content=”width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no”/&gt;<br>width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素）<br>height：高度（数值 / device-height）（范围从223 到10,000）<br>initial-scale：初始的缩放比例 （范围从&gt;0 到10）<br>minimum-scale：允许用户缩放到的最小比例<br>maximum-scale：允许用户缩放到的最大比例<br>user-scalable：用户是否可以手动缩 (no,yes)<br>minimal-ui：可以在页面加载时最小化上下状态栏。</p></blockquote><p>7.<strong>WebApp全屏模式</strong><br><code>&lt;&#39;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;!-- 启用 WebApp 全屏模式 --&gt;</code><br><strong>隐藏状态栏</strong>/设置状态栏颜色：只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。</p><p><code>&lt;&#39;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;</code><br><strong>添加到主屏后的标题</strong></p><p><code>&lt;&#39;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;</code><br><strong>忽略数字自动识别为电话号码</strong></p><p><code>&lt;&#39;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt;</code><br><strong>忽略识别邮箱</strong></p><p><code>&lt;&#39;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;</code><br>添加智能 App 广告条 Smart App Banner：告诉浏览器这个网站对应的app，并在页面上显示下载banner</p><p><code>&lt;&#39;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;</code><br><strong>其他</strong></p><p>&lt;’!– 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 –&gt;<br><code>&lt;&#39;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;</code><br>&lt;’!– 微软的老式浏览器 –&gt;<br><code>&lt;&#39;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;</code><br>&lt;’!– uc强制竖屏 –&gt;<br><code>&lt;&#39;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;</code><br>&lt;’!– QQ强制竖屏 –&gt;<br><code>&lt;&#39;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;</code><br>&lt;’!– UC强制全屏 –&gt;<br><code>&lt;&#39;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;</code><br>&lt;’!– QQ强制全屏 –&gt;<br><code>&lt;&#39;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;</code><br>&lt;’!– UC应用模式 –&gt;<br><code>&lt;&#39;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;</code><br>&lt;’!– QQ应用模式 –&gt;<br><code>&lt;&#39;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;</code><br>&lt;’!– windows phone 点击无高光 –&gt;<br><code>&lt;&#39;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;</code></p><p>##网页相关</p><p><strong>申明编码</strong><br><code>&lt;&#39;meta charset=&#39;utf-8&#39; /&gt;</code><br>优先使用 IE 最新版本和 Chrome</p><blockquote><p>&lt;’meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1” /&gt;<br>&lt;’!– 关于X-UA-Compatible –&gt;<br>&lt;’meta http-equiv=”X-UA-Compatible” content=”IE=6” &gt;<!-- 使用IE6 --><br>&lt;’meta http-equiv=”X-UA-Compatible” content=”IE=7” &gt;<!-- 使用IE7 --><br>&lt;’meta http-equiv=”X-UA-Compatible” content=”IE=8” &gt;<!-- 使用IE8 --></p></blockquote><p><strong>浏览器内核控制</strong></p><blockquote><p>&lt;’meta name=”renderer” content=”webkit|ie-comp|ie-stand”&gt;<br>禁止浏览器从本地计算机的缓存中访问页面内容<br>&lt;’meta http-equiv=”Pragma” content=”no-cache”&gt;<br>Windows 8<br>&lt;’meta name=”msapplication-TileColor” content=”#000”/&gt; <!-- Windows 8 磁贴颜色 --><br>&lt;’meta name=”msapplication-TileImage” content=”icon.png”/&gt; <!-- Windows 8 磁贴图标 --></p></blockquote><p><strong>站点适配</strong></p><blockquote><p>&lt;’meta name=”mobile-agent”content=”format=[wml|xhtml|html5]; url=url”&gt;<br><!--[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；url="url" 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。 --></p></blockquote><p><strong>转码申明</strong><br><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;</code><br>用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加此meta</p><p>#数组去重<br>用数组和对象做对比。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique3 = function()&#123;</span><br><span class="line">    var res = [];</span><br><span class="line">    var json = &#123;&#125;;</span><br><span class="line">    for(var i = 0; i &lt; this.length; i++)&#123;</span><br><span class="line">        if(!json[this[i]])&#123;</span><br><span class="line">            res.push(this[i]);</span><br><span class="line">            json[this[i]] = 1;</span><br><span class="line">            console.log(json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br><span class="line">var arr = [112,112,34,&apos;你好&apos;,112,112,34,&apos;你好&apos;,&apos;str&apos;,&apos;str1&apos;];</span><br><span class="line">console.log(arr.unique3());</span><br></pre></td></tr></table></figure></p><p>建立一个空数组和空对象，循环这个数组，到对象中匹配数组中的元素，如果不存在，则在空数组中添加这个元素，在空对象中添加这个key并随便给个值。</p><h2 id="函数链式调用"><a href="#函数链式调用" class="headerlink" title="函数链式调用"></a>函数链式调用</h2><p>以下回答假设您已经了解闭包的的相关知识</p><blockquote><p>可以解析为<br>add(2)返回函数A<br>A(3)返回函数B<br>B(4)返回函数C<br>那么初步的做法是<br>add函数执行后返回一个函数对象，这个函数对象执行后再返回一个新函数，这样一直执行下去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(num)&#123;</span><br><span class="line">    var sum=0;</span><br><span class="line">    sum= sum+num;</span><br><span class="line">    return function(numB)&#123;</span><br><span class="line">        sum= sum+ numB;</span><br><span class="line">        return function(numC)&#123;</span><br><span class="line">            sum= sum+ numC;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>代码这样实现后，执行输出9<br><code>var result=add(2)(3)(4);</code></p><blockquote><p>输出的result为9,符合题目的要求<br>然后再考虑他的拓展性<br>上面的代码符合我只调用3次函数的情况，<br>如果要求计算<br><code>var result=add(2)(3)(4)(5);</code><br>上面的实现代码就歇菜了~~~<br>子所以出现问题是上面的实现最后返回一个变量值，而不是一个函数对象。<br>好吧，那么我们按前面的写法，继续返回函数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function add(num)&#123;</span><br><span class="line">    var sum=0;</span><br><span class="line">    sum= sum+num;</span><br><span class="line">    return function(numB)&#123;</span><br><span class="line">        sum= sum+ numB;</span><br><span class="line">        return function(numC)&#123;</span><br><span class="line">            sum= sum+ numC;</span><br><span class="line">            return function(numD)&#123;</span><br><span class="line">                sum= sum+ numD;</span><br><span class="line">                return function....</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>接下来的问题是如果要调用的次数是未知的（实际上也是未知的），继续按上面代码的写法，是一个不可能完成的任务<br>但是我们可以发现返回的每一个函数执行的逻辑都是一样的，就此我们可以精简下代码,让函数返回后返回自身，哈哈这就是链式调用的写法，嗯嗯add(2)(3)(4)就是一个链式调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(num)&#123;</span><br><span class="line">    var sum=0;</span><br><span class="line">    sum= sum+num;</span><br><span class="line">    return function tempFun(numB)&#123;</span><br><span class="line">        sum= sum+ numB;</span><br><span class="line">        return tempFun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>但是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var result=add(2)(3)(4)(5);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure></p><blockquote><p>并没有输出我们预料的结果14而是一个函数的字符串表示，想想也不奇怪，你每次函数调用后返回的一个函数对象，那么console.log输出就是一个函数对象的字符串表示了。<br>那么怎么能把结果输出呢？<br>2种方法<br>第1种方法,在函数中添加判断，当没有输入参数时，直接返回调用的结果而不是返回函数</p></blockquote><p>调用时和前面的有点区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var result=add(2)(3)(4)(5)();</span><br><span class="line">console.log(result);//输出14</span><br></pre></td></tr></table></figure></p><blockquote><p>第2中方法利用JS中对象到原始值的转换规则<br>当一个对象转换成原始值时，先查看对象是否有valueOf方法，如果有并且返回值是一个原始值，<br>那么直接返回这个值，否则没有valueOf或返回的不是原始值，那么调用toString方法，返回字符串表示<br>我们就为函数对象添加一个valueOf方法和toString方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function add(num)&#123;</span><br><span class="line">    var sum=0;</span><br><span class="line">    sum= sum+num;</span><br><span class="line">    var tempFun=function(numB)&#123;</span><br><span class="line">        if(arguments.length===0)&#123;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            sum= sum+ numB;r</span><br><span class="line">            return tempFun;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tempFun.valueOf=function()&#123;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    tempFun.toString=function()&#123;</span><br><span class="line">        return sum+&apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return tempFun;</span><br><span class="line">&#125;</span><br><span class="line">var result=add(2)(3)(4)(5);</span><br><span class="line">console.log(+result);//输出14 valueOf</span><br><span class="line">console.log(result);//输出14 toString</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>个人认为这样的写法很不好~函数调用语义不清晰<br>PS:还可以这样实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var add=(function()&#123;</span><br><span class="line">    var args=[];</span><br><span class="line">    function addInner()&#123;</span><br><span class="line">        if(arguments.length===0)&#123;</span><br><span class="line">            return calResult;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Array.prototype.push.apply(args,Array.prototype.splice.call(arguments,0));</span><br><span class="line">            return add;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function calResult()&#123;</span><br><span class="line">        var result=args.reduce(function(previousValue, currentValue)&#123;</span><br><span class="line">            return previousValue+currentValue;</span><br><span class="line">        &#125;,0);</span><br><span class="line">        args=[];</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    addInner.valueOf=function()&#123;</span><br><span class="line">        return calResult();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    addInner.toString=function()&#123;</span><br><span class="line">        return calResult()+&apos;&apos;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="typeof-返回七种可能的值：“number”、“string”、“boolean”、“object”、”symbol”、“function”和“undefined”。"><a href="#typeof-返回七种可能的值：“number”、“string”、“boolean”、“object”、”symbol”、“function”和“undefined”。" class="headerlink" title="typeof 返回七种可能的值：“number”、“string”、“boolean”、“object”、”symbol”、“function”和“undefined”。"></a>typeof 返回七种可能的值：“number”、“string”、“boolean”、“object”、”symbol”、“function”和“undefined”。</h2><h2 id="基础类型包括：Number、String、Boolean、Null、Undefined、Symbol（该类型位-ES2015-中新增类型）"><a href="#基础类型包括：Number、String、Boolean、Null、Undefined、Symbol（该类型位-ES2015-中新增类型）" class="headerlink" title="基础类型包括：Number、String、Boolean、Null、Undefined、Symbol（该类型位 ES2015 中新增类型）"></a>基础类型包括：Number、String、Boolean、Null、Undefined、Symbol（该类型位 ES2015 中新增类型）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="面试总结" scheme="https://93qlin.github.io/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="体会" scheme="https://93qlin.github.io/tags/%E4%BD%93%E4%BC%9A/"/>
    
      <category term="生活" scheme="https://93qlin.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>项目中第一次向数据库连续添加多条数据</title>
    <link href="https://93qlin.github.io/2019/02/28/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%91%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E7%BB%AD%E6%B7%BB%E5%8A%A0%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE/"/>
    <id>https://93qlin.github.io/2019/02/28/项目中第一次向数据库连续添加多条数据/</id>
    <published>2019-02-28T03:12:12.522Z</published>
    <updated>2019-02-28T03:12:12.522Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">toPing() &#123;</span><br><span class="line">      if (this.n &lt; 37) &#123;</span><br><span class="line">        let jse = new JSEncrypt()</span><br><span class="line">        let publicKey =</span><br><span class="line">          &apos;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDGDTI8/oBklUDPNKGOrKFGdLQuJZien2kXi5e3HaMivY/I/Q6CZcO3m3rXjJAzhfPXnAEPbfg1Kw9Ndd1mKRqn/0EdtF4zsoBfJHsVzg3/eb+2OEdmDvqf5OXzOn1i9AANwz8iCgkabzwrUF/RnQ7zYWw+EwkBFi2d0FAttDGWjQIDAQAB&apos;</span><br><span class="line">        jse.setPublicKey(publicKey)</span><br><span class="line">        let param = &#123;&#125;;</span><br><span class="line">        let formData = &#123;</span><br><span class="line">          userName: this.pinData[this.n].consumer_name,</span><br><span class="line">          userPhone: this.pinData[this.n].mobile,</span><br><span class="line">          userAge: &apos;23-55岁&apos;,</span><br><span class="line">          city: this.pinData[this.n].province_ctiy,</span><br><span class="line">          cityCode: this.pinData[this.n].city + &apos;&apos;,</span><br><span class="line">          userCreditCard: &apos;YES&apos;,</span><br><span class="line">          houseLoan: &apos;YES&apos;,</span><br><span class="line">          insurancePolicy: &apos;YES&apos;,</span><br><span class="line">          providentFund: &apos;YES&apos;,</span><br><span class="line">          encryptFlag: &quot;YES&quot;,</span><br><span class="line">          outerSource: this.pinData[this.n].outer_source,</span><br><span class="line">          source: &quot;******&quot;,</span><br><span class="line">          outerid: &quot;*****&quot;,</span><br><span class="line">          cid: this.pinData[this.n].outersource,</span><br><span class="line">        &#125;</span><br><span class="line">        param[&apos;encryptParam&apos;] = encodeURIComponent(jse.encrypt(formData[&apos;userName&apos;] + &apos;|&apos; + formData[&apos;userPhone&apos;]));</span><br><span class="line">        for (var i in formData) &#123;</span><br><span class="line">          if (i !== &apos;userName&apos; &amp;&amp; i !== &apos;userPhone&apos; &amp;&amp; formData[i] !== &apos;&apos; &amp;&amp; formData[i] !== null) &#123;</span><br><span class="line">            param[i] = formData[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $.ajax(&#123;     // 前人用得jq的ajax，待优化，，，，</span><br><span class="line">            url: &apos;*****&apos;,</span><br><span class="line">            type: &apos;get&apos;,</span><br><span class="line">            dataType: &apos;jsonp&apos;,</span><br><span class="line">            data: param,</span><br><span class="line">          &#125;)</span><br><span class="line">          .done((data) =&gt; &#123;</span><br><span class="line">            if (data.responseCode == &quot;000000&quot; || data.responseCode == &quot;900116&quot;) &#123;</span><br><span class="line">              console.log(this.pinData[this.n].order_id + &apos;\n&apos;)</span><br><span class="line">                ++this.n</span><br><span class="line">              setTimeout(() =&gt; &#123;</span><br><span class="line">                this.toPing()</span><br><span class="line">              &#125;, 200)</span><br><span class="line">              // _this.$router.push(&apos;/card/success/&apos; + &apos;submit_pingan&apos;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              Toast(&quot;操作失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .fail(() =&gt; &#123;</span><br><span class="line">            Toast(&quot;操作失败&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="项目中第一次向数据库连续添加多条数据" scheme="https://93qlin.github.io/categories/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%91%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E7%BB%AD%E6%B7%BB%E5%8A%A0%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="es6" scheme="https://93qlin.github.io/tags/es6/"/>
    
      <category term="javascript" scheme="https://93qlin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>2018面试题</title>
    <link href="https://93qlin.github.io/2019/02/28/%E7%99%BE%E5%BA%A6%E9%98%BF%E9%87%8C%E7%BD%91%E6%98%93%E5%A4%A7%E7%96%86%E7%AD%89%E5%A4%A7%E5%B0%8F%E5%8E%82%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://93qlin.github.io/2019/02/28/百度阿里网易大疆等大小厂前端面试题/</id>
    <published>2019-02-28T03:12:12.521Z</published>
    <updated>2019-02-28T03:12:12.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>怎么从十万个节点中找到想要的节点，怎么快速在某个节点前插入一个节点？</p></li><li><p>负载均衡方式和容错机制</p></li><li><p>描述一个文件从硬盘读取到进程内存中的过程</p></li><li><p>TCP三次握手和挥手的过程，除了这些书本上的还有哪些?</p></li><li><p>画一下OSI七层模型</p></li><li><p>写一个你最熟悉的算法</p></li><li><p>有哪些伪类和伪元素</p></li><li><p>IE盒模型和标准盒模型，用哪个属性改变</p></li><li><p>怎么清除浮动，原理是什么</p></li><li><p>em,rem,px的区别</p></li></ol><p>大疆<br>大疆是我校招面的第一家公司，从六月份投简历，然后笔试面试到拿到录用意向书，前后用了近四个月，来之不易啊。</p><p>一面二面<br>因为时间太久，就直接放在一起了，问的都是基础吧，讲真，大疆前端面试不难，都是很基础的，就是时间长，等的捉急。一面是电话面，两个面试官轮流问；二面是视频面，是三个面试官一起微信视频，视频面还是蛮累的，上下左右都得顾上；终面是去的现场面，就跟一个面试官聊了十几分钟人生。</p><ol><li>meta标签</li></ol><p>meta标签：提供给页面的一些元信息（名称/值对）， 比如针对搜索引擎和更新频度的描述和关键词。</p><p>name：名称/值对中的名称。常用的有author、description、keywords、generator、revised、others。 把 content 属性关联到一个名称。<br>http-equiv：没有name时，会采用这个属性的值。常用的有content-type、expires、refresh、set-cookie。把content属性关联到http头部。<br>content： 名称/值对中的值， 可以是任何有效的字符串。 始终要和 name 属性或 http-equiv 属性一起使用。<br>scheme： 用于指定要用来翻译属性值的方案。</p><ol start="2"><li>css哪些属性可以继承</li></ol><p>字体相关：line-height, font-family, font-size, font-style, font-variant, font-weight, font<br>文本相关： letter-spacing, text-align, text-indent, text-transform, word-spacing<br>列表相关：list-style-image, list-style-position, list-style-type, list-style<br>颜色：color</p><ol start="3"><li>css3有哪些新属性</li></ol><p>（1）边框：</p><p>border-radius：圆角边框，border-radius:25px;<br>box-shadow：边框阴影，box-shadow: 10px 10px 5px #888888;<br>border-image：边框图片，border-image:url(border.png) 30 30 round;<br>（2）背景：</p><p>background-size：规定背景图片的尺寸，background-size:63px 100px;<br>background-origin：规定背景图片的定位区域，背景图片可以放置于 content-box、padding-box 或 border-box 区域。background-origin:content-box;<br>CSS3 允许您为元素使用多个背景图像。background-image:url(bg_flower.gif),url(bg_flower_2.gif);<br>（3）文本效果：</p><p>text-shadow：向文本应用阴影，可以规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。text-shadow: 5px 5px 5px #FF0000;<br>word-wrap：允许文本进行换行。word-wrap:break-word;<br>（4）字体：CSS3 @font-face 规则可以自定义字体。</p><p>（5）2D 转换（transform）</p><p>translate()：元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。 transform: translate(50px,100px);<br>rotate()：元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。transform: rotate(30deg);<br>scale()：元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数。transform: scale(2,4);<br>skew()：元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数。transform: skew(30deg,20deg);<br>matrix()： 把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。transform:matrix(0.866,0.5,-0.5,0.866,0,0);<br>（6）3D 转换</p><p>rotateX()：元素围绕其 X 轴以给定的度数进行旋转。transform: rotateX(120deg);<br>rotateY()：元素围绕其 Y 轴以给定的度数进行旋转。transform: rotateY(130deg);<br>（7）transition：过渡效果，使页面变化更平滑</p><p>transition-property ：执行动画对应的属性，例如 color，background 等，可以使用 all 来指定所有的属性。<br>transition-duration：过渡动画的一个持续时间。<br>transition-timing-function：在延续时间段，动画变化的速率，常见的有：ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier 。<br>transition-delay：延迟多久后开始动画。<br>简写为：transition: [<transition-property> || <transition-duration> || <transition-timing-function> || <transition-delay>];</transition-delay></transition-timing-function></transition-duration></transition-property></p><p>（8）animation：动画</p><p>使用CSS3 @keyframes 规则。</p><p>animation-name: 定义动画名称<br>animation-duration: 指定元素播放动画所持续的时间长<br>animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)： 指元素根据时间的推进来改变属性值的变换速率，说得简单点就是动画的播放方式。<br>animation-delay: 指定元素动画开始时间<br>animation-iteration-count:infinite | <number>：指定元素播放动画的循环次<br>animation-direction: normal | alternate： 指定元素动画播放的方向，其只有两个值，默认值为normal，如果设置为normal时，动画的每次循环都是向前播放；另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。<br>animation-play-state:running | paused ：控制元素动画的播放状态。<br>简写为： animation:[<animation-name> || <animation-duration> || <animation-timing-function> || <animation-delay> || <animation-iteration-count> || <animation-direction>]</animation-direction></animation-iteration-count></animation-delay></animation-timing-function></animation-duration></animation-name></number></number></number></number></number></p><p>这里只列出了一部分，详情可以去看w3school的CSS3 教程。</p><ol start="4"><li>闭包是什么，什么时候闭包会消除?</li></ol><p>因为作用域链，外部不能访问内部的变量和方法，这时我们就需要通过闭包，返回内部的方法和变量给外部，从而就形成了一个闭包。</p><p>JavaScript是一门具有自动垃圾回收机制的编程语言，主要有两种方式：</p><p>标记清除（最常用）<br>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p><p>引用计数<br>引用计数（reference counting）的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p><p>导致问题：会导致循环引用的变量和函数无法回收。</p><p>解决：将用完的函数或者变量置为null。</p><ol start="5"><li>怎么理解js是单线程的</li></ol><p>主要说一下异步以及事件循环机制，还有事件队列中的宏任务、微任务。</p><p>macrotask：主代码块，setTimeout，setInterval、setImmediate等。<br>microtask：process.nextTick（相当于node.js版的setTimeout），Promise 。process.nextTick的优先级高于Promise。<br>更详细可以看这篇博客：这一次，彻底弄懂 JavaScript 执行机制，讲的非常清晰。</p><ol start="6"><li>有哪些排序算法，时间复杂度是多少？什么时候快排的效率最低？</li></ol><p>排序算法    最坏事件复杂度    平均时间复杂度    稳定度    空间复杂度<br>冒泡排序    O(n^2)    O(n^2)    稳定    O(1)<br>插入排序    O(n^2)    O(n^2)    稳定    O(1)<br>选择排序    O(n^2)    O(n^2)    稳定    O(1)<br>快速排序    O(n^2)    O(n<em>log2n)    不稳定    O(log2n)~O(n)<br>二叉树排序    O(n^2)    O(n</em>log2n)    不一定    O(n)<br>堆排序    O(n<em>log2n)    O(n</em>log2n)    不稳定    O(1)<br>整个序列已经有序或完全倒序时，快排的效率最低。</p><ol start="7"><li>原生ajax的请求过程</li></ol><p>创建全平台兼容的XMLHttpRequest对象：</p><p>function getXHR(){<br>  var xhr = null;<br>  if(window.XMLHttpRequest) {// 兼容 IE7+, Firefox, Chrome, Opera, Safari<br>    xhr = new XMLHttpRequest();<br>  } else if (window.ActiveXObject) {<br>    try {<br>      xhr = new ActiveXObject(“Msxml2.XMLHTTP”);// 即MSXML3<br>    } catch (e) {<br>      try {<br>        xhr = new ActiveXObject(“Microsoft.XMLHTTP”);// // 兼容 IE6, IE5，很老的api,虽然浏览器支持,功能可能不完善,故不建议使用<br>      } catch (e) {<br>        alert(“您的浏览器暂不支持Ajax!”);<br>      }<br>    }<br>  }<br>  return xhr;<br>}<br>Ajax请求数据的过程：</p><p>var xhr = getXHR();<br>xhr.open(‘GET’, url/file,true);  //设置请求方式，url，以及是否异步<br>xhr.onreadystatechange = function() {   //设置回调监听函数<br>   if(xhr.readyState==4){<br>        if(xhr.status==200){<br>            var data=xhr.responseText;<br>             console.log(data);<br>   }<br>};<br>xhr.onerror = function() {<br>  console.log(“Oh, error”);<br>};<br>xhr.send();  //发送请求</p><ol start="8"><li>http状态码，cookie字段，cookie一般存的是什么，session怎么存在的？</li></ol><p>这部分可以参考我的博客：HTTP协议知识点总结</p><ol start="9"><li>http请求方式有哪些？</li></ol><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>更多请看：HTTP请求方法</p><ol start="10"><li>怎么用原生js实现一个轮播图，以及滚动滑动</li></ol><p>之前我使用轮播图都是用的antd的组件，所以我大致说了一下思路，用定时器去实现，以及如何实现平滑的滚动效果。详情请看： 原生js实现轮播图</p><ol start="11"><li>用过哪些开源的组件</li></ol><p>说了antd和element-ui。</p><ol start="12"><li>怎么实现上传下载的功能</li></ol><p>主要说了下form表单和input标签。</p><ol start="13"><li>react生命周期，以及diff算法，diff算法是对树的深度优先遍历还是广度优先遍历？</li></ol><p>对React、Redux、React-Redux详细剖析<br>是深度优先遍历。 diff的实现</p><ol start="14"><li>强缓存和协商缓存</li></ol><p>参考：HTTP协议知识点总结</p><ol start="15"><li>react-router的原理</li></ol><p>react-router就是控制不同的url渲染不同的组件。react-router在history库的基础上，实现了URL与UI的同步。</p><p>原理：DOM渲染完成之后，给window添加onhashchange事件监听页面hash的变化，并且在state属性中添加了route属性，代表当前页面的路由。</p><p>具体步骤：</p><p>当点击链接，页面hash改变时，触发绑定在 window 上的 onhashchange 事件；<br>在 onhashchange 事件中改变组件的 state中的 route 属性，react组件的state属性改变时，自动重新渲染页面；<br>页面随着 state 中的route属性改变，自动根据不同的hash给Child变量赋值不同的组件，进行渲染。<br>参考：react-router的实现原理</p><ol start="16"><li>怎么用无人机捕获天空上的鸟</li></ol><p>这个题目我也不造啊，毕竟我没用过无人机，有知道的大神可以在评论中回答一下~</p><p>终面<br>终面是去的现场，在深圳总部那边，基本就是闲聊了二十来分钟吧，面完还有hr小姐姐给我们介绍和参观了无人机，酷炫~</p><p>做的项目中，哪个做的最深入最久<br>为什么要做前端，喜欢做前端么<br>未来的职业规划<br>了解大疆么，大疆的文化是什么<br>除了实习，还做过哪些项目<br>如果生活富足，衣食无忧，你会选择干什么<br>阿里巴巴<br>阿里是提前批，找人内推了菜鸟网络，面了六轮，面的我怀疑人生了，中途四面本来已经挂了，后面三面面试官又捞起来给我加面了一轮，不过最后还是挂在了hr。</p><p>一面</p><ol><li>css选择器，怎么选择相同的类</li></ol><p>id、class、标签、伪类、通配符等。可以用getElementsByClassName（）选择相同的类。</p><ol start="2"><li>css3有哪些伪类，伪类选择器有哪些</li></ol><p>这里要区分一下伪类和伪元素的概念。根本区别在于它们是否创造了新的元素(抽象)。</p><p>伪类：用于向某些选择器添加特殊的效果。例如，a标签的:link, :visited, :hover, :active; 以及 :first-child, :last-child。<br>伪元素：是html中不存在的元素，用于将特殊的效果添加到某些选择器。例如:before,:after, :first-letter, :first-line。css3只新增了一个伪元素 ::selection（改变用户所选取部分的样式）。<br>参考： CSS3 选择器——伪类选择器</p><ol start="3"><li>OSI七层网络模型</li></ol><p>OSI七层模型    作用    对应协议    对应设备<br>应用层    它是计算机用户，以及各种应用程序和网络之间的接口    HTTP, FTP, SMTP, POP3    计算机设备<br>表示层    信息的语法语义以及它们的关系，如加密解密、转换翻译、压缩解压缩    IPX, LPP, XDP<br>会话层    建立、维护、管理应用程序之间的会话    SSL, TLS, DAP, LDAP<br>传输层    服务点编址，分段与重组、连接控制、流量控制、差错控制    TCP, UDP    防火墙<br>网络层    为网络设备提供逻辑地址，进行路由选择、分组转发    IP ARP RARP ICMP IGMP    路由器<br>数据链路层    物理寻址，同时将原始比特流转变为逻辑传输路线    PPTP, ARP, RARP    交换机<br>物理层    机械、电子、定时接口通道信道上的原始比特流传输    IEEE 802.2, Ethernet v.2, Internetwork    网卡<br>参考： 一张非常强大的OSI七层模型图解</p><ol start="4"><li>MVC和MVVM的区别</li></ol><p>Model用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法；<br>View作为视图层，主要负责数据的展示；<br>Controller定义用户界面对用户输入的响应方式，它连接模型和视图，用于控制应用程序的流程，处理用户的行为和数据上的改变。<br>MVC将响应机制封装在controller对象中，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了。</p><p>MVVM把View和Model的同步逻辑自动化了。以前Controller负责的View和Model同步不再手动地进行操作，而是交给框架所提供的数据绑定功能进行负责，只需要告诉它View显示的数据对应的是Model哪一部分即可。也就是双向数据绑定，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。</p><p>参考： 浅析前端开发中的 MVC/MVP/MVVM 模式</p><ol start="5"><li>用过哪些设计模式</li></ol><p>（1）单例模式</p><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>实现方法：先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</p><p>适用场景：一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。</p><p>（2）发布/订阅模式<br>定义：又叫观察者模式,它定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。</p><p>场景：订阅感兴趣的专栏和公众号。</p><p>（3）策略模式<br>定义：将一个个算法（解决方案）封装在一个个策略类中。</p><p>优点：</p><p>策略模式可以避免代码中的多重判断条件。<br>策略模式很好的体现了开放-封闭原则，将一个个算法（解决方案）封装在一个个策略类中。便于切换，理解，扩展。<br>策略中的各种算法可以重复利用在系统的各个地方，避免复制粘贴。<br>策略模式在程序中或多或少的增加了策略类。但比堆砌在业务逻辑中要清晰明了。<br>违反最少知识原则，必须要了解各种策略类，才能更好的在业务中应用。<br>应用场景：根据不同的员工绩效计算不同的奖金；表单验证中的多种校验规则。</p><p>（4）代理模式</p><p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。</p><p>应用场景：图片懒加载（先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。）</p><p>（5）中介者模式</p><p>定义：通过一个中介者对象，其他所有相关对象都通过该中介者对象来通信，而不是互相引用，当其中的一个对象发生改变时，只要通知中介者对象就可以。可以解除对象与对象之间的紧耦合关系。</p><p>应用场景： 例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p><p>（6）装饰者模式</p><p>定义：在不改变对象自身的基础上，在程序运行期间给对象动态的添加方法。</p><p>应用场景： 有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。</p><p>参考： JavaScript设计模式</p><ol start="6"><li><p>Http状态码</p></li><li><p>https怎么加密</p></li></ol><p>参考： HTTP协议知识点总结</p><ol start="8"><li>es6相比es5有哪些优点</li></ol><p>大概说一下：let、const，模板字符串，箭头函数，做异步处理的promise、generator、async await，es6模块等。</p><p>参考： 阮一峰 —— ECMAScript 6 入门</p><ol start="9"><li>ajax请求过程</li></ol><p>不多说，上面有。</p><ol start="10"><li>有哪些性能优化</li></ol><p>参考：</p><p>嗨，送你一张Web性能优化地图<br>前端优化不完全指南</p><ol start="11"><li>懒加载怎么实现</li></ol><p>场景：一个页面中很多图片，但是首屏只出现几张，这时如果一次性把图片都加载出来会影响性能。这时可以使用懒加载，页面滚动到可视区在加载。优化首屏加载。</p><p>实现：img标签src属性为空，给一个data-xx属性，里面存放图片真实地址，当页面滚动直至此图片出现在可视区域时，用js取到该图片的data-xx的值赋给src。</p><p>优点：页面加载速度快，减轻服务器压力、节约流量，用户体验好。</p><ol start="12"><li>项目中写过什么组件，组件有哪些功能</li></ol><p>主要介绍了下实习项目写过的组件，说了下如何实现的。</p><p>二面</p><ol><li>react框架有哪些设计的好的地方</li></ol><p>主要介绍了以下几个部分：</p><p>JSX语法<br>组件化<br>react单项数据流<br>虚拟DOM<br>react生命周期</p><ol start="2"><li>react是怎么工作的，怎么提高性能</li></ol><p>主要还是说了下react的生命周期，还有shouldComponentUpdate这个函数，以及diff算法。</p><ol start="3"><li>redux有哪些需要改进，你觉得你用的不怎么舒服的地方？</li></ol><p>我当时说的是redux的subscribe方法有点麻烦，每次更新数据都要手动的subscribe一下，所以觉得react-redux的api封装的更好，用起来比较简单。</p><p>参考：</p><p>这段时间研究了下Redux，写写自己对它的感觉<br>Redux数据流管理架构有什么致命缺陷,未来会如何改进?</p><ol start="4"><li>怎么设计一个类似于antd 的 react 组件库</li></ol><p>这个问题把我给问懵了额，我是按照软件工程的生命周期流程来答的。</p><ol start="5"><li>你做的最自豪的一个项目</li></ol><p>这个略过…言之有理即可</p><ol start="6"><li>mysql 的左关联和右关联</li></ol><p>左关联：保留左表中所有的元组，右表中没有的属性填充NULL。</p><p>右关联：保留右表中所有的元组，左表中没有的属性填充NULL。</p><ol start="7"><li>有没有折腾过后端</li></ol><p>直接说了没有，之前学了点PHP，不过都快忘得差不多了额。</p><ol start="8"><li>学习方法和未来的学习路线</li></ol><p>言之有理即可。</p><ol start="9"><li>浏览器页面渲染机制</li></ol><p>解析html建立dom树<br>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）<br>布局render树（Layout/reflow），负责各元素尺寸、位置的计算<br>绘制render树（paint），绘制页面像素信息<br>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。<br>参考： 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</p><ol start="10"><li>XSS和CSRF防范措施</li></ol><p>（1）XSS：跨站脚本攻击</p><p>攻击方式：在URL或者页面输入框中插入JavaScript代码。</p><p>防范：</p><p>设置httpOnly，禁止用document.cookie操作；<br>输入检查：在用户输入的时候进行格式检查；<br>对输出转义。<br>（2）CSRF：跨站点伪造请求</p><p>攻击方式：攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。主要是拿到了用户的登录态。</p><p>防范：</p><p>检查 Referer 字段：这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下。<br>添加校验 Token：这种数据通常是表单中的一个数据项。服务器生成token并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 Token 的值为空或者错误，拒绝这个可疑请求。<br>通过输入验证码来校验合法请求。<br>三面<br>这一面基本问的是个人知识沉淀了，如实回答就可以了。</p><p>在项目中的难点，怎么解决的<br>你的优势是什么<br>redux 源码学到了什么，怎么看源码的<br>了解哪些前端的前沿技术<br>平时看什么书，兴趣爱好是什么<br>异步有哪些方法<br>博客写了什么<br>除了实习经历，还做过哪些项目<br>四面<br>这一面是在杭州菜鸟现场面的，尴尬的是通知我的小姐姐一直强调是hr面，我天真的以为是hr面了，然鹅问了很多技术，当时候想的是阿里的hr都这么厉害了，都能直接问技术了。临走之前，特意问了面试官是hr面么，他说是技术，然后我……大概就知道自己凉了。</p><ol><li>mysql的索引用的什么，介绍一下b树，b+树，红黑树这些</li></ol><p>mysql的索引用的是B+树。</p><p>参考： 数据结构中常见的树（BST二叉搜索树、AVL平衡二叉树、RBT红黑树、B-树、B+树、B*树）</p><ol start="2"><li>Mysql的基本写法</li></ol><p>参考： 一千行 MySQL 学习笔记</p><ol start="3"><li>估算下杭州上空现在有多少架飞机</li></ol><p>这个题目，也真的是为难我了额。在网上搜到了个答案，可以参考下：高盛的面试题</p><ol start="4"><li>两组数据，都存储五亿条url，内存有4G，如何找出相同的两条url</li></ol><p>参考： 面试- 阿里-. 大数据题目- 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?</p><ol start="5"><li>如何找到一个字符串中最长的两个字符串</li></ol><p>解法：后缀数组。首先生成字符串的所有后缀数组，在进行排序，找出相邻两个最长的公共子串（从第一位开始相同的）</p><p>例如：abcdeabc</p><p>生成后缀数组：【abcdeabc，bcdeabc，cdeabc，deabc，eabc，abc，bc，c】</p><p>再排序：【abcdeabc，abc，bcdeabc，bc，cdeabc，c，deabc，eabc】</p><p>找出相邻的最长公共子串：【abc，bc，c】</p><p>因此，最长的串是abc。</p><ol start="6"><li>在白板上画出这个项目的整个架构</li></ol><p>画了下项目的功能架构什么的。</p><ol start="7"><li>XSS, CSRF,token 怎么来的，sql 注入知道么</li></ol><p>sql注入：</p><p>攻击方式：服务器上的数据库运行非法的 SQL 语句，主要通过拼接字符串的形式来完成，改变sql语句本身的语义。通过sql语句实现无账号登陆，甚至篡改数据库。</p><p>防御：</p><p>使用参数化查询：使用预编译语句，预先编译的 SQL 语句，并且传入适当参数多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。 使用preparedStatement的参数化sql，通过先确定语义，再传入参数，就不会因为传入的参数改变sql的语义。（通过setInt，setString，setBoolean传入参数）<br>单引号转换：将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。<br>检查变量数据类型和格式。<br>使用正则表达式过滤传入的参数，对特殊符号过滤或者转义处理。</p><ol start="8"><li><p>怎么设计一个ant的组件</p></li><li><p>你觉得你实习做的项目有什么改进的地方</p></li><li><p>你做过印象最深刻的项目</p></li><li><p>算法了解过吗</p></li></ol><p>就知道一些基本的排序额…</p><ol start="12"><li>Setstate 会发生什么</li></ol><p>setState会引发一次组件的更新过程，从而引发页面的重新绘制。主要会涉及以下几个生命周期函数：</p><p>shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）<br>componentWillUpdate（被调用时this.state没有更新）<br>render（被调用时this.state得到更新）<br>componentDidUpdate</p><ol start="13"><li>平时处理过什么兼容性</li></ol><p>参考： web前端兼容性问题总结</p><ol start="14"><li>了解分布式和负载均衡么</li></ol><p>然鹅我并不了解呃。</p><p>参考： 服务器负载均衡的基本功能和实现原理</p><p>五面<br>第四面确实是挂了，没面hr就让我走了，后面过了两天之后，三面面试官又把我捞起来了，说我计算机基础还有数据库基础不怎么好，然后说问我几个简单的，之后给了我机会面了hr，感谢三面面试官让我体验了阿里的整个面试流程，很满足了。</p><ol><li>进程和线程的区别</li></ol><p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。<br>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。<br>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。<br>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。<br>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><ol start="2"><li>冒泡排序和快速排序的区别</li></ol><p>简述了下冒泡和快排的思想，以及冒泡和快排的时间复杂度。</p><ol start="3"><li>OSI七层模型以及作用</li></ol><p>上面有写噢，不知道的往上翻。</p><ol start="4"><li>你有哪些优势，或者打动他的</li></ol><p>呃，最怕这种自夸的问题额，然后就是夸了一顿，手动捂脸。</p><ol start="5"><li>面向对象和非面向对象有什么区别</li></ol><p>面向对象三大特性：封装,继承,多态。</p><p>面向对象的好处：</p><p>将对象进行分类，分别封装它们的数据和可以调用的方法，方便了函数、变量、数据的管理，方便方法的调用（减少重复参数等），尤其是在编写大型程序时更有帮助。<br>用面向对象的编程可以把变量当成对象进行操作，让编程思路更加清晰简洁，而且减少了很多冗余变量的出现<br>参考： 面向对象（一）|面向对象概念及优点</p><ol start="6"><li>设计模式有哪些，说下装饰者模式和代理模式</li></ol><p>前面有总结，往前翻。</p><ol start="7"><li>重载和重写有什么区别</li></ol><p>方法重写(overriding)：</p><p>也叫子类的方法覆盖父类的方法，要求返回值、方法名和参数都相同。<br>子类抛出的异常不能超过父类相应方法抛出的异常。(子类异常不能超出父类异常)<br>子类方法的的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)。<br>方法重载(overloading):</p><p>重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但是参数却不相同，方法体也不相同，最常见的重载的例子就是类的构造函数。</p><p>参考： 方法重载和重写的区别</p><p>hr面<br>为什么选择前端开发<br>什么事情让你最有成就感<br>什么让你最有挫败感<br>为什么选择阿里<br>平时是怎么学习的<br>职业发展<br>百度<br>二面三面都有手写代码的环节，对于我这种动手能力弱的人来说还是挺吃力。当时提前批投递的是深圳百度，总共只招五个前端，没过也很正常。后面正式批笔试过了，但是要去北京面试，也就直接放弃了。</p><ol><li>为什么要用flex布局，align-items和justify-content的区别</li></ol><p>传统布局基于盒模型，非常依赖 display属性 、position属性 、float属性。而flex布局更灵活，可以简便、完整、响应式地实现各种页面布局，比如水平垂直居中。</p><p>align-items：定义在垂直方向上的对齐方式；</p><p>justify-content：定义在水平方向上的对齐方式。</p><ol start="2"><li>webpack是怎么打包的，babel又是什么？</li></ol><p>把项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p><p>babel将es6、es7、es8等语法转换成浏览器可识别的es5或es3语法。</p><ol start="3"><li>saas和less不同于普通css的地方</li></ol><p>定义变量，可以把反复使用的css属性值定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值；<br>嵌套写法，父子关系一目了然；<br>使用运算符，可以进行样式的计算；<br>内置一些颜色处理函数用来对颜色值进行处理，例如加亮、变暗、颜色梯度等；<br>继承：为多个元素定义相同样式的时候，我们可以考虑使用继承的做法；<br>Mixins （混入）：有点像是函数或者是宏，当某段 CSS经常需要在多个元素中使用时，可以为这些共用的 CSS 定义一个Mixin，然后只需要在需要引用这些 CSS 地方调用该 Mixin 即可。</p><ol start="4"><li>es 6模块和其他模块不同的地方</li></ol><p>对比了一下es6模块和CommonJS模块：</p><p>区别    CommonJS    es6<br>加载原理    第一次加载模块就会执行整个模块，再次用到时，不会执行该模块，而是到缓存中取值。    不会缓存运行结果，动态的去被加载的模块中取值，并且变量总是绑定其所在模块。<br>输出    值的拷贝（模块中值的改变不会影响已经加载的值）    值的引用（静态分析，动态引用，原来模块值改变会改变加载的值）<br>加载方式    运行时加载（加载整个模块，即模块中的所有接口）    编译时加载（只加载需要的接口）<br>this指向    指向当前模块    指向undefined<br>循环加载    只输出已经执行的部分，还未执行的部分不会输出    遇到模块加载命令import时不会去执行模块，而是生成一个动态的只读引用，等到真正用到时再去模块中取值。只要引用存在，代码就能执行。</p><ol start="5"><li>有没有用过es6的一些异步处理函数</li></ol><p>Promise，generator，async await</p><ol start="6"><li>redux怎么处理异步操作</li></ol><p>可以引入Redux-thunk或者redux-promise这种中间件，可以延迟事件的派发。</p><p>其中的原理：是因为他们用了applymiddleware()包装了store的dispatch方法，拥有可以处理异步的能力。</p><ol start="7"><li>为什么reducer要是个纯函数，纯函数是什么？</li></ol><p>纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p><p>原因：Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同（浅比较）。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。两个state相同的话，页面就不会重新渲染了。</p><p>因为比较两个Javascript对象所有的属性是否相同的的唯一方法是对它们进行深比较。但是深比较在真实的应用当中代价昂贵，因为通常js的对象都很大，同时需要比较的次数很多。因此一个有效的解决方法是作出一个规定：无论何时发生变化时，开发者都要创建一个新的对象，然后将新对象传递出去。同时，当没有任何变化发生时，开发者发送回旧的对象。也就是说，新的对象代表新的state。</p><ol start="8"><li>高阶函数是什么，怎么去写一个高阶函数</li></ol><p>高阶函数：参数值为函数或者返回值为函数。例如map，reduce，filter，sort方法就是高阶函数。</p><p>编写高阶函数，就是让函数的参数能够接收别的函数。</p><ol start="9"><li>vue跟react的区别是什么</li></ol><p>没有用过vue，所以就只说了vue具有双向绑定，react是单向数据流。</p><p>参考： Vue.js与React的全面对比</p><ol start="10"><li>nodejs处理了什么问题</li></ol><p>可以处理高并发的I/O，也能与websocket配合，开发长连接的实时交互应用程序。</p><ol start="11"><li>响应式布局，怎么做移动端适配</li></ol><p>使用媒体查询可以实现响应式布局。</p><p>移动端适配方案：</p><p>（1）meta viewport：让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。</p><p><meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><br>width=device-width: 让当前viewport宽度等于设备的宽度</p><p>user-scalable=no: 禁止用户缩放</p><p>initial-scale=1.0: 设置页面的初始缩放值为不缩放</p><p>maximum-scale=1.0: 允许用户的最大缩放值为1.0</p><p>minimum-scale=1.0: 允许用户的最小缩放值为1.0</p><p>（2）媒体查询（响应式)</p><p>（3）动态 rem 方案</p><p>参考： 移动端是怎么做适配的？</p><p>二面</p><ol><li>怎么做一个实时的聊天系统</li></ol><p>使用WebSocket和nodejs，《nodejs实战》这本书详细介绍了这个项目。</p><ol start="2"><li>当消息有延迟的时候，怎么保证消息的正确顺序</li></ol><p>每个消息在被创建时，都将被赋予一个全局唯一的、单调递增的、连续的序列号（SerialNumber，SN）。可以通过一个全局计数器来实现这一点。通过比较两个消息的SN，确定其先后顺序。</p><ol start="3"><li>怎么做一个登陆窗口，input有哪些兼容性</li></ol><p>使用form表单。</p><ol start="4"><li>input按钮如何校验</li></ol><p>使用正则表达式。</p><ol start="5"><li>如何实现水平垂直居中，relative、absolute、fixed</li></ol><p>我说了三种方式：</p><p>（1）使用表格</p><p>.container{<br>  width: 600px;<br>  height: 600px;<br>  background: #eee;<br>  display: table-cell;<br>  text-align: center;<br>  vertical-align: middle;<br>}<br>.center{<br>  background: blue;<br>}<br>（2）css3的transform属性</p><p>.container{<br>  width: 100%;<br>  height: 400px;<br>  background: #eee;<br>  position: relative;<br>}<br>.center{<br>  background: blue;<br>  position:absolute;<br>  top: 50%;<br>  left: 50%;<br>  transform: translate(-50%, -50%);<br>}<br>（3）flex布局</p><p>.container{<br>  width: 100%;<br>  height: 400px;<br>  background: #eee;<br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br>}<br>.center{<br>  width: 100px;<br>  height: 100px;<br>  background: blue;<br>  text-align: center;<br>}<br>relative：相对于自己的定位；<br>absolute：相对于最近一级定位元素的定位；<br>fixed：相对于窗口的定位。</p><ol start="6"><li>写一个函数，1s之后依次输出1,2,3,4,5</li></ol><p>直接使用了let和定时器。</p><p>for(let i = 1 ; i &lt; 6; i++){<br>    setTimeout(() =&gt; {<br>        conosle.log(i)<br>    }, 1000)<br>}</p><ol start="7"><li>事件队列（宏任务、微任务）</li></ol><p>参考：：这一次，彻底弄懂 JavaScript 执行机制</p><ol start="8"><li>如何每隔三个数加一个逗号，还要考虑小数点的情况</li></ol><p>这道题就是大疆的笔试题，当时候笔试题也是瞎写的，后面也没仔细看，没想到又成了一道面试题。</p><p>function transform(number){<br>    var num = number.toString()<br>    var numArr = num.split(‘.’)<br>    var [num, dotNum] = numArr</p><pre><code>var operateNum = num.split(&apos;&apos;).reverse()var result = [], len = operateNum.lengthfor(var i = 0; i&lt; len; i++){     result.push(operateNum[i])     if(((i+1) % 3 === 0) &amp;&amp; (i !== len-1)){          result.push(&apos;,&apos;)    }}if(dotNum){     result.reverse().push(&apos;.&apos;， ...dotNum)     return result.join(&apos;&apos;)}else{     return result.reverse().join(&apos;&apos;)}</code></pre><p>}</p><ol start="9"><li>webpack有配置过吗？原理知道吗</li></ol><p>参考前面。</p><ol start="10"><li>父子组件如何通信，子组件怎么跟父组件通信？</li></ol><p>父组件把state作为props传递给子组件进行通信。</p><p>父组件写好state和处理该state的函数，同时将函数名通过props属性值的形式传入子组件，子组件调用父组件的函数，同时引起state变化。</p><ol start="11"><li>简单说一下pwa</li></ol><p>面试的这个部门就是做pwa的，所以说了下自己对pwa的理解。</p><p>三面</p><ol><li>手写indexOf</li></ol><p>function indexOf(str, val){<br>    var strLen = str.length, valLen = val.length<br>    for(var i = 0; i &lt; strLen; i++){<br>        var matchLen = i + valLen<br>        var matchStr = str.slice(i, matchLen)<br>        if(matchLen &gt; strLen){<br>            return -1<br>        }<br>        if(matchStr === val){<br>            return i<br>        }<br>    }<br>    return -1<br>}</p><ol start="2"><li>实现 JS 的继承</li></ol><p>function A () {<br>   this.name = ‘a’;<br>}</p><p>A.prototype.getName = function () {<br>    return this.name;<br>}</p><p>function B () {<br>}</p><p>// B 如何继承 A<br>参考： JS实现继承的几种方式</p><ol start="3"><li>从url输入到页面显示会有哪些步骤</li></ol><p>（1）DNS服务器解析域名，找到对应服务器的IP地址;</p><p>（2）和服务器建立TCP三次握手连接；</p><p>（3）发送HTTP请求，服务器会根据HTTP请求到数据服务器取出相应的资源，并返回给浏览器；</p><p>（4）浏览器处理响应</p><p>加载：浏览器对一个html页面的加载顺序是从上而下的。<br>当加载到外部css文件、图片等资源，浏览器会再发起一次http请求，来获取外部资源。<br>当加载到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，等待js文件加载、解析完毕才可以恢复html文档的渲染线程。</p><p>解析：解析DOM树和CSSDOM树。<br>渲染：构建渲染树，将DOM树进行可视化表示，将页面呈现给用户。</p><ol start="4"><li>method有哪些方法，分别是什么意思？post和put的区别</li></ol><p>post：上传资源</p><p>put：修改资源</p><ol start="5"><li><p>https有几次握手</p></li><li><p>http2比http1好的地方</p></li></ol><p>主要是考察http2的几个特性。</p><p>参考：HTTP协议知识点总结</p><ol start="7"><li>页面刷新不出来，是有哪些问题</li></ol><p>可以从第三题的每个步骤进行分析，大概是：</p><p>域名不存在，或者ip地址错误<br>网络问题，不能建立正常的tcp连接<br>服务器找不到正确的资源</p><ol start="8"><li>上一次系统性的学习是什么时候，怎么学习的</li></ol><p>学习react的时候，看文档、博客，照着网上写了点小项目。</p><ol start="9"><li><p>你觉得项目中最自豪的是什么</p></li><li><p>上家公司有哪些不好的地方</p></li></ol><p>网易<br>网易是在杭州网易大厦面的，一天面完三轮，然后录用排序，择优录取的吧。我投的是网易考拉，哭唧唧，后面被拒了之后还伤心的卸载了考拉。之后正式批投了杭研，过了笔试，要去武汉面，本来海康也是在武汉面的，考虑到还要住一晚上，有点怕怕，就没去了。</p><p>1.css3动画</p><ol start="2"><li><p>flex布局</p></li><li><p>实现call</p></li></ol><p>Function.prototype.call2 = function (context) {<br>    var context = Object(context) || window<br>    context.fn = this<br>    var args = []<br>    for (var i = 1; i &lt; arguments.length; i++) {<br>        args.push(‘arguments[‘ + i +’]’)<br>    }</p><pre><code>var res = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)delete context.fnreturn res</code></pre><p>}</p><ol start="4"><li><p>图片懒加载data-src</p></li><li><p>Promise异步</p></li><li><p>水平垂直居中</p></li><li><p>数组有哪些方法，哪些会改变原数组</p></li></ol><p>改变原数组的方法：pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill；</p><p>不改变原数组（复制）：concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf、未标准的toSource以及ES7新增的方法includes；</p><p>循环遍历：forEach、every、some、filter、map、reduce、reduceRight 以及ES6新增的方法entries、find、findIndex、keys、values。</p><ol start="8"><li>操作dom有哪些方法</li></ol><p>创建：</p><p>  createDocumentFragment()    //创建一个DOM片段<br><br>  createElement()   //创建一个具体的元素<br><br>  createTextNode()   //创建一个文本节点<br></p><p>添加：appendChild()</p><p>移出：removeChild()</p><p>替换：replaceChild()</p><p>插入：insertBefore()</p><p>复制：cloneNode(true)</p><p>查找：</p><p>  getElementsByTagName()    //通过标签名称<br><br>  getElementsByClassName()    //通过标签名称<br><br>  getElementsByName()    //通过元素的Name属性的值<br><br>  getElementById()    //通过元素Id，唯一性</p><ol start="9"><li>左边定宽右边自适应</li></ol><p>（1）左盒子左浮动，右盒子width=100%</p><p>（2）左盒子左浮动，右盒子margin-left=左盒子宽度</p><p>（3）左盒子左浮动，右盒子右浮动，设置calc（100vw-盒子宽度）</p><p>（4）父容器设置display=flex，右盒子flex：1</p><ol start="10"><li>事件代理</li></ol><p>利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行。打个比方：一个button对象，本来自己需要监控自身的点击事件，但是自己不来监控这个点击事件，让自己的父节点来监控自己的点击事件。</p><ol start="11"><li>后端了解么</li></ol><p>直接说了不了解，笑哭。</p><p>二面</p><ol><li>节流和防抖，手写一下代码</li></ol><p>（1）防抖：</p><p>定义： 合并事件且不会去触发事件，当一定时间内没有触发这个事件时，才真正去触发事件。</p><p>原理：对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。</p><p>场景： keydown事件上验证用户名，输入法的联想。</p><p>实现：</p><p>function debounce(fn, delay) {<br>    var timer</p><pre><code>return function () {    var that = this    var args = arguments    clearTimeout(timer)        timer = setTimeout(function () {        fn.apply(that, args)    }, delay)}</code></pre><p>}<br>（2）节流：</p><p>定义： 持续触发事件时，合并一定时间内的事件，在间隔一定时间之后再真正触发事件。每间隔一段时间触发一次。</p><p>原理：对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。</p><p>场景： resize改变布局时，onscroll滚动加载下面的图片时。</p><p>实现：</p><p>方法一：使用时间戳。<br>当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为0)，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p><p>缺陷：第一次事件会立即执行，停止触发后没办法再激活事件。</p><p>function throttle(fn, interval) {<br>    var previousTime = +new Date()</p><pre><code>return function () {    var that = this    var args = arguments    var now = +new Date()    if (now - previousTime &gt;= interval) {        previousTime = now        fn.apply(that, args)    }</code></pre><p>   }<br>}<br>方法二：使用定时器<br>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p><p>缺陷：第一次事件会在n秒后执行，停止触发后依然会再执行一次事件。</p><p>function throttle(fn, interval) {<br>    var timer<br>    return function (){<br>        var that = this<br>        var args = arguments</p><p>   if(!timer){<br>        timer = setTimeout(function () {<br>            fn.apply(that, args)<br>            timer = null<br>         }, interval)<br>        }<br>    }<br>}<br>方法三：优化<br>鼠标移入能立刻执行，停止触发的时候还能再执行一次。</p><p>var throttle = function(func,delay){<br>    var timer = null;<br>    var startTime = Date.now();</p><pre><code>return function(){    var curTime = Date.now();    var remaining = delay-(curTime-startTime);    var context = this;    var args = arguments;    clearTimeout(timer);    if(remaining&lt;=0){        func.apply(context,args);        startTime = Date.now();    }else{        timer = setTimeout(func,remaining);    }}</code></pre><p>}</p><ol start="2"><li><p>知道哪些性能优化</p></li><li><p>react为什么比其他要快，虚拟dom知道吗</p></li><li><p>写过什么组件</p></li><li><p>平时怎么学习的</p></li><li><p>node，webpack了解么</p></li><li><p>模块化，commonjs,es6模块</p></li><li><p>redux怎么实现的</p></li></ol><p>hr面<br>项目上有哪些难点，项目中学到了什么<br>不喜欢跟什么样的人共事<br>平时怎么学习<br>为什么来杭州<br>职业发展<br>搜狗<br>搜狗是内推的，面试也很迷，第一面到第二面中间隔了二十几天，然后二面完了也毫无反馈。</p><p>一面</p><ol><li><p>说一下项目，整个网络过程，从前端到后台</p></li><li><p>Ajax 底层实现，readystate 有哪些</p></li></ol><p>0-（未初始化）还没有调用send()方法</p><p>1-（载入）已调用send()方法，正在发送请求</p><p>2-（载入完成）send()方法执行完成，已经接收到全部响应内容</p><p>3-（交互）正在解析响应内容</p><p>4-（完成）响应内容解析完成，可以在客户端调用了</p><ol start="3"><li><p>状态码有哪些，100,307</p></li><li><p>OSI七层模型</p></li><li><p>TCP三次握手</p></li><li><p>SSL握手过程</p></li><li><p>jQuery 有哪些方法</p></li><li><p>display 有哪些属性，说一下flex的属性</p></li><li><p>Es6的async awiat ，generator</p></li><li><p>Map有哪些方法</p></li></ol><p>Map的方法：set, get, has, delete, clear</p><p>遍历方法：</p><p>keys()：返回键名的遍历器。</p><p>values()：返回键值的遍历器。</p><p>entries()：返回所有成员的遍历器。</p><p>forEach()：遍历 Map 的所有成员。</p><p>参考： Set 和 Map 数据结构</p><ol start="11"><li><p>正则用过吗？exec, 匹配一个手机号</p></li><li><p>css3动画了解吗，怎么写一个loading动画</p></li><li><p>怎么实现跨域,cors涉及哪些请求字段</p></li><li><p>编程: 判断两个网络地址是否属于同一个子网掩码</p></li></ol><p>用与运算符就可以了。当时是在牛客网的面试系统上写的，一直AC不出，也是很迷了额。</p><ol start="15"><li>怎么上传文件</li></ol><p>二面</p><ol><li>怎么计算在一个页面上的停留时间</li></ol><p>方案1：websocket，前端开个长连接，后台统计长连接时间。</p><p>方案2：ajax轮询，隔几秒发一个查询，后台记录第一与最后一个查询间隔时间。</p><p>方案3： 关闭窗口或者跳转的时候会触发window.onbeforeunload函数，可以在该函数中做处理（有兼容性问题）；统计完数据记录到本地cookies中，一段时间后统一发送。</p><ol start="2"><li>给你一亿个数，是连续的，怎么找出两个不存在的数</li></ol><p>用bitmap就能搞定了，存在为1，不存在为0。</p><ol start="3"><li>一个搜索框的输入联想，会遇到什么问题？如果第一个请求延迟，第二个请求先到，请问怎么处理？</li></ol><p>键盘输入太快，每次输入都去联想，需要多次发送请求，会导致用户体验太差，可以使用防抖优化。</p><p>在前端做判断，判断此时的值是否与返回的值相同，不同就丢弃，相同就显示在页面。</p><ol start="4"><li><p>Http的缓存</p></li><li><p>二维码怎么工作的，扫描pc端的二维码，怎么让pc端登录？</p></li></ol><p>pc端随机生成一个含有唯一uid的二维码，并与服务器建立一个长连接；<br>手机扫描二维码，解析出二维码中的uid，并把这个uid和手机端的用户密码进行绑定，上传给服务器；<br>服务器获得客户端信息之后，pc端的长连接轮询操作会获得该消息，显示该账号的信息；<br>pc端会再开一个长连接与手机端保持通信，等待手机端确认登陆后，获得服务器授权的token，就可以在pc端登陆进行正常通信了。</p><ol start="6"><li>Promise 做什么的，有哪几种状态</li></ol><p>异步处理的，有三个状态：resolve，pending，reject。</p><ol start="7"><li><p>项目有哪些难点，怎么处理的</p></li><li><p>遇到过哪些性能优化</p></li></ol><p>电信IT研发中心<br>当时听说电信对学历要求很高，本科基本都是211起的，想着自己本科太渣，就直接放弃了网上的笔试。之后电信来了学校宣讲会，跟朋友吃完饭看到了，就去说凑凑热闹，刚好有笔试也就做了。做完之后笔试居然考了最高分，比第二名高出二十分，手动捂脸额。一面完分数也挺高的，有95分，运气爆棚。重点是今年电信开的薪资实在太高了，目前还在纠结选哪个。</p><ol><li>Xhtml和html的区别</li></ol><p>XHTML 元素必须被正确地嵌套。<br>XHTML 元素必须被关闭。<br>标签名必须用小写字母。<br>XHTML 文档必须拥有根元素。</p><ol start="2"><li><p>遇到过哪些兼容性问题</p></li><li><p>浏览器内核有哪些，移动端用的是哪个</p></li></ol><p>Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。[又称为MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等；<br>Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink]<br>Webkit内核：Safari,Chrome等。[Chrome的:Blink(Webkit的分支)]<br>对于Android手机而言，使用率最高的就是Webkit内核。</p><ol start="4"><li><p>怎么实现标签页的通信</p></li><li><p>Cookie、session,localstorage，sessionstorage</p></li><li><p>React 和jquery 之间的区别，哪个好用</p></li><li><p>怎么实现继承</p></li><li><p>Es6,es7有哪些特性</p></li><li><p>怎么跨域</p></li><li><p>Commonjs用的js哪个特性?</p></li></ol><p>因为js之前只能在浏览器运行，为了能让js能在服务器上运行，所以设计了commonjs规范，而且js之前没有模块化的概念。</p><ol start="11"><li><p>选择器优先级</p></li><li><p>伪类知道吗，有哪些</p></li><li><p>块级元素有哪些，怎么转成行内元素</p></li><li><p>一个完整的http请求，页面渲染过程，js和css文件怎么渲染</p></li></ol><p>二面<br>一面问的都很常规的，不知道为啥给了这么高的分。二面的时候三个面试官，总共就问了三个问题，然后就说面试结束了，不超过五分钟。</p><ol><li>TCP怎么工作的</li></ol><p>三次握手</p><ol start="2"><li>OSI七层模型，路由器工作在哪一层？</li></ol><p>网络层</p><ol start="3"><li>平时用什么语言，用过哪些框架</li></ol><p>深信服<br>深信服给的薪资居然比电信还低，而且加班还严重，就直接拒了。</p><p>一面</p><ol><li><p>跨域，同源策略，webpack里面有个跨域的方式知道么</p></li><li><p>怎么把es6转成es5，babel怎么工作的</p></li></ol><p>解析：将代码字符串解析成抽象语法树<br>变换：对抽象语法树进行变换操作<br>再建：根据变换后的抽象语法树再生成代码字符串</p><ol start="3"><li><p>反向代理知道么，Nginx</p></li><li><p>继承有哪些方式</p></li><li><p>怎么实现一个sleep ，手写一个promise</p></li><li><p>能写一个二叉树么，怎么去遍历</p></li><li><p>深拷贝怎么写</p></li></ol><p>（1）var new_arr = JSON.parse( JSON.stringify(arr) );</p><p>（2）for in 加递归</p><p>function isObj(obj) {<br>//判断是否为对象或者函数，但不是null<br>    return (typeof obj === ‘object’ || typeof obj === ‘function’) &amp;&amp; obj !== null<br>}</p><p>function deepCopy(obj) {<br>    let newObj = Array.isArray(obj) ? [] : {}<br>    for(let key in obj) {<br>        newObj[key] = isObj(obj[key]) ? deepCopy(obj[key]) : obj[key]<br>    }<br>    return newObj<br>}<br>（3）$.extend()</p><p>（4）函数库lodash，提供_.cloneDeep（）</p><ol start="8"><li><p>在公司除了完成上级交待的任务，还做了什么</p></li><li><p>怎么实现垂直中间布局</p></li><li><p>Call和apply，哪个性能开销大</p></li></ol><p>在思否上提问了，已有大神回答。</p><p>参考： call和apply的哪个性能更好</p><ol start="11"><li><p>正则写一个手机号，全局匹配是什么</p></li><li><p>删除一个数组中的某个数</p></li></ol><p>splice方法</p><ol start="13"><li><p>模块化介绍一下，什么是编译时优化</p></li><li><p>有哪些网络安全名词，怎么防范</p></li><li><p>平时怎么学习</p></li></ol><p>二面<br>二面小哥哥问了几个问题之后，就一直跟我介绍深信服内部的一些管理、技术氛围、晋升机制什么的，全程都是笑脸额。</p><ol><li>git push -u 是什么意思</li></ol><p>绑定默认提交的远程版本库，加了参数-u后，以后即可直接用git push 代替git push origin master</p><ol start="2"><li>git rebase解释下</li></ol><p>有test和dev两个分支，分别有两个commit，此时执行下列命令：</p><p>git checkout test<br>git rebase dev<br>以dev为基准将test的提交进行回放，挨个的应用到dev上去，然后test的那些提交就会废弃。 等价于git merge dev。</p><p>git merge 和git rebase区别：</p><p>merge不会修改提交历史，rebase会修改提交历史<br>。</p><p>rebase只应用于本地没有提交的代码，如果应用到已经提交到远程的分支不要应用，不然会非常的麻烦，git merge 可以应用于远程分支。</p><ol start="3"><li>linux命令，怎么打开一个文件</li></ol><p>cat abc.txt</p><ol start="4"><li><p>你的上级给你review 代码时会提什么建议</p></li><li><p>怎么看待加班和工作效率</p></li><li><p>get和post分别进行几次数据交互</p></li></ol><p>get请求过程：（2次交互）</p><p>浏览器请求tcp连接（第一次握手） 　　<br>服务器答应进行tcp连接（第二次握手） 　　<br>浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送） 　　<br>服务器返回200 ok响应。<br>post请求过程：（3次交互）</p><p>浏览器请求tcp连接（第一次握手） 　　<br>服务器答应进行tcp连接（第二次握手） 　　<br>浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送） 　　<br>服务器返回100 continue响应 　　<br>浏览器开始发送数据 　　<br>服务器返回200 ok响应</p><ol start="7"><li>怎么打断点，如何确定一个结果来自于哪个函数</li></ol><p>ThoughtWorks<br>TW是内推的，做了内推作业后，就面了技术和文化面。技术面是在作业的基础上加两个功能，只写出来一个，后面一个没时间写了，然后就只讲了下思路。</p><p>文化面面了快一个小时，听说TW不加班，对女程序员还很友好，挺中意的公司，不过最后还是挂了额。</p><p>华为<br>华为的面试就不多说了，基本不问前端的，进去是随机分岗的。华为的面试阵仗是我见过的最大的，听说要招一万人，在万达那里面的，全是人啊，阔怕。现在正泡在offer池里，估计国庆后发正式offer吧。</p><p>二面碰到的是个女面试官，太恐怖了，一直在怼我，最怕碰到女面试官了，惨。</p><p>小米<br>小米是内推的，电话面了一面，国庆后要我去武汉现场面，那会学校刚好有事应该也不会去了。</p><ol><li><p>redux主要做什么的，用过redux的一些中间件吗，简单说一下</p></li><li><p>react生命周期说一下，diff算法说一下</p></li><li><p>setstate时会合并修改，是在哪个函数里修改的？宏事件和微事件</p></li></ol><p>setstate是异步更新的，通过一个队列机制实现state的更新，当执行setState时，会将需要更新的state合并后放入状态队列，而不会立即更新，队列可以高效的批量更新state。</p><ol start="4"><li>let、const、var的区别；如果const定义的是个对象，能够修改对象的属性吗？</li></ol><p>const实际上保证的并不是变量的值不得改动，而是变量指向的那个指针不得改动，可以给对象添加属性。如果真的想将对象冻结，应该使用Object.freeze方法。</p><ol start="5"><li>Object.freeze和Object.seal的区别</li></ol><p>Object.preventExtension：禁止对象添加新属性并保留已有属性;</p><p>Object.seal：在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false;</p><p>Object.freeze：在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false。</p><ol start="6"><li><p>说一下防抖，应用场景是什么</p></li><li><p>快速排序算法说下，基点怎么选？如果一个数组是已经排序好的怎么选基点？</p></li></ol><p>数组元素随机，取固定基准；<br>数组元素已排序或逆序，取随机基准；<br>更好的方法：三数取中，选取数组开头，中间和结尾的元素，通过比较，选择中间的值作为快排的基准。</p><ol start="8"><li><p>算法的稳定性，冒泡、快排</p></li><li><p>lodash，underscore的库了解么？有哪些方法</p></li><li><p>整个项目的架构，包括前端、后台、运营</p></li><li><p>sort的底层实现机制，看过源码么？</p></li></ol><p>数组长度&lt;=22时采用插入排序，大于22用快排。</p><ol start="12"><li>怎么调试bug？打过断点么？如果前端代码被压缩，如何去找到相应元素？</li></ol><p>chromre控制台下，在 Scripts 面板下面有个 Pretty print 按钮(这种符号 {})，点击会将压缩 js 文件格式化缩进规整的文件，这时候在设定断点可读性就大大提高了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="2018面试题" scheme="https://93qlin.github.io/categories/2018%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://93qlin.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>扁平化数据树形化 ,树形数据扁平化</title>
    <link href="https://93qlin.github.io/2019/02/28/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%89%81%E5%B9%B3%E5%8C%96%EF%BC%8C%E6%89%81%E5%B9%B3%E5%8C%96%E6%95%B0%E6%8D%AE%E6%A0%91%E5%BD%A2%E5%8C%96/"/>
    <id>https://93qlin.github.io/2019/02/28/树形数据扁平化，扁平化数据树形化/</id>
    <published>2019-02-28T03:12:12.521Z</published>
    <updated>2019-02-28T03:12:12.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="扁平化数据树形化"><a href="#扁平化数据树形化" class="headerlink" title="扁平化数据树形化"></a>扁平化数据树形化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">var  list = [</span><br><span class="line">  &#123;&quot;Id&quot;: 19,</span><br><span class="line">  &quot;Name&quot;: &quot;App&quot;,</span><br><span class="line">  &quot;PId&quot;: null,</span><br><span class="line">  &quot;Order&quot;: 1,</span><br><span class="line">  &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">  &#123;&quot;Id&quot;: 1025,</span><br><span class="line">  &quot;Name&quot;: &quot;企业查询&quot;,</span><br><span class="line">  &quot;PId&quot;: 19,</span><br><span class="line">  &quot;Order&quot;: 1,</span><br><span class="line">  &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;Id&quot;: 1051,</span><br><span class="line">  &quot;Name&quot;: &quot;企业列表&quot;,</span><br><span class="line">  &quot;PId&quot;: 1025,</span><br><span class="line">  &quot;Order&quot;: 1,</span><br><span class="line">  &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1029,</span><br><span class="line">    &quot;Name&quot;: &quot;企业明细&quot;,</span><br><span class="line">    &quot;PId&quot;: 1025,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">&#125;,&#123;</span><br><span class="line">     &quot;Id&quot;: 1030,</span><br><span class="line">     &quot;Name&quot;: &quot;投标战绩&quot;,</span><br><span class="line">     &quot;PId&quot;: 1025,</span><br><span class="line">     &quot;Order&quot;: 3,</span><br><span class="line">     &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;Id&quot;: 1026,</span><br><span class="line">     &quot;Name&quot;: &quot;业绩查询&quot;,</span><br><span class="line">     &quot;PId&quot;: 19,</span><br><span class="line">     &quot;Order&quot;: 2,</span><br><span class="line">     &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;Id&quot;: 1031,</span><br><span class="line">     &quot;Name&quot;: &quot;业绩列表&quot;,</span><br><span class="line">     &quot;PId&quot;: 1026,</span><br><span class="line">     &quot;Order&quot;: 1,</span><br><span class="line">     &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;Id&quot;: 1032,</span><br><span class="line">     &quot;Name&quot;: &quot;业绩明细&quot;,</span><br><span class="line">     &quot;PId&quot;: 1026,</span><br><span class="line">     &quot;Order&quot;: 2,</span><br><span class="line">     &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line"></span><br><span class="line">     &quot;Children&quot;: []</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;Id&quot;: 1,</span><br><span class="line">     &quot;Name&quot;: &quot;后台&quot;,</span><br><span class="line">     &quot;PId&quot;: null,</span><br><span class="line">     &quot;Order&quot;: 2,</span><br><span class="line">     &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;Id&quot;: 22,</span><br><span class="line">     &quot;Name&quot;: &quot;首页&quot;,</span><br><span class="line">     &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">     &quot;Order&quot;: 1,</span><br><span class="line">     &quot;Class&quot;: &quot;iconfont icon-home&quot;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;Id&quot;: 38,</span><br><span class="line">     &quot;Name&quot;: &quot;查询&quot;,</span><br><span class="line">     &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">     &quot;Order&quot;: 3,</span><br><span class="line">     &quot;Class&quot;: &quot;iconfont icon-home&quot;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;Id&quot;: 2,</span><br><span class="line">     &quot;Name&quot;: &quot;管理&quot;,</span><br><span class="line">     &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">     &quot;Order&quot;: 99,</span><br><span class="line">     &quot;Class&quot;: &quot;iconfont icon-home&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 12,</span><br><span class="line">      &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">      &quot;PId&quot;: 2,</span><br><span class="line">      &quot;Order&quot;: 1,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 3,</span><br><span class="line">      &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">      &quot;PId&quot;: 12,</span><br><span class="line">      &quot;Order&quot;: 1,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 4,</span><br><span class="line">      &quot;Name&quot;: &quot;添加用户&quot;,</span><br><span class="line">      &quot;PId&quot;: 3,</span><br><span class="line">      &quot;Order&quot;: 2,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">      &quot;Code&quot;: &quot;1001&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 5,</span><br><span class="line">      &quot;Name&quot;: &quot;修改用户&quot;,</span><br><span class="line">      &quot;PId&quot;: 3,</span><br><span class="line">      &quot;Order&quot;: 3,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">      &quot;Code&quot;: &quot;1002&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 8,</span><br><span class="line">      &quot;Name&quot;: &quot;开启、关闭用户&quot;,</span><br><span class="line">      &quot;PId&quot;: 3,</span><br><span class="line">      &quot;Order&quot;: 6,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">      &quot;Code&quot;: &quot;1009&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 9,</span><br><span class="line">      &quot;Name&quot;: &quot;重置密码&quot;,</span><br><span class="line">      &quot;PId&quot;: 3,</span><br><span class="line">      &quot;Order&quot;: 7,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">      &quot;Code&quot;: &quot;2001&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 10,</span><br><span class="line">      &quot;Name&quot;: &quot;导出用户信息&quot;,</span><br><span class="line">      &quot;PId&quot;: 3,</span><br><span class="line">      &quot;Order&quot;: 8,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">      &quot;Code&quot;: &quot;1008&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 39,</span><br><span class="line">      &quot;Name&quot;: &quot;金币管理&quot;,</span><br><span class="line">      &quot;PId&quot;: 12,</span><br><span class="line">      &quot;Order&quot;: 2,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 40,</span><br><span class="line">      &quot;Name&quot;: &quot;使用量&quot;,</span><br><span class="line">      &quot;PId&quot;: 12,</span><br><span class="line">      &quot;Order&quot;: 3,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 41,</span><br><span class="line">      &quot;Name&quot;: &quot;业余采集&quot;,</span><br><span class="line">      &quot;PId&quot;: 12,</span><br><span class="line">      &quot;Order&quot;: 4,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Id&quot;: 14,</span><br><span class="line">    &quot;Name&quot;: &quot;相关设置&quot;,</span><br><span class="line">    &quot;PId&quot;: 2,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 42,</span><br><span class="line">      &quot;Name&quot;: &quot;预测参数管理&quot;,</span><br><span class="line">      &quot;PId&quot;: 14,</span><br><span class="line">      &quot;Order&quot;: 1,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 43,</span><br><span class="line">      &quot;Name&quot;: &quot;优惠活动&quot;,</span><br><span class="line">      &quot;PId&quot;: 14,</span><br><span class="line">      &quot;Order&quot;: 2,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 44,</span><br><span class="line">      &quot;Name&quot;: &quot;统计分析&quot;,</span><br><span class="line">      &quot;PId&quot;: 14,</span><br><span class="line">      &quot;Order&quot;: 3,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 45,</span><br><span class="line">      &quot;Name&quot;: &quot;CA设置&quot;,</span><br><span class="line">      &quot;PId&quot;: 14,</span><br><span class="line">      &quot;Order&quot;: 4,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: 46,</span><br><span class="line">      &quot;Name&quot;: &quot;VIP价格&quot;,</span><br><span class="line">      &quot;PId&quot;: 14,</span><br><span class="line">      &quot;Order&quot;: 5,</span><br><span class="line">      &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function listChangeTree(data) &#123;</span><br><span class="line"> // 删除 所有 children,以防止多次调用</span><br><span class="line">        data.forEach(function (item) &#123;</span><br><span class="line">          delete item.child;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 将数据存储为 以 id 为 KEY 的 map 索引数据列</span><br><span class="line">        let map = &#123;&#125;;</span><br><span class="line">        data.forEach(function (item) &#123;</span><br><span class="line">          map[item.Id] = item;</span><br><span class="line">        &#125;);</span><br><span class="line">        let val = [];</span><br><span class="line">        data.forEach(function (item) &#123;</span><br><span class="line">          // 以当前遍历项，的pid,去map对象中找到索引的id</span><br><span class="line">          let parent = map[item.PId];</span><br><span class="line">          // 如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中</span><br><span class="line">          if (parent) &#123;</span><br><span class="line">            (parent.child || (parent.child = [])).push(item);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级</span><br><span class="line">            val.push(item);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return val;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listChangeTree(list)</span><br></pre></td></tr></table></figure><blockquote><p>结果得到：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;Id&quot;: 19,</span><br><span class="line">    &quot;Name&quot;: &quot;App&quot;,</span><br><span class="line">    &quot;PId&quot;: null,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 1025,</span><br><span class="line">        &quot;Name&quot;: &quot;企业查询&quot;,</span><br><span class="line">        &quot;PId&quot;: 19,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 1051,</span><br><span class="line">            &quot;Name&quot;: &quot;企业列表&quot;,</span><br><span class="line">            &quot;PId&quot;: 1025,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 1029,</span><br><span class="line">            &quot;Name&quot;: &quot;企业明细&quot;,</span><br><span class="line">            &quot;PId&quot;: 1025,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 1030,</span><br><span class="line">            &quot;Name&quot;: &quot;投标战绩&quot;,</span><br><span class="line">            &quot;PId&quot;: 1025,</span><br><span class="line">            &quot;Order&quot;: 3,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 1026,</span><br><span class="line">        &quot;Name&quot;: &quot;业绩查询&quot;,</span><br><span class="line">        &quot;PId&quot;: 19,</span><br><span class="line">        &quot;Order&quot;: 2,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 1031,</span><br><span class="line">            &quot;Name&quot;: &quot;业绩列表&quot;,</span><br><span class="line">            &quot;PId&quot;: 1026,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 1032,</span><br><span class="line">            &quot;Name&quot;: &quot;业绩明细&quot;,</span><br><span class="line">            &quot;PId&quot;: 1026,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;Children&quot;: []</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1,</span><br><span class="line">    &quot;Name&quot;: &quot;后台&quot;,</span><br><span class="line">    &quot;PId&quot;: null,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 22,</span><br><span class="line">        &quot;Name&quot;: &quot;首页&quot;,</span><br><span class="line">        &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-home&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 38,</span><br><span class="line">        &quot;Name&quot;: &quot;查询&quot;,</span><br><span class="line">        &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Order&quot;: 3,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-home&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 2,</span><br><span class="line">        &quot;Name&quot;: &quot;管理&quot;,</span><br><span class="line">        &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Order&quot;: 99,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-home&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 12,</span><br><span class="line">            &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">            &quot;PId&quot;: 2,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;child&quot;: [&#123;</span><br><span class="line">                &quot;Id&quot;: 3,</span><br><span class="line">                &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 1,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                &quot;child&quot;: [&#123;</span><br><span class="line">                    &quot;Id&quot;: 4,</span><br><span class="line">                    &quot;Name&quot;: &quot;添加用户&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 2,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1001&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 5,</span><br><span class="line">                    &quot;Name&quot;: &quot;修改用户&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 3,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1002&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 8,</span><br><span class="line">                    &quot;Name&quot;: &quot;开启、关闭用户&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 6,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1009&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 9,</span><br><span class="line">                    &quot;Name&quot;: &quot;重置密码&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 7,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;2001&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 10,</span><br><span class="line">                    &quot;Name&quot;: &quot;导出用户信息&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 8,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1008&quot;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 39,</span><br><span class="line">                &quot;Name&quot;: &quot;金币管理&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 2,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 40,</span><br><span class="line">                &quot;Name&quot;: &quot;使用量&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 3,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 41,</span><br><span class="line">                &quot;Name&quot;: &quot;业余采集&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 4,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 14,</span><br><span class="line">            &quot;Name&quot;: &quot;相关设置&quot;,</span><br><span class="line">            &quot;PId&quot;: 2,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;child&quot;: [&#123;</span><br><span class="line">                &quot;Id&quot;: 42,</span><br><span class="line">                &quot;Name&quot;: &quot;预测参数管理&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 1,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 43,</span><br><span class="line">                &quot;Name&quot;: &quot;优惠活动&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 2,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 44,</span><br><span class="line">                &quot;Name&quot;: &quot;统计分析&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 3,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 45,</span><br><span class="line">                &quot;Name&quot;: &quot;CA设置&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 4,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 46,</span><br><span class="line">                &quot;Name&quot;: &quot;VIP价格&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 5,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h3 id="树形数据扁平化"><a href="#树形数据扁平化" class="headerlink" title="树形数据扁平化"></a>树形数据扁平化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">var list = [&#123;</span><br><span class="line">    &quot;Id&quot;: 19,</span><br><span class="line">    &quot;Name&quot;: &quot;App&quot;,</span><br><span class="line">    &quot;PId&quot;: null,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 1025,</span><br><span class="line">        &quot;Name&quot;: &quot;企业查询&quot;,</span><br><span class="line">        &quot;PId&quot;: 19,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 1051,</span><br><span class="line">            &quot;Name&quot;: &quot;企业列表&quot;,</span><br><span class="line">            &quot;PId&quot;: 1025,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 1029,</span><br><span class="line">            &quot;Name&quot;: &quot;企业明细&quot;,</span><br><span class="line">            &quot;PId&quot;: 1025,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 1030,</span><br><span class="line">            &quot;Name&quot;: &quot;投标战绩&quot;,</span><br><span class="line">            &quot;PId&quot;: 1025,</span><br><span class="line">            &quot;Order&quot;: 3,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 1026,</span><br><span class="line">        &quot;Name&quot;: &quot;业绩查询&quot;,</span><br><span class="line">        &quot;PId&quot;: 19,</span><br><span class="line">        &quot;Order&quot;: 2,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 1031,</span><br><span class="line">            &quot;Name&quot;: &quot;业绩列表&quot;,</span><br><span class="line">            &quot;PId&quot;: 1026,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 1032,</span><br><span class="line">            &quot;Name&quot;: &quot;业绩明细&quot;,</span><br><span class="line">            &quot;PId&quot;: 1026,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1,</span><br><span class="line">    &quot;Name&quot;: &quot;后台&quot;,</span><br><span class="line">    &quot;PId&quot;: null,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 22,</span><br><span class="line">        &quot;Name&quot;: &quot;首页&quot;,</span><br><span class="line">        &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-home&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 38,</span><br><span class="line">        &quot;Name&quot;: &quot;查询&quot;,</span><br><span class="line">        &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Order&quot;: 3,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-home&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 2,</span><br><span class="line">        &quot;Name&quot;: &quot;管理&quot;,</span><br><span class="line">        &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Order&quot;: 99,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-home&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 12,</span><br><span class="line">            &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">            &quot;PId&quot;: 2,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;child&quot;: [&#123;</span><br><span class="line">                &quot;Id&quot;: 3,</span><br><span class="line">                &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 1,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                &quot;child&quot;: [&#123;</span><br><span class="line">                    &quot;Id&quot;: 4,</span><br><span class="line">                    &quot;Name&quot;: &quot;添加用户&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 2,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1001&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 5,</span><br><span class="line">                    &quot;Name&quot;: &quot;修改用户&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 3,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1002&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 8,</span><br><span class="line">                    &quot;Name&quot;: &quot;开启、关闭用户&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 6,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1009&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 9,</span><br><span class="line">                    &quot;Name&quot;: &quot;重置密码&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 7,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;2001&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 10,</span><br><span class="line">                    &quot;Name&quot;: &quot;导出用户信息&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 8,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1008&quot;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 39,</span><br><span class="line">                &quot;Name&quot;: &quot;金币管理&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 2,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 40,</span><br><span class="line">                &quot;Name&quot;: &quot;使用量&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 3,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 41,</span><br><span class="line">                &quot;Name&quot;: &quot;业余采集&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 4,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 14,</span><br><span class="line">            &quot;Name&quot;: &quot;相关设置&quot;,</span><br><span class="line">            &quot;PId&quot;: 2,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;child&quot;: [&#123;</span><br><span class="line">                &quot;Id&quot;: 42,</span><br><span class="line">                &quot;Name&quot;: &quot;预测参数管理&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 1,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 43,</span><br><span class="line">                &quot;Name&quot;: &quot;优惠活动&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 2,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 44,</span><br><span class="line">                &quot;Name&quot;: &quot;统计分析&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 3,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 45,</span><br><span class="line">                &quot;Name&quot;: &quot;CA设置&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 4,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 46,</span><br><span class="line">                &quot;Name&quot;: &quot;VIP价格&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 5,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function formatConversion (parent, child, index = 0, family = [], elderIdentity = &apos;x&apos;) &#123;</span><br><span class="line">      // child如果长度等于0，则代表已经到了最低层</span><br><span class="line">      // let page = (this.startPage - 1) * 10</span><br><span class="line">      if (child&amp;&amp;child.length &gt; 0) &#123;</span><br><span class="line">        child.map((x, i) =&gt; &#123;</span><br><span class="line">          // 设置 __level 标志位 用于展示区分层级</span><br><span class="line">          // Vue.set(x, &apos;__level&apos;, index)</span><br><span class="line">          // 设置 __family 为家族关系 为所有父级，包含本身在内</span><br><span class="line">          // Vue.set(x, &apos;__family&apos;, [...family, elderIdentity + &apos;_&apos; + i])</span><br><span class="line">          // 本身的唯一标识  可以理解为个人的身份证咯 一定唯一。</span><br><span class="line">          // Vue.set(x, &apos;__identity&apos;, elderIdentity + &apos;_&apos; + i)</span><br><span class="line">          parent.push(x)</span><br><span class="line">          // 如果仍有子集，则进行递归</span><br><span class="line">          if (x.child&amp;&amp;x.child.length &gt; 0) this.formatConversion(parent, x.child, index + 1, [...family, elderIdentity + &apos;_&apos; + i], elderIdentity + &apos;_&apos; + i)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; return parent</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formatConversion([],list)</span><br></pre></td></tr></table></figure><blockquote><p>结果得到：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;Id&quot;: 19,</span><br><span class="line">    &quot;Name&quot;: &quot;App&quot;,</span><br><span class="line">    &quot;PId&quot;: null,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 1025,</span><br><span class="line">        &quot;Name&quot;: &quot;企业查询&quot;,</span><br><span class="line">        &quot;PId&quot;: 19,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 1051,</span><br><span class="line">            &quot;Name&quot;: &quot;企业列表&quot;,</span><br><span class="line">            &quot;PId&quot;: 1025,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 1029,</span><br><span class="line">            &quot;Name&quot;: &quot;企业明细&quot;,</span><br><span class="line">            &quot;PId&quot;: 1025,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 1030,</span><br><span class="line">            &quot;Name&quot;: &quot;投标战绩&quot;,</span><br><span class="line">            &quot;PId&quot;: 1025,</span><br><span class="line">            &quot;Order&quot;: 3,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 1026,</span><br><span class="line">        &quot;Name&quot;: &quot;业绩查询&quot;,</span><br><span class="line">        &quot;PId&quot;: 19,</span><br><span class="line">        &quot;Order&quot;: 2,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 1031,</span><br><span class="line">            &quot;Name&quot;: &quot;业绩列表&quot;,</span><br><span class="line">            &quot;PId&quot;: 1026,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 1032,</span><br><span class="line">            &quot;Name&quot;: &quot;业绩明细&quot;,</span><br><span class="line">            &quot;PId&quot;: 1026,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1025,</span><br><span class="line">    &quot;Name&quot;: &quot;企业查询&quot;,</span><br><span class="line">    &quot;PId&quot;: 19,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 1051,</span><br><span class="line">        &quot;Name&quot;: &quot;企业列表&quot;,</span><br><span class="line">        &quot;PId&quot;: 1025,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 1029,</span><br><span class="line">        &quot;Name&quot;: &quot;企业明细&quot;,</span><br><span class="line">        &quot;PId&quot;: 1025,</span><br><span class="line">        &quot;Order&quot;: 2,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 1030,</span><br><span class="line">        &quot;Name&quot;: &quot;投标战绩&quot;,</span><br><span class="line">        &quot;PId&quot;: 1025,</span><br><span class="line">        &quot;Order&quot;: 3,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1051,</span><br><span class="line">    &quot;Name&quot;: &quot;企业列表&quot;,</span><br><span class="line">    &quot;PId&quot;: 1025,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1029,</span><br><span class="line">    &quot;Name&quot;: &quot;企业明细&quot;,</span><br><span class="line">    &quot;PId&quot;: 1025,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1030,</span><br><span class="line">    &quot;Name&quot;: &quot;投标战绩&quot;,</span><br><span class="line">    &quot;PId&quot;: 1025,</span><br><span class="line">    &quot;Order&quot;: 3,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1026,</span><br><span class="line">    &quot;Name&quot;: &quot;业绩查询&quot;,</span><br><span class="line">    &quot;PId&quot;: 19,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 1031,</span><br><span class="line">        &quot;Name&quot;: &quot;业绩列表&quot;,</span><br><span class="line">        &quot;PId&quot;: 1026,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 1032,</span><br><span class="line">        &quot;Name&quot;: &quot;业绩明细&quot;,</span><br><span class="line">        &quot;PId&quot;: 1026,</span><br><span class="line">        &quot;Order&quot;: 2,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1031,</span><br><span class="line">    &quot;Name&quot;: &quot;业绩列表&quot;,</span><br><span class="line">    &quot;PId&quot;: 1026,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1032,</span><br><span class="line">    &quot;Name&quot;: &quot;业绩明细&quot;,</span><br><span class="line">    &quot;PId&quot;: 1026,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 1,</span><br><span class="line">    &quot;Name&quot;: &quot;后台&quot;,</span><br><span class="line">    &quot;PId&quot;: null,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 22,</span><br><span class="line">        &quot;Name&quot;: &quot;首页&quot;,</span><br><span class="line">        &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-home&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 38,</span><br><span class="line">        &quot;Name&quot;: &quot;查询&quot;,</span><br><span class="line">        &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Order&quot;: 3,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-home&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 2,</span><br><span class="line">        &quot;Name&quot;: &quot;管理&quot;,</span><br><span class="line">        &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Order&quot;: 99,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-home&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 12,</span><br><span class="line">            &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">            &quot;PId&quot;: 2,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;child&quot;: [&#123;</span><br><span class="line">                &quot;Id&quot;: 3,</span><br><span class="line">                &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 1,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                &quot;child&quot;: [&#123;</span><br><span class="line">                    &quot;Id&quot;: 4,</span><br><span class="line">                    &quot;Name&quot;: &quot;添加用户&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 2,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1001&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 5,</span><br><span class="line">                    &quot;Name&quot;: &quot;修改用户&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 3,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1002&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 8,</span><br><span class="line">                    &quot;Name&quot;: &quot;开启、关闭用户&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 6,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1009&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 9,</span><br><span class="line">                    &quot;Name&quot;: &quot;重置密码&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 7,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;2001&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Id&quot;: 10,</span><br><span class="line">                    &quot;Name&quot;: &quot;导出用户信息&quot;,</span><br><span class="line">                    &quot;PId&quot;: 3,</span><br><span class="line">                    &quot;Order&quot;: 8,</span><br><span class="line">                    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                    &quot;Code&quot;: &quot;1008&quot;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 39,</span><br><span class="line">                &quot;Name&quot;: &quot;金币管理&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 2,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 40,</span><br><span class="line">                &quot;Name&quot;: &quot;使用量&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 3,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 41,</span><br><span class="line">                &quot;Name&quot;: &quot;业余采集&quot;,</span><br><span class="line">                &quot;PId&quot;: 12,</span><br><span class="line">                &quot;Order&quot;: 4,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 14,</span><br><span class="line">            &quot;Name&quot;: &quot;相关设置&quot;,</span><br><span class="line">            &quot;PId&quot;: 2,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;child&quot;: [&#123;</span><br><span class="line">                &quot;Id&quot;: 42,</span><br><span class="line">                &quot;Name&quot;: &quot;预测参数管理&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 1,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 43,</span><br><span class="line">                &quot;Name&quot;: &quot;优惠活动&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 2,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 44,</span><br><span class="line">                &quot;Name&quot;: &quot;统计分析&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 3,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 45,</span><br><span class="line">                &quot;Name&quot;: &quot;CA设置&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 4,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 46,</span><br><span class="line">                &quot;Name&quot;: &quot;VIP价格&quot;,</span><br><span class="line">                &quot;PId&quot;: 14,</span><br><span class="line">                &quot;Order&quot;: 5,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 22,</span><br><span class="line">    &quot;Name&quot;: &quot;首页&quot;,</span><br><span class="line">    &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-home&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 38,</span><br><span class="line">    &quot;Name&quot;: &quot;查询&quot;,</span><br><span class="line">    &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;Order&quot;: 3,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-home&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 2,</span><br><span class="line">    &quot;Name&quot;: &quot;管理&quot;,</span><br><span class="line">    &quot;PId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;Order&quot;: 99,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-home&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 12,</span><br><span class="line">        &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">        &quot;PId&quot;: 2,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 3,</span><br><span class="line">            &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">            &quot;PId&quot;: 12,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;child&quot;: [&#123;</span><br><span class="line">                &quot;Id&quot;: 4,</span><br><span class="line">                &quot;Name&quot;: &quot;添加用户&quot;,</span><br><span class="line">                &quot;PId&quot;: 3,</span><br><span class="line">                &quot;Order&quot;: 2,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                &quot;Code&quot;: &quot;1001&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 5,</span><br><span class="line">                &quot;Name&quot;: &quot;修改用户&quot;,</span><br><span class="line">                &quot;PId&quot;: 3,</span><br><span class="line">                &quot;Order&quot;: 3,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                &quot;Code&quot;: &quot;1002&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 8,</span><br><span class="line">                &quot;Name&quot;: &quot;开启、关闭用户&quot;,</span><br><span class="line">                &quot;PId&quot;: 3,</span><br><span class="line">                &quot;Order&quot;: 6,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                &quot;Code&quot;: &quot;1009&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 9,</span><br><span class="line">                &quot;Name&quot;: &quot;重置密码&quot;,</span><br><span class="line">                &quot;PId&quot;: 3,</span><br><span class="line">                &quot;Order&quot;: 7,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                &quot;Code&quot;: &quot;2001&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Id&quot;: 10,</span><br><span class="line">                &quot;Name&quot;: &quot;导出用户信息&quot;,</span><br><span class="line">                &quot;PId&quot;: 3,</span><br><span class="line">                &quot;Order&quot;: 8,</span><br><span class="line">                &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">                &quot;Code&quot;: &quot;1008&quot;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 39,</span><br><span class="line">            &quot;Name&quot;: &quot;金币管理&quot;,</span><br><span class="line">            &quot;PId&quot;: 12,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 40,</span><br><span class="line">            &quot;Name&quot;: &quot;使用量&quot;,</span><br><span class="line">            &quot;PId&quot;: 12,</span><br><span class="line">            &quot;Order&quot;: 3,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 41,</span><br><span class="line">            &quot;Name&quot;: &quot;业余采集&quot;,</span><br><span class="line">            &quot;PId&quot;: 12,</span><br><span class="line">            &quot;Order&quot;: 4,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 14,</span><br><span class="line">        &quot;Name&quot;: &quot;相关设置&quot;,</span><br><span class="line">        &quot;PId&quot;: 2,</span><br><span class="line">        &quot;Order&quot;: 2,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 42,</span><br><span class="line">            &quot;Name&quot;: &quot;预测参数管理&quot;,</span><br><span class="line">            &quot;PId&quot;: 14,</span><br><span class="line">            &quot;Order&quot;: 1,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 43,</span><br><span class="line">            &quot;Name&quot;: &quot;优惠活动&quot;,</span><br><span class="line">            &quot;PId&quot;: 14,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 44,</span><br><span class="line">            &quot;Name&quot;: &quot;统计分析&quot;,</span><br><span class="line">            &quot;PId&quot;: 14,</span><br><span class="line">            &quot;Order&quot;: 3,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 45,</span><br><span class="line">            &quot;Name&quot;: &quot;CA设置&quot;,</span><br><span class="line">            &quot;PId&quot;: 14,</span><br><span class="line">            &quot;Order&quot;: 4,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 46,</span><br><span class="line">            &quot;Name&quot;: &quot;VIP价格&quot;,</span><br><span class="line">            &quot;PId&quot;: 14,</span><br><span class="line">            &quot;Order&quot;: 5,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 12,</span><br><span class="line">    &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">    &quot;PId&quot;: 2,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 3,</span><br><span class="line">        &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">        &quot;PId&quot;: 12,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;child&quot;: [&#123;</span><br><span class="line">            &quot;Id&quot;: 4,</span><br><span class="line">            &quot;Name&quot;: &quot;添加用户&quot;,</span><br><span class="line">            &quot;PId&quot;: 3,</span><br><span class="line">            &quot;Order&quot;: 2,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;Code&quot;: &quot;1001&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 5,</span><br><span class="line">            &quot;Name&quot;: &quot;修改用户&quot;,</span><br><span class="line">            &quot;PId&quot;: 3,</span><br><span class="line">            &quot;Order&quot;: 3,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;Code&quot;: &quot;1002&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 8,</span><br><span class="line">            &quot;Name&quot;: &quot;开启、关闭用户&quot;,</span><br><span class="line">            &quot;PId&quot;: 3,</span><br><span class="line">            &quot;Order&quot;: 6,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;Code&quot;: &quot;1009&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 9,</span><br><span class="line">            &quot;Name&quot;: &quot;重置密码&quot;,</span><br><span class="line">            &quot;PId&quot;: 3,</span><br><span class="line">            &quot;Order&quot;: 7,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;Code&quot;: &quot;2001&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Id&quot;: 10,</span><br><span class="line">            &quot;Name&quot;: &quot;导出用户信息&quot;,</span><br><span class="line">            &quot;PId&quot;: 3,</span><br><span class="line">            &quot;Order&quot;: 8,</span><br><span class="line">            &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">            &quot;Code&quot;: &quot;1008&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 39,</span><br><span class="line">        &quot;Name&quot;: &quot;金币管理&quot;,</span><br><span class="line">        &quot;PId&quot;: 12,</span><br><span class="line">        &quot;Order&quot;: 2,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 40,</span><br><span class="line">        &quot;Name&quot;: &quot;使用量&quot;,</span><br><span class="line">        &quot;PId&quot;: 12,</span><br><span class="line">        &quot;Order&quot;: 3,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 41,</span><br><span class="line">        &quot;Name&quot;: &quot;业余采集&quot;,</span><br><span class="line">        &quot;PId&quot;: 12,</span><br><span class="line">        &quot;Order&quot;: 4,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 3,</span><br><span class="line">    &quot;Name&quot;: &quot;用户管理&quot;,</span><br><span class="line">    &quot;PId&quot;: 12,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 4,</span><br><span class="line">        &quot;Name&quot;: &quot;添加用户&quot;,</span><br><span class="line">        &quot;PId&quot;: 3,</span><br><span class="line">        &quot;Order&quot;: 2,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;Code&quot;: &quot;1001&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 5,</span><br><span class="line">        &quot;Name&quot;: &quot;修改用户&quot;,</span><br><span class="line">        &quot;PId&quot;: 3,</span><br><span class="line">        &quot;Order&quot;: 3,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;Code&quot;: &quot;1002&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 8,</span><br><span class="line">        &quot;Name&quot;: &quot;开启、关闭用户&quot;,</span><br><span class="line">        &quot;PId&quot;: 3,</span><br><span class="line">        &quot;Order&quot;: 6,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;Code&quot;: &quot;1009&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 9,</span><br><span class="line">        &quot;Name&quot;: &quot;重置密码&quot;,</span><br><span class="line">        &quot;PId&quot;: 3,</span><br><span class="line">        &quot;Order&quot;: 7,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;Code&quot;: &quot;2001&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 10,</span><br><span class="line">        &quot;Name&quot;: &quot;导出用户信息&quot;,</span><br><span class="line">        &quot;PId&quot;: 3,</span><br><span class="line">        &quot;Order&quot;: 8,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">        &quot;Code&quot;: &quot;1008&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 4,</span><br><span class="line">    &quot;Name&quot;: &quot;添加用户&quot;,</span><br><span class="line">    &quot;PId&quot;: 3,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;Code&quot;: &quot;1001&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 5,</span><br><span class="line">    &quot;Name&quot;: &quot;修改用户&quot;,</span><br><span class="line">    &quot;PId&quot;: 3,</span><br><span class="line">    &quot;Order&quot;: 3,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;Code&quot;: &quot;1002&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 8,</span><br><span class="line">    &quot;Name&quot;: &quot;开启、关闭用户&quot;,</span><br><span class="line">    &quot;PId&quot;: 3,</span><br><span class="line">    &quot;Order&quot;: 6,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;Code&quot;: &quot;1009&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 9,</span><br><span class="line">    &quot;Name&quot;: &quot;重置密码&quot;,</span><br><span class="line">    &quot;PId&quot;: 3,</span><br><span class="line">    &quot;Order&quot;: 7,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;Code&quot;: &quot;2001&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 10,</span><br><span class="line">    &quot;Name&quot;: &quot;导出用户信息&quot;,</span><br><span class="line">    &quot;PId&quot;: 3,</span><br><span class="line">    &quot;Order&quot;: 8,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;Code&quot;: &quot;1008&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 39,</span><br><span class="line">    &quot;Name&quot;: &quot;金币管理&quot;,</span><br><span class="line">    &quot;PId&quot;: 12,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 40,</span><br><span class="line">    &quot;Name&quot;: &quot;使用量&quot;,</span><br><span class="line">    &quot;PId&quot;: 12,</span><br><span class="line">    &quot;Order&quot;: 3,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 41,</span><br><span class="line">    &quot;Name&quot;: &quot;业余采集&quot;,</span><br><span class="line">    &quot;PId&quot;: 12,</span><br><span class="line">    &quot;Order&quot;: 4,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 14,</span><br><span class="line">    &quot;Name&quot;: &quot;相关设置&quot;,</span><br><span class="line">    &quot;PId&quot;: 2,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,</span><br><span class="line">    &quot;child&quot;: [&#123;</span><br><span class="line">        &quot;Id&quot;: 42,</span><br><span class="line">        &quot;Name&quot;: &quot;预测参数管理&quot;,</span><br><span class="line">        &quot;PId&quot;: 14,</span><br><span class="line">        &quot;Order&quot;: 1,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 43,</span><br><span class="line">        &quot;Name&quot;: &quot;优惠活动&quot;,</span><br><span class="line">        &quot;PId&quot;: 14,</span><br><span class="line">        &quot;Order&quot;: 2,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 44,</span><br><span class="line">        &quot;Name&quot;: &quot;统计分析&quot;,</span><br><span class="line">        &quot;PId&quot;: 14,</span><br><span class="line">        &quot;Order&quot;: 3,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 45,</span><br><span class="line">        &quot;Name&quot;: &quot;CA设置&quot;,</span><br><span class="line">        &quot;PId&quot;: 14,</span><br><span class="line">        &quot;Order&quot;: 4,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: 46,</span><br><span class="line">        &quot;Name&quot;: &quot;VIP价格&quot;,</span><br><span class="line">        &quot;PId&quot;: 14,</span><br><span class="line">        &quot;Order&quot;: 5,</span><br><span class="line">        &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 42,</span><br><span class="line">    &quot;Name&quot;: &quot;预测参数管理&quot;,</span><br><span class="line">    &quot;PId&quot;: 14,</span><br><span class="line">    &quot;Order&quot;: 1,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 43,</span><br><span class="line">    &quot;Name&quot;: &quot;优惠活动&quot;,</span><br><span class="line">    &quot;PId&quot;: 14,</span><br><span class="line">    &quot;Order&quot;: 2,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 44,</span><br><span class="line">    &quot;Name&quot;: &quot;统计分析&quot;,</span><br><span class="line">    &quot;PId&quot;: 14,</span><br><span class="line">    &quot;Order&quot;: 3,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 45,</span><br><span class="line">    &quot;Name&quot;: &quot;CA设置&quot;,</span><br><span class="line">    &quot;PId&quot;: 14,</span><br><span class="line">    &quot;Order&quot;: 4,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Id&quot;: 46,</span><br><span class="line">    &quot;Name&quot;: &quot;VIP价格&quot;,</span><br><span class="line">    &quot;PId&quot;: 14,</span><br><span class="line">    &quot;Order&quot;: 5,</span><br><span class="line">    &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="扁平化数据树形化 ,树形数据扁平化" scheme="https://93qlin.github.io/categories/%E6%89%81%E5%B9%B3%E5%8C%96%E6%95%B0%E6%8D%AE%E6%A0%91%E5%BD%A2%E5%8C%96-%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    
    
      <category term="javascript" scheme="https://93qlin.github.io/tags/javascript/"/>
    
      <category term="tree" scheme="https://93qlin.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://93qlin.github.io/2019/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://93qlin.github.io/2019/02/28/设计模式/</id>
    <published>2019-02-28T03:12:12.521Z</published>
    <updated>2019-02-28T03:12:12.522Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h4><blockquote><p>在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。<br>通俗理解:==给好的设计取个名字。==</p></blockquote><h4 id="设计模式的作用？"><a href="#设计模式的作用？" class="headerlink" title="设计模式的作用？"></a>设计模式的作用？</h4><blockquote><p>当某个类似的场景出现的时候，很快的找到某种模式作为解决方案。</p></blockquote><p><em>javaScript和其他静态类型的语言有差异，不应照搬设计模式。</em></p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h5><blockquote><p>同一操作作用于不同对象的上面，可以产生不同的解释和不同的执行效果。<br>通俗理解：主人说发出叫的命令，不同动物发出不同的叫声。<br>代码理解多态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var makeSound=function(animal) &#123;</span><br><span class="line">    animal.sound()</span><br><span class="line">&#125;</span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">Dunk.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&apos;嘎嘎嘎&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var Dog = function()&#123;&#125;</span><br><span class="line">Dog.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&apos;汪汪汪&apos;)</span><br><span class="line">&#125;</span><br><span class="line">mackSound(new Duck)</span><br><span class="line">mackSound(new Dog)</span><br><span class="line"></span><br><span class="line">还有其他动物就简单追加一些代码就可以了。</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>多态思想是把”做什么”和”谁去做”分开，<br>那如何分开？消除类型之间的耦合关系。<br>如果makeSound指定了发出叫声的对向是某个类型，那就不能被替换另一类型所以:==静态类型语言的多态==：涉及到类型检查，所以像（java）通过向上转型，通过继承来实现多态。<br>==javaScript的多态==：由于变量类型在运行期间是可变的，不存在类型耦合，所以它的多态是与生俱来的。</p></blockquote><blockquote><p>javaScript函数也是对象，函数用来封装行为并到处传递，当对函数发出“调用”的消息时，这些函数会返回不同的执行效果。这是多态的一种体现。这也是很多设计模式在JavaScript中使用高阶函数来实现的原因。</p></blockquote><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote><p>封装的目的是将信息影藏。<br>广义上包括封装数据和封装实现，封装类型和封装变化。</p></blockquote><h5 id="封装数据"><a href="#封装数据" class="headerlink" title="封装数据"></a>封装数据</h5><blockquote><p>许多语言封装数据是通过语法解析来实现的，用（private,public,protect）等关键字来提供不同的访问权限。<br>JavaScript没有这些关键字的支持，只能通过==变量的作用域==来实现封装特性而且只能模拟public和private两种封装性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = (function() &#123;</span><br><span class="line">    var _name = &quot;haha&quot;      //私有变量（&apos;private&apos;）</span><br><span class="line">    return &#123;</span><br><span class="line">        getName: function()&#123; // 公开方法（&apos;public&apos;）</span><br><span class="line">            return _name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(myObject._name)  // 输出：haha</span><br><span class="line">console.log(myObject.getName()) // 输出undefined</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h5><p>封装使得对象之间的耦合变松散，对象之间只通过暴露api接口来通信。</p><h5 id="封装类型"><a href="#封装类型" class="headerlink" title="封装类型"></a>封装类型</h5><blockquote><p>它是静态类型语言的一种重要的封装方式。一般通过抽象类和接口来进行的。<br>JavaScript是类型模糊的语言没有抽象类和接口的支持，所以在封装类型方面没有能力也没必要做的更多。</p></blockquote><h5 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h5><p>找到系统稳定不变的部分和容易变化的部分隔离开，系统演变的过程中只需要替换容易变化的部分。</p><h4 id="原型模式和基于原型模式的JavaScript对象系统。"><a href="#原型模式和基于原型模式的JavaScript对象系统。" class="headerlink" title="原型模式和基于原型模式的JavaScript对象系统。"></a>原型模式和基于原型模式的JavaScript对象系统。</h4><h5 id="第一个设计模式————原型模式"><a href="#第一个设计模式————原型模式" class="headerlink" title="第一个设计模式————原型模式"></a>第一个设计模式————原型模式</h5><h6 id="使用克隆的原型模式"><a href="#使用克隆的原型模式" class="headerlink" title="使用克隆的原型模式"></a>使用克隆的原型模式</h6><blockquote><p>es5提供了Object.created()来克隆对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Plane = function() &#123;</span><br><span class="line">this.aa = 11</span><br><span class="line">&#125;</span><br><span class="line">var plane = new Plane()</span><br><span class="line">plane.aa = 22</span><br><span class="line">var clonePlane = Object.create(plane)</span><br><span class="line">console.log(clonePlane.aa)  // 22</span><br><span class="line">plane.aa = 33</span><br><span class="line">console.log(clonePlane.aa) // 33</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="克隆是创建对象的手段"><a href="#克隆是创建对象的手段" class="headerlink" title="克隆是创建对象的手段"></a>克隆是创建对象的手段</h5><p>在javaScript创建对象非常容易，不存在类型耦合，所以原型模式的意义并不大，但是他的对象系统就是使用原型模式来搭建的。</p><h5 id="原型编程泛型"><a href="#原型编程泛型" class="headerlink" title="原型编程泛型"></a>原型编程泛型</h5><blockquote><p>object是animal的原型，而animal是Dog原型，他们之间形成了一个原型链，这个原型链很有用处当调用Dog对象的某个方法时，它本身没有，Dog对象会把这个请求委托給它的原型animal对象这样顺着原型链一直委托下去，便得到继承的效果。<br>==这样基于原型链的委托机制就是原型继承的本质==。</p></blockquote><h4 id="JavaScript中的原型继承"><a href="#JavaScript中的原型继承" class="headerlink" title="JavaScript中的原型继承"></a>JavaScript中的原型继承</h4><p>==原型编程的基本规则：==</p><ol><li>所有数据都是对象</li><li>要得到一个对象不是通过实例化类，而是找到一个对象并克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li></ol><h5 id="1，所有数据都是对象"><a href="#1，所有数据都是对象" class="headerlink" title="1，所有数据都是对象"></a>1，所有数据都是对象</h5><p>javascrit模仿java有两套类型机制：基本类型和对象类型。<br>javaScript并不是所有数据都是对象，按设计者本意除undefined外一切都应是对象，为了实现这个number，boolean,string这几种基本类型也可以通过“包装类”的方式变成对象类型的数据处理。</p><blockquote><p>  javaSript中的根对象是object.prototype对象（一个空对象）。javascripty中遇到的每个对象都是从Object.prototype对象克隆而来的。Object.prototype对象就是他们的原型，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = &#123;&#125;;</span><br><span class="line">查看这两个对象的原型(es5的Object.getPrototypeOf)</span><br><span class="line">console.log(Object.getPrototypeOf(obj1)===Object.prototype) //true</span><br><span class="line">console.log(Object.getPrototypeOf(obj2)===Object.prototype) //true</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="2-要得到一个对象不是通过实例化类，而是找到一个对象并克隆它"><a href="#2-要得到一个对象不是通过实例化类，而是找到一个对象并克隆它" class="headerlink" title="2.要得到一个对象不是通过实例化类，而是找到一个对象并克隆它"></a>2.要得到一个对象不是通过实例化类，而是找到一个对象并克隆它</h5><p>JavaScript引擎内部负责实现克隆，<br>调用var obj1 = new Object()和var obj2 = {};时内部会从Object.prototype上克隆一个对象；一段熟悉的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funtion Person(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">var a = new Person(&apos;seven&apos;)</span><br><span class="line">console.log(a.name) //seven</span><br><span class="line">console.log(a.getName())</span><br><span class="line">console.log(Object.getPrototypeOf(a)===Person.prototype)</span><br></pre></td></tr></table></figure></p><p>==javascript没有类的概念==这里的Person不是类而是函数构造器，因为js的函数既可以作为普通函数调用也可以作为构造器被调用，用new运算符调用时就是一个构造器，创建对象的过程就是先克隆Object.prototype对象，再进行一些其他额外的操作的过程（实际上并不是真的克隆了一个新对象《内存方面出发还做了其他处理，参考js精髓和编程实战）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="https://93qlin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="https://93qlin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo + github搭建自己的博客</title>
    <link href="https://93qlin.github.io/2019/02/28/%E7%94%A8Hexo%20+%20github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://93qlin.github.io/2019/02/28/用Hexo + github搭建自己的博客/</id>
    <published>2019-02-28T03:12:12.521Z</published>
    <updated>2019-02-28T03:12:12.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="看见一个朋友用这个做了一个博客然后自己就开始研究一下-好像已经过时了，那就当做自己的另一个笔记本吧"><a href="#看见一个朋友用这个做了一个博客然后自己就开始研究一下-好像已经过时了，那就当做自己的另一个笔记本吧" class="headerlink" title="看见一个朋友用这个做了一个博客然后自己就开始研究一下(好像已经过时了，那就当做自己的另一个笔记本吧)"></a>看见一个朋友用这个做了一个博客然后自己就开始研究一下(好像已经过时了，那就当做自己的另一个笔记本吧)</h2><blockquote><p>一篇博客(<a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689)写的不错就截屏保存，以防删除：" target="_blank" rel="noopener">https://blog.csdn.net/Hoshea_chx/article/details/78826689)写的不错就截屏保存，以防删除：</a></p></blockquote><p><img src="/img/hexo.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="用Hexo + github搭建自己的博客" scheme="https://93qlin.github.io/categories/%E7%94%A8Hexo-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="https://93qlin.github.io/tags/Hexo/"/>
    
      <category term="github" scheme="https://93qlin.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>指数化退避</title>
    <link href="https://93qlin.github.io/2019/02/28/%E6%8C%87%E6%95%B0%E5%8C%96%E9%80%80%E9%81%BF/"/>
    <id>https://93qlin.github.io/2019/02/28/指数化退避/</id>
    <published>2019-02-28T03:12:12.521Z</published>
    <updated>2019-02-28T03:12:12.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>指数化退避是一种失败后重试 API 的技巧，它会在每次连续的失败之后让重试时间逐渐变长，超过最大重试次数之后就会彻底放弃。 如果使用承诺和其它跟踪 AJAX 调用的方法会非常复杂，而使用可观察对象，这非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; pipe, range, timer, zip &#125; from &apos;rxjs&apos;;</span><br><span class="line">import &#123; ajax &#125; from &apos;rxjs/ajax&apos;;</span><br><span class="line">import &#123; retryWhen, map, mergeMap &#125; from &apos;rxjs/operators&apos;;</span><br><span class="line"></span><br><span class="line">function backoff(maxTries, ms) &#123;</span><br><span class="line"> return pipe(</span><br><span class="line">   retryWhen(attempts =&gt; range(1, maxTries)</span><br><span class="line">     .pipe(</span><br><span class="line">       zip(attempts, (i) =&gt; i),</span><br><span class="line">       map(i =&gt; i * i),</span><br><span class="line">       mergeMap(i =&gt;  timer(i * ms))</span><br><span class="line">     )</span><br><span class="line">   )</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&apos;/api/endpoint&apos;)</span><br><span class="line">  .pipe(backoff(3, 250))</span><br><span class="line">  .subscribe(data =&gt; handleData(data));</span><br><span class="line"></span><br><span class="line">function handleData(data) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="指数化退避" scheme="https://93qlin.github.io/categories/%E6%8C%87%E6%95%B0%E5%8C%96%E9%80%80%E9%81%BF/"/>
    
    
      <category term="javascript" scheme="https://93qlin.github.io/tags/javascript/"/>
    
      <category term="技巧" scheme="https://93qlin.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>基础5.3.：面向对象之继承的的七种方式</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%805.3%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://93qlin.github.io/2019/02/28/基础5.3：面向对象之继承的的七种方式/</id>
    <published>2019-02-28T03:12:12.520Z</published>
    <updated>2019-02-28T03:12:12.520Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>七种方式：</p></blockquote><p>1 .原型链继承</p><p>2 .借用构造函数继承</p><p>3 .组合继承</p><p>4 .原型式继承</p><p>5 .寄生式继承</p><p>6 .寄生组合式继承(<strong>最佳方式</strong>)</p><p>7 .混入方式继承多个对象</p><h4 id="一-原型链继承"><a href="#一-原型链继承" class="headerlink" title="一.原型链继承"></a>一.原型链继承</h4><p><strong>基本思想：</strong></p><blockquote><p>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p></blockquote><p><strong>1.1构造函数、原型和实例的关系：</strong></p><blockquote><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。我们让原型对象等于另一个类型的实例,此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数<br>的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进,就构成了实例与原型的链条。这就是所谓<strong>原型链的基本概念</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line"> this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line"> return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line"> this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">//继承了 SuperType</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.getSubValue = function ()&#123;</span><br><span class="line"> return this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue()); //true</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/038BF7E3A3D84C8BA17770C539240107?method=download&amp;shareKey=e09951823cbe593973b9abf9d32be85d" alt="img"></p><p><strong>1.2搜索机制</strong></p><blockquote><p>上一节中说到，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在<br>通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用<br>instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype；<br>3）<br><strong>1.3确定原型和实例的关系两种方式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceof Object); //true</span><br><span class="line">alert(instance instanceof SuperType); //true</span><br><span class="line">alert(instance instanceof SubType); //true</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>由于原型链的关系，我们可以说 instance 是 Object、SuperType 或SubType中任何一个类型的实例。因此，测试这三个构造函数的结果都返回了 true。<br>第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该<br>原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.prototype.isPrototypeOf(instance)); //true</span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)); //true</span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)); //true</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>1.3 谨慎地定义方法</strong></p><blockquote><p>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎<br>样，给原型添加方法的代码一定要放在<strong>替换原型的语句之后</strong>。来看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line"> this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line"> return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line"> this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">//继承了 SuperType</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">//添加新方法</span><br><span class="line">SubType.prototype.getSubValue = function ()&#123;</span><br><span class="line"> return this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line">//重写超类型中的方法</span><br><span class="line">SubType.prototype.getSuperValue = function ()&#123;</span><br><span class="line"> return false;</span><br><span class="line">&#125;;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue()); //false</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>1.4 缺点(主要两方面)</strong></p><p>最主要的问题来自包含引<br>用类型值的原型。上一节说过包含引用类型值的原型属性会被所有实例共享；而<br><strong>这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因</strong>。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line"> this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">&#125;</span><br><span class="line">//继承了 SuperType</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors); //&quot;red,blue,green,black&quot;</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors); //&quot;red,blue,green,black&quot;</span><br></pre></td></tr></table></figure></p><blockquote><p>当 SubType 通过原型链继承了<br>SuperType 之后，SubType.prototype 就变成了 SuperType 的一个实例，因此它也拥有了一个它自<br>己的 colors 属性——就跟专门创建了一个 SubType.prototype.colors 属性一样。但结果是什么<br>呢？结果是 SubType 的所有实例都会共享这一个 colors 属性。<br>第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，<br>应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上<br>前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，<strong>实践中很少会单独使用原型链</strong>。</p></blockquote><h4 id="二-借用构造函数"><a href="#二-借用构造函数" class="headerlink" title="二.借用构造函数"></a>二.借用构造函数</h4><blockquote><p>解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数,即在子类型构造函数的内部调用超类型构造函数。因为，<strong>函数只不过是在特定环境中执行代码的对象</strong>，因此通过使用 apply()和call()方法也可以在（将来）新创建的对象上执行构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line"> this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line"> //继承了 SuperType</span><br><span class="line"> SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors); //&quot;red,blue,green,black&quot;</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors); //&quot;red,blue,green&quot;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>新创建的 SubType 实例的环境下调用了 SuperType 构造函数。<br>这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果，<br>SubType 的每个实例就都会具有自己的 colors 属性的副本了。</p></blockquote><p><strong>2.1. 传递参数</strong></p><blockquote><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。看下面这个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line"> //继承了 SuperType，同时还传递了参数</span><br><span class="line"> SuperType.call(this, &quot;Nicholas&quot;);</span><br><span class="line"></span><br><span class="line"> //实例属性</span><br><span class="line"> this.age = 29;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.name); //&quot;Nicholas&quot;;</span><br><span class="line">alert(instance.age); //29</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>以上代码中的 SuperType 只接受一个参数 name，该参数会直接赋给一个属性。在 SubType 构造<br>函数内部调用 SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。为了确保<br>SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中<br>定义的属性。</p></blockquote><p><strong>2.2. 缺点</strong></p><ul><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><blockquote><p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定<br>义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结<br>果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术<strong>也是很少单独使用的</strong>。</p></blockquote><h4 id="三-组合继承"><a href="#三-组合继承" class="headerlink" title="三 组合继承"></a>三 组合继承</h4><p>是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line"> this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line"> //继承属性</span><br><span class="line"> // 第二次调用SuperType()</span><br><span class="line"> SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line"> this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">// 继承方法</span><br><span class="line">// 构建原型链</span><br><span class="line">// 第一次调用SuperType()</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line"> alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors); //&quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName(); //&quot;Nicholas&quot;;</span><br><span class="line">instance1.sayAge(); //29</span><br><span class="line">var instance2 = new SubType(&quot;Greg&quot;, 27);</span><br><span class="line">alert(instance2.colors); //&quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName(); //&quot;Greg&quot;;</span><br><span class="line">instance2.sayAge(); //27</span><br></pre></td></tr></table></figure></p><p><strong>缺点：</strong></p><p><img src="https://note.youdao.com/yws/api/personal/file/F91BEAFDC46749D1ADB8E7E54E1517BB?method=download&amp;shareKey=d28d6c0a26a8bf6dfc4888668ba57a59" alt="img"></p><blockquote><p>第一次调用SuperType()：给SubType.prototype写入两个属性name，color。<br>第二次调用SuperType()：给instance1写入两个属性name，color。<br>实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。<br>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p></blockquote><h4 id="四-原型式继承"><a href="#四-原型式继承" class="headerlink" title="四 原型式继承"></a>四 原型式继承</h4><blockquote><p>是借助原型可以基于已有的对象创建新对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line"> function F()&#123;&#125;</span><br><span class="line"> F.prototype = o;</span><br><span class="line"> return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的<br>原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。来看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line"> name: &quot;Nicholas&quot;,</span><br><span class="line"> friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">var yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line">alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么<br>一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person对象，于是我们把它传入到 object()函数中，然后该函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friends 不仅属于 person 所有，而且也会被anotherPerson以及yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本。es5通过新增<strong>Object.create()</strong>方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入<strong>一个参数</strong>的情况下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object.create()与 object()方法的行为相同。</span><br><span class="line">var person = &#123;</span><br><span class="line"></span><br><span class="line">name: &quot;Nicholas&quot;,</span><br><span class="line"></span><br><span class="line">friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = Object.create(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line"></span><br><span class="line">var yetAnotherPerson = Object.create(person);</span><br><span class="line">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line">alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br></pre></td></tr></table></figure></p></blockquote><p>Object.create()方法的第二个参数与Object.defineProperties()(理解对象的定义多个属性)方法的第二个参数格式相<br>同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属<br>性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line"> name: &quot;Nicholas&quot;,</span><br><span class="line"> friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = Object.create(person, &#123;</span><br><span class="line"></span><br><span class="line">name: &#123;</span><br><span class="line"></span><br><span class="line">value: &quot;Greg&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(anotherPerson.name); //&quot;Greg&quot;</span><br></pre></td></tr></table></figure></p><p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的<br><strong>缺点： </strong></p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数<h4 id="五-寄生式继承"><a href="#五-寄生式继承" class="headerlink" title="五 寄生式继承"></a>五 寄生式继承</h4><blockquote><p>寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line"> var clone = object(original); //通过调用函数创建一个新对象</span><br><span class="line"> clone.sayHi = function()&#123; //以某种方式来增强这个对象</span><br><span class="line"> alert(&quot;hi&quot;);</span><br><span class="line"> &#125;;</span><br><span class="line"> return clone; //返回这个对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line"> name: &quot;Nicholas&quot;,</span><br><span class="line"> friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); //&quot;hi&quot;</span><br></pre></td></tr></table></figure><p>这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person<br>的所有属性和方法，而且还有自己的 sayHi()方法。<br>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示<br>范继承模式时使用的 <strong>object()函数不是必需的</strong>；任何能够返回新对象的函数都适用于此模式。</p><p><strong>缺点（同原型式继承）</strong>：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数<h4 id="六-寄生组合式继承"><a href="#六-寄生组合式继承" class="headerlink" title="六 寄生组合式继承"></a>六 寄生组合式继承</h4><blockquote><p>结合借用构造函数传递参数和寄生模式实现继承<br><strong>背景</strong></p></blockquote></li></ul><blockquote><p>前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的<br>问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是<br>在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子<br>类型构造函数时重写这些属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line"> this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line"> SuperType.call(this, name); //第二次调用 SuperType()</span><br><span class="line"></span><br><span class="line"> this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType(); //第一次调用 SuperType()</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line"> alert(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><p>加粗字体的行中是调用 SuperType 构造函数的代码。在第一次调用 SuperType 构造函数时，<br>SubType.prototype 会得到两个属性：name 和 colors；它们都是 SuperType 的实例属性，只不过<br>现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这<br>一次又在新对象上创建了实例属性 name 和 colors。于是，这两个属性就屏蔽了原型中的两个同名属<br>性。图 6-6 展示了上述过程。<br><strong>有两组 name 和 colors 属性：一组在实例上，一组在 SubType 原型中。（上面有图说明</strong>这就是调<br>用两次 SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。<br>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背<br>后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型<br>原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型<br>的原型。寄生组合式继承的基本模式如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType)&#123;</span><br><span class="line"> var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本</span><br><span class="line"> prototype.constructor = subType;                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br><span class="line"> subType.prototype = prototype;                      // 指定对象，将新创建的对象赋值给子类的原型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类初始化实例属性和原型属性</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line"> this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line"> SuperType.call(this, name);</span><br><span class="line"> this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将父类原型指向子类</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">// 新增子类原型属性</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line"> alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;xyc&quot;, 23);</span><br><span class="line">var instance2 = new SubType(&quot;lxy&quot;, 23);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(&quot;2&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]</span><br><span class="line">instance1.colors.push(&quot;3&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</span><br></pre></td></tr></table></figure></p><p><img src="https://note.youdao.com/yws/api/personal/file/DEFACD1D69D04F1ABF4366D8C98BC298?method=download&amp;shareKey=ca967273dbb2d4423afe0429984516ed" alt="img"></p><blockquote><p>这个例子的高效率体现在它只调用了一次SuperType 构造函数，并且因此避免了在SubType.prototype 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和isPrototypeOf()</p></blockquote><p><strong>这是最成熟的方法，也是现在库实现的方法</strong></p><h4 id="七-混入方式继承多个对象"><a href="#七-混入方式继承多个对象" class="headerlink" title="七 混入方式继承多个对象"></a>七 混入方式继承多个对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function MyClass() &#123;</span><br><span class="line">    SuperClass.call(this);</span><br><span class="line">    OtherSuperClass.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承一个类</span><br><span class="line">MyClass.prototype = Object.create(SuperClass.prototype);</span><br><span class="line">// 混合其它</span><br><span class="line">Object.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line">// 重新指定constructor</span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = function() &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Object.assign会把  OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="基础5.3.：面向对象之继承的的七种方式" scheme="https://93qlin.github.io/categories/%E5%9F%BA%E7%A1%805-3-%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>多个连续的箭头函数与柯里化</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%A4%9A%E4%B8%AA%E8%BF%9E%E7%BB%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://93qlin.github.io/2019/02/28/多个连续的箭头函数与柯里化/</id>
    <published>2019-02-28T03:12:12.520Z</published>
    <updated>2019-02-28T03:12:12.520Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数定义：将函数作为参数或者返回值是函数的函数。</p><p>所以高阶函数分两种：</p><p>是我们常见的 sort,reduce 等函数。<br>返回值是函数的函数。<br>一般而言，我们要理解常见的高阶函数还是很容易的。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(a) &#123;</span><br><span class="line">    return function(b) &#123;</span><br><span class="line">        return a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add3 = add(3)</span><br><span class="line">add3(4) === 3 + 4 //true</span><br><span class="line">add 函数 在 es6 里的写法等价为</span><br><span class="line"></span><br><span class="line">let add = a =&gt; b =&gt; a + b</span><br></pre></td></tr></table></figure></p><p>其实以上就是 柯里化函数 只不过用 es6 写，变了一个样子，后面详细介绍它的原理和特点。</p><p>多个连续的箭头函数<br>but 当一堆箭头函数在你面前的时候，你会不会有一丝犹豫，我在此之前就是一脸懵逼。。。比如我看到下面的 redux-thunk 的源码（没错整个源码只有14行）里的多个连续箭头函数的时候。。。</p><p>// 形如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a =&gt; b =&gt; c =&gt; &#123;xxx&#125;</span><br></pre></td></tr></table></figure></p><p>那怎么轻松理解这些箭头干了啥呢，当我看了柯里化后，瞬间就懂了，</p><p>多个连续箭头函数就是 es6的多次柯里化的写法</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>我们先看 stackoverflow 的关于如何理解多个箭头函数的最高票回答,</p><p>他说 这就是柯里化函数。(This is a curried function)</p><p>wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术</p><p>好，现在懂没，我来简单说一下。</p><p>关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let add = x =&gt; y =&gt; x + y</span><br><span class="line">let add2 = add(2)</span><br></pre></td></tr></table></figure></p><p>本来完成 add 这个操作，应该是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let add = (x, y) =&gt; x + y</span><br></pre></td></tr></table></figure></p><p>它需要俩参数，而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。</p><p>详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y =&gt; x + y 函数</p><p>并且此时 x = 2，所以此时调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add2(3) === 2 + 3</span><br></pre></td></tr></table></figure></p><p>回归正题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let add = x =&gt; y =&gt; x + y</span><br></pre></td></tr></table></figure></p><p>add 函数按照 wiki 的定义可以理解成只柯里化了一次，那么下面这种呢？</p><p>a =&gt; b =&gt; c =&gt; {xxx}<br>n 个连续箭头组成的函数实际上就是柯里化了 n - 1次。</p><p>具体调用过程如下：</p><p>前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值。</p><p>结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。</p><p>所以连续箭头函数就是多次柯里化函数的 es6 写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let test = a =&gt; b =&gt; c =&gt; &#123;xxx&#125;</span><br></pre></td></tr></table></figure></p><p>调用特点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let test = a =&gt; b =&gt; c =&gt; &#123;xxx&#125;</span><br></pre></td></tr></table></figure></p><p>比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c</p><p>柯里化函数的功能<br>可以惰性求值<br>可以提前传递部分参数<br>出自(<a href="https://www.cnblogs.com/xueandsi/p/6032578.html" target="_blank" rel="noopener">https://www.cnblogs.com/xueandsi/p/6032578.html</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="多个连续的箭头函数与柯里化" scheme="https://93qlin.github.io/categories/%E5%A4%9A%E4%B8%AA%E8%BF%9E%E7%BB%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
    
      <category term="es6" scheme="https://93qlin.github.io/tags/es6/"/>
    
      <category term="javascript" scheme="https://93qlin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>基础5.2：面向对象之创建对象的七种模式</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%805.2%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%83%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://93qlin.github.io/2019/02/28/基础5.2：面向对象之创建对象的七种模式/</id>
    <published>2019-02-28T03:12:12.519Z</published>
    <updated>2019-02-28T03:12:12.520Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>七种模式：<br>1.工厂模式<br>2.构造函数模式<br>3.原型模式<br>4.组合使用构造函数模式和原型模式(<strong>最佳</strong>)<br>5.动态原型模式<br>6.寄生构造函数模式(和工厂模式差不多)<br>7.稳妥构造函数模式(遵循与寄生构造函数类似的模式)</p></blockquote><h4 id="一-工厂模式"><a href="#一-工厂模式" class="headerlink" title="一.工厂模式"></a>一.工厂模式</h4><p><strong>1.工厂模式</strong></p><blockquote><p>考虑到在 ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　function createPerson(name,age,job)&#123;</span><br><span class="line">　　　　var o = new Object();</span><br><span class="line">　　　　o.name = name;</span><br><span class="line">　　　　o.age = age;</span><br><span class="line">　　　　o.job = job;</span><br><span class="line">　　　　o.sayName = function()&#123;</span><br><span class="line">　　　　　　alert(this.name);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return o;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var person1 = createPerson(&apos;Grey&apos;,27,&apos;Doctor&apos;);</span><br></pre></td></tr></table></figure></p></blockquote><p>　　</p><blockquote><p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建\多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型？）。</p></blockquote><p><strong>什么是对象类型</strong>？</p><blockquote><p>JS中，可以将对象分为“内部对象”、“宿主对象”和“自定义对象”三种。</p></blockquote><p>1 内部对象<br>js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError和TypeError。<br>其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。</p><p>2 宿主对象<br>宿主对象就是执行JS脚本的环境提供的对象。对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，增加开发难度。<br>浏览器对象有很多，如Window和Document等等。</p><p>3 自定义对象<br>顾名思义，就是开发人员自己定义的对象。JS允许使用自定义对象，使JS应用及功能得到扩充。</p><blockquote><p><strong>优点</strong>：主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复</p></blockquote><blockquote><p><strong>缺点</strong>：工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例.</p></blockquote><h4 id="二-构造函数模式"><a href="#二-构造函数模式" class="headerlink" title="二.构造函数模式"></a>二.构造函数模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">　　　　this.name = name;</span><br><span class="line">　　　　this.age = age;</span><br><span class="line">　　　　this.job = job;</span><br><span class="line">　　　　this.sayName = function()&#123;</span><br><span class="line">　　　　　　alert(this.name);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">　　var person2 = new Person(&apos;Grey&apos;,27,&apos;Doctor&apos;);</span><br></pre></td></tr></table></figure><p><strong>不同：</strong></p><p>1 没有显式地创建对象</p><p>2 直接将属性和方法赋给了 this 对象</p><p>3 没有 return 语句</p><p><strong>经历的步骤</strong></p><p>(1) 创建一个新对象；</p><p>(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</p><p>(3) 执行构造函数中的代码（为这个新对象添加属性）；</p><p>(4) 返回新对象。</p><blockquote><p>person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 <strong>constructor</strong>（构造函数）属性，该属性指向 Person，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.constructor == Person); //true</span><br><span class="line">alert(person2.constructor == Person); //true</span><br></pre></td></tr></table></figure></p></blockquote><p>对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person的实例，这一点通过 instanceof 操作符可以得到验证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(person1 instanceof Object); //true</span><br><span class="line">alert(person1 instanceof Person); //true</span><br><span class="line">alert(person2 instanceof Object); //true</span><br><span class="line">alert(person2 instanceof Person); //true</span><br></pre></td></tr></table></figure></p><blockquote><p>优点：实例标识为一种特定的类型，即知道person1（person2）是Person对象的实例</p></blockquote><blockquote><p>弊端：也就是说相同的Person实例都有不同Function的实例，造成作用域链和标识符解析不同。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.sayName == person2.sayName); //false</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="三-原型模式"><a href="#三-原型模式" class="headerlink" title="三.原型模式"></a>三.原型模式</h4><blockquote><p>prototype（原型）属性：我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName(); //&quot;Nicholas&quot;</span><br><span class="line">var person2 = new Person();</span><br><span class="line">person2.sayName(); //&quot;Nicholas&quot;</span><br><span class="line">alert(person1.sayName == person2.sayName); //true</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1 和 person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的工作原理，必须先理解 ECMAScript 中原型对象的性质。</p></blockquote><p><strong>1. 理解原型对象?</strong></p><blockquote><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype<br>属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor<br>（构造函数）属性，这个属性包含一<strong>个指向 prototype 属性所在函数的指针</strong>。就拿前面的例子来说，<br>Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象<br>添加其他属性和方法。</p></blockquote><blockquote><p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从 Object继承而来的。<strong>m 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象</strong>。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari和Chrome在每个对象上都支持一个属性<strong>proto</strong>；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。前面使用Person构造函数和Person.prototype创建实例的代码为例，下图展示了各个对象之间的关系。</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/82F24F1BEBBF42A5B3229EF5C032F797?method=download&amp;shareKey=0958ee754b400a6552ffb3ba59ba88ea" alt="img"></p><blockquote><p>虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过<strong>查找对象属性的过程</strong>来实现的。</p></blockquote><p><strong>isPrototypeOf()</strong>:</p><blockquote><p>虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之<br>间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用 isPrototypeOf()方法的对象<br>（Person.prototype），那么这个方法就返回 true，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1)); //true</span><br><span class="line">alert(Person.prototype.isPrototypeOf(person2)); //true</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>ES5:Object.getPrototypeOf()</strong></p><blockquote><p>ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个<br>方法返回[[Prototype]]的值。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.getPrototypeOf(person1) == Person.prototype); //true</span><br><span class="line">alert(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这里的第一行代码只是确定 Object.getPrototypeOf()返回的对象实际就是这个对象的原型。<br>第二行代码取得了原型对象中 name 属性的值，也就是”Nicholas”。使用 Object.getPrototypeOf()<br>可以方便地取得一个对象的原型</p></blockquote><p><strong>查找对象属性的过程</strong></p><blockquote><p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值.这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p></blockquote><p><strong>注意：前面提到过，原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问</strong></p><blockquote><p>前面的构造函数模式说person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person</p></blockquote><p><strong>问题这个constructor属性到底是在实例中还是在构造函数中？</strong><br><strong>尝试解答</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.hasOwnProperty(&quot;constructor&quot;)); //false</span><br></pre></td></tr></table></figure></p><p>以上说明person1的constructor（构造函数）属性不是实例属性</p><p><strong>（1）.通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值（2）.如果在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。（3）.修改后的例子中，我们使用 delete 操作符删除了 person1.name，之前它保存的”Greg”<br>值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 name 属性的连接。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">person1.name = &quot;Greg&quot;;</span><br><span class="line">alert(person1.name); //&quot;Greg&quot;——来自实例</span><br><span class="line">alert(person2.name); //&quot;Nicholas&quot;——来自原型</span><br><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name); //&quot;Nicholas&quot;——来自原型</span><br></pre></td></tr></table></figure></p><p><strong>hasOwnProperty()方法</strong></p><blockquote><p>使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不<br>要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。来看下面这个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">alert(person1.hasOwnProperty(&quot;name&quot;)); //false</span><br><span class="line">person1.name = &quot;Greg&quot;;</span><br><span class="line">alert(person1.name); //&quot;Greg&quot;——来自实例</span><br><span class="line">alert(person1.hasOwnProperty(&quot;name&quot;)); //true</span><br><span class="line">alert(person2.name); //&quot;Nicholas&quot;——来自原型</span><br><span class="line">alert(person2.hasOwnProperty(&quot;name&quot;)); //false</span><br><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name); //&quot;Nicholas&quot;——来自原型</span><br><span class="line">alert(person1.hasOwnProperty(&quot;name&quot;)); //false</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法只能用于实例属<br>性，要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()方法。</strong></p><p><strong>2. 原型与 in 操作符</strong></p><blockquote><p>有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在通<br>过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。看一看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">alert(person1.hasOwnProperty(&quot;name&quot;)); //false</span><br><span class="line">alert(&quot;name&quot; in person1); //true</span><br><span class="line">person1.name = &quot;Greg&quot;;</span><br><span class="line">alert(person1.name); //&quot;Greg&quot; ——来自实例</span><br><span class="line">alert(person1.hasOwnProperty(&quot;name&quot;)); //true</span><br><span class="line">alert(&quot;name&quot; in person1); //true</span><br><span class="line">alert(person2.name); //&quot;Nicholas&quot; ——来自原型</span><br><span class="line">alert(person2.hasOwnProperty(&quot;name&quot;)); //false</span><br><span class="line">alert(&quot;name&quot; in person2); //true</span><br><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name); //&quot;Nicholas&quot; ——来自原型</span><br><span class="line">alert(person1.hasOwnProperty(&quot;name&quot;)); //false</span><br><span class="line">alert(&quot;name&quot; in person1); //true</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>无论该属性存在于实例中还是存在于原型中。<br>同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于<br>原型中，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hasPrototypeProperty(object, name)&#123;</span><br><span class="line"> return !object.hasOwnProperty(name) &amp;&amp; (name in object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>由于 in 操作符只要通过对象能够访问到属性就返回 true，hasOwnProperty()只在属性存在于<br>实例中时才返回 true，因此只要 in 操作符返回 true 而 hasOwnProperty()返回 false，就可以确<br>定属性是原型中的属性。下面来看一看上面定义的函数 hasPrototypeProperty()的用法。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person = new Person();</span><br><span class="line">alert(hasPrototypeProperty(person, &quot;name&quot;)); //true</span><br><span class="line">person.name = &quot;Greg&quot;;</span><br><span class="line">alert(hasPrototypeProperty(person, &quot;name&quot;)); //false</span><br></pre></td></tr></table></figure></p></blockquote><p>在使用 <strong>for-in</strong> 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中<br>既包括存在于实例中的属性，也包括存在于原型中的属性。<strong>屏蔽了(重写或其他)</strong>原型中不可枚举属性（即将<br>[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所<br>有开发人员定义的属性都是可枚举的——只有在 IE8 及更早版本中例外。<br>IE 早期版本的实现中存在一个 bug，即屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line"> toString : function()&#123;</span><br><span class="line"> return &quot;My Object&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">for (var prop in o)&#123;</span><br><span class="line"> if (prop == &quot;toString&quot;)&#123;</span><br><span class="line"> alert(&quot;Found toString&quot;); //在 IE 中不会显示</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这里的对象 o 定义了<br>一个名为 toString()的方法，该方法屏蔽了原型中（不可枚举）的 toString()方法。在 IE 中，由<br>于其实现认为原型的 toString()方法被打上了值为 false 的[[Enumerable]]标记，因此应该跳过<br>该属性，结果我们就不会看到警告框。该 bug 会影响默认不可枚举的所有属性和方法，包括：<br>hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和 valueOf()。<br>ECMAScript 5 也将 constructor 和 prototype 属性的[[Enumerable]]特性设置为 false，但并不<br>是所有浏览器都照此实现。</p></blockquote><p><strong>Object.keys()</strong></p><blockquote><p>这个方法可以取得对象上<strong>所有可枚举的实例属性</strong>，<br>接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;Nicholas&quot;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var keys = Object.keys(Person.prototype);</span><br><span class="line">alert(keys); //&quot;name,age,job,sayName&quot;</span><br><span class="line">var p1 = new Person();</span><br><span class="line">p1.name = &quot;Rob&quot;;</span><br><span class="line">p1.age = 31;</span><br><span class="line">var p1keys = Object.keys(p1);</span><br><span class="line">alert(p1keys); //&quot;name,age</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>变量 keys 中将保存一个数组，数组中是字符串”name”、”age”、”job”和”sayName”。这<br>个顺序也是它们在 for-in 循环中出现的顺序。如果是通过 Person 的<strong>实例调用，则 Object.keys()<br>返回的数组只包含”name”和”age”这两个实例属性。</strong><br>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()<br>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var keys = Object.getOwnPropertyNames(Person.prototype);</span><br><span class="line">alert(keys); //&quot;constructor,name,age,job,sayName&quot;</span><br></pre></td></tr></table></figure></p></blockquote><p>注意结果中包含了<strong>不可枚举的 constructor 属性</strong>。Object.keys()和 Object.getOwnProperty￾Names()方法都可以用来替代 for-in 循环。支持这两个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera<br>12+和 Chrome。</p><ol start="3"><li><strong>更简单的原型语法</strong><blockquote><p>每添加一个属性和方法就要敲一遍 Person.prototype。为减少<br>不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的<br>对象字面量来重写整个原型对象，如下面的例子所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> name : &quot;Nicholas&quot;,</span><br><span class="line"> age : 29,</span><br><span class="line"> job: &quot;Software Engineer&quot;,</span><br><span class="line"> sayName : function () &#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。<br>最终结果相同，但有一个例外：constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一<br>个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在<br>这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新<br>对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时，尽管 instanceof<br>操作符还能返回正确的结果，<strong>但通过 constructor 已经无法确定对象的类型了</strong>，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var friend = new Person();</span><br><span class="line">alert(friend instanceof Object); //true</span><br><span class="line">alert(friend instanceof Person); //true</span><br><span class="line">alert(friend.constructor == Person); //false</span><br><span class="line">alert(friend.constructor == Object); //true</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>解决方法：</strong></p><blockquote><p>在此，用 instanceof 操作符测试 Object 和 Person 仍然返回 true，但 constructor 属性则<br>等于 Object 而不等于 Person 了。如果 constructor 的值真的很重要，可以像下面这样特意将它设<br>置回适当的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> constructor : Person,</span><br><span class="line"> name : &quot;Nicholas&quot;,</span><br><span class="line"> age : 29,</span><br><span class="line"> job: &quot;Software Engineer&quot;,</span><br><span class="line"> sayName : function () &#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>又有个问题</strong>：</p><blockquote><p>以上代码特意包含了一个 constructor 属性，并将它的值设置为 Person，从而确保了通过该属<br>性能够访问到适当的值。<br>注意，以这种方式重设 constructor 属性会<strong>导致它的[[Enumerable]]特性被设置为 true</strong>。默认<br>情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引<br>擎，可以试一试 Object.defineProperty()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> name : &quot;Nicholas&quot;,</span><br><span class="line"> age : 29,</span><br><span class="line"> job : &quot;Software Engineer&quot;,</span><br><span class="line"> sayName : function () &#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><p>//重设构造函数，只适用于 ECMAScript 5 兼容的浏览器<br>Object.defineProperty(Person.prototype, “constructor”, {<br>    enumerable: false,<br>    value: Person<br>});<br><strong>4. 原型的动态性</strong></p><blockquote><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上<br>反映出来——即使是先创建了实例后修改原型也照样如此。请看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype.sayHi = function()&#123;</span><br><span class="line"> alert(&quot;hi&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi(); //&quot;hi&quot;（没有问题！）</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>以上代码先创建了 Person 的一个实例，并将其保存在 person 中。然后，下一条语句在 Person.<br>prototype 中添加了一个方法 sayHi()。即使 person 实例是在添加新方法之前创建的，但它仍然可<br>以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 person.sayHi()<br>时，首先会在实例中搜索名为 sayHi 的属性，在没找到的情况下，会继续搜索原型。因为<strong>实例与原型<br>之间的连接只不过是一个指针</strong>，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存<br>在那里的函数。<br>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重<br>写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的<br>[[Prototype]]指针，而把<strong>原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系</strong>。<br>请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> constructor: Person,</span><br><span class="line"> name : &quot;Nicholas&quot;,</span><br><span class="line"> age : 29,</span><br><span class="line"> job : &quot;Software Engineer&quot;,</span><br><span class="line"> sayName : function () &#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayName(); //error</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在这个例子中，我们先创建了 Person 的一个实例，然后又重写了其原型对象。然后在调用<br>friend.sayName()时发生了错误，因为 friend 指向的原型中不包含以该名字命名的属性。图 6-3 展示了这个过程的内幕。</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/5C45C62B0F5C43A992B13EFDBF7623A7?method=download&amp;shareKey=90c922c7b933d2287f8760e39565ba51" alt="img"></p><blockquote><p>从图 6-3 可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它<br>们引用的仍然是最初的原型。<br><strong>5. 原生对象的原型</strong><br>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式<br>创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。<br>例如，在 Array.prototype 中可以找到 sort()方法，而在 String.prototype 中可以找到<br>substring()方法，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof Array.prototype.sort); //&quot;function&quot;</span><br><span class="line">alert(typeof String.prototype.substring); //&quot;function&quot;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自<br>定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型<br>String 添加了一个名为 startsWith()的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.startsWith = function (text) &#123;</span><br><span class="line"> return this.indexOf(text) == 0;</span><br><span class="line">&#125;;</span><br><span class="line">var msg = &quot;Hello world!&quot;;</span><br><span class="line">alert(msg.startsWith(&quot;Hello&quot;)); //true</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这里新定义的 startsWith()方法会在传入的文本位于一个字符串开始时返回 true。既然方法被<br>添加给了 String.prototype，那么当前环境中的所有字符串就都可以调用它。由于 msg 是字符串，<br>而且后台会调用 String 基本包装函数创建这个字符串，因此通过 msg 就可以调用 startsWith()方法。</p></blockquote><p><strong>缺点6. 原型对象的问题</strong></p><blockquote><p>原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于<strong>包含引用类型值的属性来说，问题就比较突出了</strong>。来看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> constructor: Person,</span><br><span class="line"> name : &quot;Nicholas&quot;,</span><br><span class="line"> age : 29,</span><br><span class="line"> job : &quot;Software Engineer&quot;,</span><br><span class="line"> friends : [&quot;Shelby&quot;, &quot;Court&quot;],</span><br><span class="line"> sayName : function () &#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends); //&quot;Shelby,Court,Van&quot;</span><br><span class="line">alert(person2.friends); //&quot;Shelby,Court,Van&quot;</span><br><span class="line">alert(person1.friends === person2.friends); //true</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>假如我们的初衷就是像这样<br>在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部<br>属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。</p></blockquote><h4 id="四-组合使用构造函数模式和原型模式"><a href="#四-组合使用构造函数模式和原型模式" class="headerlink" title="四.组合使用构造函数模式和原型模式"></a>四.组合使用构造函数模式和原型模式</h4><p>组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参<br>数；可谓是集两种模式之长。下面的代码重写了前面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line"> this.name = name;</span><br><span class="line"> this.age = age;</span><br><span class="line"> this.job = job;</span><br><span class="line"> this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"> constructor : Person,</span><br><span class="line"> sayName : function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends); //&quot;Shelby,Count,Van&quot;</span><br><span class="line">alert(person2.friends); //&quot;Shelby,Count&quot;</span><br><span class="line">alert(person1.friends === person2.friends); //false</span><br><span class="line">alert(person1.sayName === person2.sayName); //true</span><br></pre></td></tr></table></figure></p><blockquote><p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方<br>法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不<br>会影响到 person2.friends，因为它们分别引用了不同的数组。<br>这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自<br>定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p></blockquote><h4 id="五-动态原型模式"><a href="#五-动态原型模式" class="headerlink" title="五. 动态原型模式"></a>五. 动态原型模式</h4><blockquote><p>有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原<br>型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数<br>中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过<br>检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line"> //属性</span><br><span class="line"> this.name = name;</span><br><span class="line"> this.age = age;</span><br><span class="line"> this.job = job;</span><br><span class="line">//方法</span><br><span class="line"> if (typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line"></span><br><span class="line"> Person.prototype.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>注意构造函数代码中加粗的部分。这里<strong>只在 sayName()方法不存在的情况下，才会将它添加到原<br>型中</strong>。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修<br>改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可<br>以说非常完美。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆<br>if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使<br>用 instanceof 操作符确定它的类型。</p></blockquote><p><strong>使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果<br>在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系</strong>。</p><h4 id="六-寄生构造函数模式-和工厂模式差不多"><a href="#六-寄生构造函数模式-和工厂模式差不多" class="headerlink" title="六 寄生构造函数模式(和工厂模式差不多)"></a>六 寄生构造函数模式(和工厂模式差不多)</h4><blockquote><p>通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式<br>的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但<br>从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line"> var o = new Object();</span><br><span class="line"> o.name = name;</span><br><span class="line"> o.age = age;</span><br><span class="line"> o.job = job;</span><br><span class="line"> o.sayName = function()&#123;</span><br><span class="line"> alert(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">friend.sayName(); //&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure></p></blockquote><p>在这个例子中，Person 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返<br>回了这个对象。除了<strong>使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实<br>是一模一样的</strong>。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以<strong>重写</strong>调用构造函数时<strong>返回的值</strong>。<br>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray()&#123;</span><br><span class="line"> //创建数组</span><br><span class="line"> var values = new Array();</span><br><span class="line"> //添加值</span><br><span class="line"> values.push.apply(values, arguments);</span><br><span class="line"> //添加方法</span><br><span class="line"> values.toPipedString = function()&#123;</span><br><span class="line"> return this.join(&quot;|&quot;);</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> //返回数组</span><br><span class="line"> return values;</span><br><span class="line">&#125;</span><br><span class="line">var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</span><br><span class="line">alert(colors.toPipedString()); //&quot;red|blue|green&quot;</span><br></pre></td></tr></table></figure></p><blockquote><p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间<strong>没有关系</strong>；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。</p></blockquote><h4 id="七-稳妥构造函数模式-遵循与寄生构造函数类似的模式"><a href="#七-稳妥构造函数模式-遵循与寄生构造函数类似的模式" class="headerlink" title="七. 稳妥构造函数模式(遵循与寄生构造函数类似的模式)"></a>七. 稳妥构造函数模式(遵循与寄生构造函数类似的模式)</h4><blockquote><p>道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这<br>个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在<br>一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup<br>程序）改动时使用。<strong>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同</strong>：一是新创建对象的<br>实例方法不引用 this；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面<br>的 Person 构造函数重写如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line"></span><br><span class="line"> //创建要返回的对象</span><br><span class="line"> var o = new Object();</span><br><span class="line"> //可以在这里定义私有变量和函数</span><br><span class="line"> //添加方法</span><br><span class="line"> o.sayName = function()&#123;</span><br><span class="line"> alert(name);</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> //返回对象</span><br><span class="line"> return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>注意，在以这种模式创建的对象中，<strong>除了使用 sayName()方法之外，没有其他办法访问 name 的值</strong>。可以像下面使用稳妥的 Person 构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var friend = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">friend.sayName(); //&quot;Nicholas&quot;</span><br></pre></td></tr></table></figure></p><blockquote><p>这样，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName()方法外，没有别的方式可<br>以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传<br>入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环<br>境——例如，ADsafe（<a href="http://www.adsafe.org）和" target="_blank" rel="noopener">www.adsafe.org）和</a> Caja（<a href="http://code.google.com/p/google-caja/）提供的环境——" target="_blank" rel="noopener">http://code.google.com/p/google-caja/）提供的环境——</a><br>下使用。<br>与寄生构造函数模式类似，<strong>使用稳妥构造函数模式创建的对象与构造函数之间也<br>没有什么关系</strong>，因此 instanceof 操作符对这种对象也没有意义。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="基础5.2：面向对象之创建对象的七种模式" scheme="https://93qlin.github.io/categories/%E5%9F%BA%E7%A1%805-2%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%83%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>3.3作用域与作用域链</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%803.3%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <id>https://93qlin.github.io/2019/02/28/基础3.3：作用域和作用域链/</id>
    <published>2019-02-28T03:12:12.518Z</published>
    <updated>2019-02-28T03:12:12.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-作用域？"><a href="#1-作用域？" class="headerlink" title="1.作用域？"></a>1.作用域？</h4><blockquote><p>变量a的作用域是什么？一会儿又问：函数a的作用域是什么？变量和函数的作用域分别是啥玩意？<br>我们先来看看“作用域”是什么意思，“作用域”拆开来就是“作用”和“域”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：访问、操作、调用……</span><br><span class="line">域：区域、范围、空间……</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>作用域</strong>: 就是变量和函数的可访问范围，或者说变量或函数起作用的区域。</p><p>1.javascript函数的作用域：</p><blockquote><p>函数内的区域，就是这个函数的作用域，变量和函数在这个区域都可以访问操作。最外层函数外的区域叫全局作用域，函数内的区域叫局部作用域。</p></blockquote><p>2.javascript变量的作用域：</p><blockquote><p>在源代码中变量所在的区域，就是这个变量的作用域，变量在这个区域内可以被访问操作。在全局作用域上定义的变量叫全局变量，在函数内定义的变量叫局部变量。<br>简单地理解，JS源代码被函数{ }划分成一块一块的区域，这些区域换个身份就是某函数或某变量的作用域，变量的作用域和函数的作用域在源代码中有可能指的是同一块区域。</p></blockquote><h4 id="2-作用域链"><a href="#2-作用域链" class="headerlink" title="2.作用域链"></a>2.作用域链</h4><p>作用域链（Scope Chain）是javascript内部中一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域链<br>作用域链的形成原理，通过1999年的ECMAScript-262-3th第三版来说明作用域链的形成原理，将会介绍执行环境，变量对象和活动对象，arguments对象，作用域链等几个概念。2009年发布了ECMAScript-262-5th第五版，不同的是取消了变量对象和活动对象等概念，引入了词法环境（Lexical Environments）、环境记录（EnviromentRecord）等新的概念，所以两个版本的概念不要混淆了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="3.3作用域与作用域链" scheme="https://93qlin.github.io/categories/3-3%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="javascript" scheme="https://93qlin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>基础5.1：面向对象之理解对象</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%805.1%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/"/>
    <id>https://93qlin.github.io/2019/02/28/基础5.1：面向对象之理解对象/</id>
    <published>2019-02-28T03:12:12.518Z</published>
    <updated>2019-02-28T03:12:12.519Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="理解对象属性"><a href="#理解对象属性" class="headerlink" title="理解对象属性"></a>理解对象属性</h3><h4 id="一-属性类型"><a href="#一-属性类型" class="headerlink" title="一 属性类型"></a>一 属性类型</h4><blockquote><p>首先理解特性与属性的关系?<br>特性是内部值，描述了属性的特征，ECMA-262第五版把特性放在两对方括号中</p></blockquote><h5 id="1-1-数据属性"><a href="#1-1-数据属性" class="headerlink" title="1.1.数据属性"></a>1.1.数据属性</h5><blockquote><p>包含一个数据值的位置，这个位置可以读取和写入值，数据属性有4个描述其行为的特性。</p><ol><li>[[Configurable]]  能否通过delete删除属性而定义新属性，能否修改属性的特性，能否把属性设置为访问器属性。直接在对象上定义的属性默认为true。</li><li>[[Enumberable]] 能否通过for-in循环返回属性，直接在对象上定义的属性默认为true。</li><li>[[Writeable]] 能否修改属性的值 直接在对象上定义的属性默认为true。</li><li>[[Value]]  包含这个属性的数据值，这个特性默认为undefined。<br><strong>Object.defineProperty()方法</strong><br>要修改这四个，默认属性必须使用这个方法<br>这个方法接受三个参数（”属性所在的对象”，”属性的名字”，描述符对象），其中描述符对象属性必须是上面四个的一个或多个。可以修改对应的特性值。</li></ol></blockquote><h4 id="1-2-访问器属性"><a href="#1-2-访问器属性" class="headerlink" title="1.2. 访问器属性"></a>1.2. 访问器属性</h4><p>它不包含数据值，包含<strong>getter和setter</strong>(这两个 不是必须的)，在读取访问器属性时会调用getter函数，在写入访问器属性时会调用setter函数并传入新值，负责处理数据。</p><ol><li>[[Configurable]]  能否通过delete删除属性而定义新属性，能否修改属性的特性，能否把属性设置为数据属性。直接在对象上定义的属性默认为true。</li><li>[[Enumberable]] 能否通过for-in循环返回属性，直接在对象上定义的属性默认为true。</li><li>[[Get]] 读取属性时调用的函数，默认undefined。</li><li>[[Value]] 设置属性时调用的函数，默认undefined。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line"> _year: 2004,</span><br><span class="line"> edition: 1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class="line"> get: function()&#123;</span><br><span class="line"> return this._year;</span><br><span class="line"> &#125;,</span><br><span class="line"> set: function(newValue)&#123;</span><br><span class="line"> if (newValue &gt; 2004) &#123;</span><br><span class="line"> this._year = newValue;</span><br><span class="line"> this.edition += newValue - 2004;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = 2005;</span><br><span class="line">alert(book.edition); //2</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>以上代码创建了一个 book 对象，并给它定义两个默认的属性：_year 和 edition._year 前面<br>的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性 year 则包含一个<br>getter 函数和一个 setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此，<br>把 year 属性修改为 2005 会导致_year 变成 2005，而 edition 变为 2。这是使用访问器属性的常见方<br>式，即设置一个属性的值会导致其他属性发生变化。</p></blockquote><h4 id="二-多个属性"><a href="#二-多个属性" class="headerlink" title="二.多个属性"></a>二.多个属性</h4><p><strong>Object.defineProperties()方法</strong><br>。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一<br>个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对<br>应。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;;</span><br><span class="line">Object.defineProperties(book, &#123;</span><br><span class="line">     _year: &#123;</span><br><span class="line">     value: 2004</span><br><span class="line">     &#125;,</span><br><span class="line">     edition: &#123;</span><br><span class="line">        value: 1</span><br><span class="line">     &#125;,</span><br><span class="line">     year: &#123;</span><br><span class="line">        get: function()&#123;</span><br><span class="line">             return this._year;</span><br><span class="line">         &#125;,</span><br><span class="line">         set: function(newValue)&#123;</span><br><span class="line">            if (newValue &gt; 2004) &#123;</span><br><span class="line">                this._year = newValue;</span><br><span class="line">                this.edition += newValue - 2004;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>以上代码在 book对象上定义了两个数据属性（_year 和 edition）和一个访问器属性（year）。<br>最终的对象与上一节中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。<br>支持 Object.defineProperties()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和<br>Chrome。</p></blockquote><h4 id="三-读取属性的特性"><a href="#三-读取属性的特性" class="headerlink" title="三.读取属性的特性"></a>三.读取属性的特性</h4><p><strong>的 Object.getOwnPropertyDescriptor()</strong><br>可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果<br>是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这<br>个对象的属性有 configurable、enumerable、writable 和 value。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;;</span><br><span class="line">Object.defineProperties(book, &#123;</span><br><span class="line"> _year: &#123;</span><br><span class="line">    value: 2004</span><br><span class="line"> &#125;,</span><br><span class="line"> edition: &#123;</span><br><span class="line">    value: 1</span><br><span class="line"> &#125;,</span><br><span class="line"> year: &#123;</span><br><span class="line">     get: function()&#123;</span><br><span class="line">         return this._year;</span><br><span class="line">    &#125;,</span><br><span class="line">     set: function(newValue)&#123;</span><br><span class="line">         if (newValue &gt; 2004) &#123;</span><br><span class="line">             this._year = newValue;</span><br><span class="line">             this.edition += newValue - 2004;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);</span><br><span class="line">alert(descriptor.value); //2004</span><br><span class="line">alert(descriptor.configurable); //false</span><br><span class="line">alert(typeof descriptor.get); //&quot;undefined&quot;</span><br><span class="line">var descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);</span><br><span class="line">alert(descriptor.value); //undefined</span><br><span class="line">alert(descriptor.enumerable); //false</span><br><span class="line">alert(typeof descriptor.get); //&quot;function&quot;</span><br></pre></td></tr></table></figure></p><blockquote><p>对于<strong>数据属性_year</strong>，value 等于最初的值，configurable 是 false，而 get 等于 undefined。<br>对于<strong>访问器属性 year</strong>，value 等于 undefined，enumerable 是 false，而 get 是一个指向 getter<br>函数的指针。<br>在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 Object.getOwnPropertyDescriptor()方法。支持这个方法的浏览器有<br>IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。</p></blockquote><blockquote><p>总结：本节应该知道以下三点：</p><ol><li>属性类型。</li><li>定义多个属性</li><li>读取属性<strong>特性</strong></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="基础5.1：面向对象之理解对象" scheme="https://93qlin.github.io/categories/%E5%9F%BA%E7%A1%805-1%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>基础4.4：js内存与内存泄漏</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%804.4%EF%BC%9Ajs%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://93qlin.github.io/2019/02/28/基础4.4：js内存与内存泄漏/</id>
    <published>2019-02-28T03:12:12.518Z</published>
    <updated>2019-02-28T03:12:12.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="基础4.4：js内存与内存泄漏" scheme="https://93qlin.github.io/categories/%E5%9F%BA%E7%A1%804-4%EF%BC%9Ajs%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>基础2.3：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%802.3%EF%BC%9A%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E5%AE%8C%E5%96%84%E8%87%AA%E5%B7%B1%E7%9A%84%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%81/"/>
    <id>https://93qlin.github.io/2019/02/28/基础2.3：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！/</id>
    <published>2019-02-28T03:12:12.518Z</published>
    <updated>2019-02-28T03:12:12.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="基础2.3：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！" scheme="https://93qlin.github.io/categories/%E5%9F%BA%E7%A1%802-3%EF%BC%9A%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E5%AE%8C%E5%96%84%E8%87%AA%E5%B7%B1%E7%9A%84%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%81/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%802.2%EF%BC%9Athis/"/>
    <id>https://93qlin.github.io/2019/02/28/基础2.2：this/</id>
    <published>2019-02-28T03:12:12.518Z</published>
    <updated>2019-02-28T03:12:12.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html</a><br>先来一道题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;//全局变量  值为10</span><br><span class="line"> function foo() &#123;</span><br><span class="line">     console.log(this)//此处this一直指向window, 所以this.a一直是10</span><br><span class="line">     console.log(a);</span><br><span class="line">     //a全局变量  打印10</span><br><span class="line"> &#125;</span><br><span class="line"> (function() &#123;//自执行函数 此处this指代window,自执行函数其实是window对象调用它！函数分普通函数和构造函数普通函数的this指向window，构造函数的this指向它本身，谁调用它this就指向谁！</span><br><span class="line">     var a = 20;</span><br><span class="line">     console.log(this.a)//10</span><br><span class="line">     foo();//依然打印10</span><br><span class="line"> &#125;)();</span><br><span class="line"> (function (func) &#123;//自执行函数 此处this指代window</span><br><span class="line">     var a = 30;</span><br><span class="line">     console.log(this.a)//10</span><br><span class="line">     func();//依然打印10</span><br><span class="line"> &#125;)(foo)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="this" scheme="https://93qlin.github.io/categories/this/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>基础2.1：闭包，作用域链，作用域链理解闭包</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%802.1%EF%BC%9A%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/"/>
    <id>https://93qlin.github.io/2019/02/28/基础2.1：闭包，作用域链，作用域链理解闭包/</id>
    <published>2019-02-28T03:12:12.518Z</published>
    <updated>2019-02-28T03:12:12.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="基础2.1：闭包，作用域链，作用域链理解闭包" scheme="https://93qlin.github.io/categories/%E5%9F%BA%E7%A1%802-1%EF%BC%9A%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>图片上传</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    <id>https://93qlin.github.io/2019/02/28/图片上传/</id>
    <published>2019-02-28T03:12:12.517Z</published>
    <updated>2019-02-28T03:12:12.517Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="图片上传（https-blog-csdn-net-qq-29712995-article-details-78839093）"><a href="#图片上传（https-blog-csdn-net-qq-29712995-article-details-78839093）" class="headerlink" title="图片上传（https://blog.csdn.net/qq_29712995/article/details/78839093）"></a>图片上传（<a href="https://blog.csdn.net/qq_29712995/article/details/78839093）" target="_blank" rel="noopener">https://blog.csdn.net/qq_29712995/article/details/78839093）</a></h4><p>安装axios的话：</p><blockquote><p>1利用npm安装npm install axios –save</p></blockquote><blockquote><p>2使用ES6的写法引入<br>import axios from ‘axios’<br>我们可能会想，如何使用axios上传照片：<br>一般情况上传照片有两种方式：</p></blockquote><blockquote><p>1.本地图片转换成base64，然后通过普通的post请求发送到服务端。操作简单，适合小图，以及如果想兼容低版本的ie没办法用此方法，还有就是最近我想应用到微信小程序中，发现小程序目前还不可以将图片转换为base64.</p></blockquote><p>以下是我的代码</p><p>HTML代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input accept=&quot;image/*&quot; name=&quot;img&quot; id=&quot;upload_file&quot; type=&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>JS代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var file = document.getElementById(&quot;upload_file&quot;).files[0];</span><br><span class="line">var r = new FileReader();  //本地预览</span><br><span class="line">r.onload = function()&#123;</span><br><span class="line">    console.log(r.result);//图片的base64</span><br><span class="line">&#125;</span><br><span class="line">r.readAsDataURL(file);    //Base64</span><br></pre></td></tr></table></figure></p><p>2.通过form表单提交。</p><blockquote><p>form表单提交图片会刷新页面，也可以是form绑定到一个隐藏的iframe上，可以实现无刷新提交数据。</p></blockquote><p>HTML代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input accept=&quot;image/*&quot; name=&quot;img&quot; id=&quot;upload_file&quot; type=&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>JS代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">var file = document.getElementById(&quot;upload_file&quot;).files[0];</span><br><span class="line">var formdata1=new FormData();// 创建form对象</span><br><span class="line">formdata1.append(&apos;img&apos;,file,file.name);//</span><br></pre></td></tr></table></figure></p><blockquote><p>通过append向form对象添加数据,可以通过append继续添加数据<br>//或formdata1.append(‘img’,file);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let config = &#123;</span><br><span class="line">    headers:&#123;&apos;Content-Type&apos;:&apos;multipart/form-data&apos;&#125;</span><br><span class="line">&#125;;  //添加请求头</span><br><span class="line">axios.post(&apos;/xapi/upimage&apos;,formdata1,config).then(response)=&gt;&#123;   //这里的/xapi/upimage为接口</span><br><span class="line">    console.log(response.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这里注意的是，设置 的==Content-Type==<br>查看是否成功：按F12-network-点击对应的那个请求<br>可以看到</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="图片上传" scheme="https://93qlin.github.io/categories/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    
    
      <category term="javascript" scheme="https://93qlin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>基础1.2：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%801.1%EF%BC%9A%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%B0JS%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84%E4%B8%80%E6%AC%A1%E6%A2%B3%E7%90%86/"/>
    <id>https://93qlin.github.io/2019/02/28/基础1.1：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理/</id>
    <published>2019-02-28T03:12:12.517Z</published>
    <updated>2019-02-28T03:12:12.517Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="基础1.2：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理" scheme="https://93qlin.github.io/categories/%E5%9F%BA%E7%A1%801-2%EF%BC%9A%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%B0JS%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84%E4%B8%80%E6%AC%A1%E6%A2%B3%E7%90%86/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>判断数据类型</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://93qlin.github.io/2019/02/28/判断数据类型/</id>
    <published>2019-02-28T03:12:12.517Z</published>
    <updated>2019-02-28T03:12:12.517Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用Object-prototype上的原生toString-方法判断数据类型，使用方法如下："><a href="#使用Object-prototype上的原生toString-方法判断数据类型，使用方法如下：" class="headerlink" title="使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下："></a>使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下：</h1><h2 id="1-判断基本类型："><a href="#1-判断基本类型：" class="headerlink" title="1.判断基本类型："></a>1.判断基本类型：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(null);//”[object Null]”</span><br><span class="line">Object.prototype.toString.call(undefined);//”[object Undefined]”</span><br><span class="line">Object.prototype.toString.call(“abc”);//”[object String]”</span><br><span class="line">Object.prototype.toString.call(123);//”[object Number]”</span><br><span class="line">Object.prototype.toString.call(true);//”[object Boolean]”</span><br></pre></td></tr></table></figure><h2 id="2-判断原生引用类型："><a href="#2-判断原生引用类型：" class="headerlink" title="2.判断原生引用类型："></a>2.判断原生引用类型：</h2><p>函数类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function fn()&#123;console.log(“test”);&#125;</span><br><span class="line">Object.prototype.toString.call(fn);//”[object Function]”</span><br></pre></td></tr></table></figure></p><p>日期类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">Object.prototype.toString.call(date);//”[object Date]”</span><br></pre></td></tr></table></figure></p><p>数组类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3];</span><br><span class="line">Object.prototype.toString.call(arr);//”[object Array]”</span><br></pre></td></tr></table></figure></p><p>正则表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg = /[hbc]at/gi;</span><br><span class="line">Object.prototype.toString.call(arr);//”[object Array]”</span><br></pre></td></tr></table></figure></p><p>自定义类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&quot;Rose&quot;, 18);</span><br><span class="line">Object.prototype.toString.call(arr); //”[object Object]”</span><br></pre></td></tr></table></figure></p><blockquote><p>很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示：<br>console.log(person instanceof Person);//输出结果为true<br>3.判断原生JSON对象：</p></blockquote><p>var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON);<br>console.log(isNativeJSON);//输出结果为”[object JSON]”说明JSON是原生的，否则不是；</p><blockquote><p>注意：Object.prototype.toString()本身是允许被修改的，而我们目前所讨论的关于Object.prototype.toString()这个方法的应用都是假设toString()方法未被修改为前提的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="判断数据类型" scheme="https://93qlin.github.io/categories/%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="javascript" scheme="https://93qlin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>基础1.1:变量（变量提升,暂时性死区）、执行环境、执行栈、作用域</title>
    <link href="https://93qlin.github.io/2019/02/28/%E5%9F%BA%E7%A1%801.2%EF%BC%9A%E5%8F%98%E9%87%8F%EF%BC%88%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87,%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%EF%BC%89%E3%80%81%E6%89%A7%E8%A1%8C%EF%BC%88%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%89%E7%8E%AF%E5%A2%83%E3%80%81%E6%89%A7%E8%A1%8C%E6%A0%88%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://93qlin.github.io/2019/02/28/基础1.2：变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、作用域/</id>
    <published>2019-02-28T03:12:12.517Z</published>
    <updated>2019-02-28T03:12:12.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一·变量提升"><a href="#一·变量提升" class="headerlink" title="一·变量提升"></a>一·变量提升</h3><p>首先两个打印例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;ghostwu&apos;;</span><br><span class="line">var a;</span><br><span class="line">console.log( a );   //ghostwu</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log( a );</span><br><span class="line">var a = &apos;ghostwu&apos;; //undefined</span><br></pre></td></tr></table></figure><p><strong>why?</strong></p><blockquote><p>首先:明确两点</p><ul><li>javascript代码并不是一行一行往下执行的.</li><li>javascript执行分为2个步骤:<pre><code>1.编译(词法解释/预解释)2.执行</code></pre></li></ul></blockquote><blockquote><p>其次:当我们碰到 var a = “ghostwu” 定义一个变量的时候， 其实js把这句话看成是2个阶段的事,  var a 发生在==编译==阶段， a = ‘ghostwu’发生在执行阶段. 然后 var a会被提升到当前作用域的最前面,  a = ‘ghostwu’留在原地==等待执行==阶段，所以：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;ghostwu&apos;;</span><br><span class="line">var a;</span><br><span class="line">console.log( a );</span><br><span class="line">// 上面这段代码经过编译之后，变成下面这样</span><br><span class="line">var a;  //被提升到当前作用域的最前面</span><br><span class="line">a = &apos;ghostwu&apos;; //留在原地，等待执行</span><br><span class="line">console.log( a );</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log( a );</span><br><span class="line">var a = &apos;ghostwu&apos;;</span><br><span class="line">//上面这段代码,经过编译之后，变成下面这样</span><br><span class="line">var a;</span><br><span class="line">console.log( a );</span><br><span class="line">a = &apos;ghostwu&apos;;</span><br></pre></td></tr></table></figure><p><strong>明确函数定义的两种方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//函数声明, 形如:</span><br><span class="line">function show()&#123;</span><br><span class="line">    console.log( &apos;函数声明方式&apos; );</span><br><span class="line">&#125;</span><br><span class="line">//函数表达式, 形如:</span><br><span class="line">var show = function()&#123;</span><br><span class="line">    console.log( &apos;表达式方式&apos; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为表达式和函数声明，在编译阶段，会产生不同的解释效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show(); //undefined</span><br><span class="line">function show()&#123;</span><br><span class="line">    console.log( a );</span><br><span class="line">    var a = &apos;ghostwu&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>函数声明会被提升</strong></p><blockquote><p>所以，上面的代码，经过编译之后，就变成了下面这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function show()&#123;    //函数声明被提升到 当前作用域的最前面</span><br><span class="line">    var a;    //var声明被提升到当前作用域的最前面, 注意，它不会提升到函数的外面, 因为当前的作用域是在函数中</span><br><span class="line">    console.log( a );</span><br><span class="line">    a = &apos;ghostwu&apos;;</span><br><span class="line">&#125;</span><br><span class="line">show();</span><br></pre></td></tr></table></figure><p><strong>函数表达式，是不会提升的</strong>, 看下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">show(); //报错,show is not a function</span><br><span class="line">var show = function()&#123;</span><br><span class="line">console.log( &apos;ghostwu&apos; );</span><br><span class="line">&#125;</span><br><span class="line">//对于上面这段表达式代码，经过编译之后:</span><br><span class="line">var show;</span><br><span class="line">show();  //执行之后就是 undefined, 所以在表达式定义之前，调用函数报错了</span><br><span class="line">show = function()&#123;</span><br><span class="line">console.log( &apos;ghostwu&apos; );</span><br></pre></td></tr></table></figure></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show(); //你好</span><br><span class="line">var show;</span><br><span class="line">function show()&#123;</span><br><span class="line">    console.log( &apos;你好&apos; );</span><br><span class="line">&#125;</span><br><span class="line">show = function()&#123;</span><br><span class="line">    console.log( &apos;hello&apos; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子<strong>为什么</strong>是你好？<br>因为： 当出现同名的函数声明，变量声明的时候， 函数声明会被优先提升，变量声明会被忽略。 所以经过编译之后，就变成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function show()&#123;</span><br><span class="line">    console.log( &apos;你好&apos; );</span><br><span class="line">&#125;</span><br><span class="line">show(); //你好</span><br><span class="line">show = function()&#123;</span><br><span class="line">    console.log( &apos;hello&apos; );</span><br><span class="line">&#125;</span><br><span class="line">show();//如果这里在调用一次，就是hello, 因为show函数体在执行阶段 被 重新赋值了</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>如果有同名的函数声明，后面的会覆盖前面的，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">show(); //how are you</span><br><span class="line">var show;</span><br><span class="line">function show()&#123;</span><br><span class="line">    console.log( &apos;hello&apos; );</span><br><span class="line">&#125;    </span><br><span class="line">show = function()&#123;</span><br><span class="line">    console.log( &apos;你好&apos; );</span><br><span class="line">&#125;</span><br><span class="line">function show()&#123;</span><br><span class="line">    console.log( &apos;how are you!&apos; );</span><br><span class="line">&#125;</span><br><span class="line">//上面的代码经过编译之后，变成如下形式:</span><br><span class="line">function show()&#123;</span><br><span class="line">    console.log( &apos;how are you!&apos; );</span><br><span class="line">&#125;</span><br><span class="line">show(); //how are you</span><br><span class="line">show = function()&#123;</span><br><span class="line">    console.log( &apos;你好&apos; );</span><br><span class="line">&#125;</span><br><span class="line">show(); //如果在这里再执行一次，结果：你好</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>暂时性死区</strong><br>我们都知道，var声明的变量会有变量提升的作用，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);  //1</span><br><span class="line">var a=1;</span><br><span class="line">console.log(b);  //undefined</span><br><span class="line">var b;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看出，虽然代码中console调用a在前，声明a在后，但是由于在js中，函数及变量的声明都将被提升到函数的最顶部，也就是说（var声明的）变量可以先使用再声明。</p></blockquote><blockquote><p>然后，使用let，const（后面会提及）声明的变量却不存在变量提升。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo); // Uncaught ReferenceError: foo is not defined</span><br><span class="line">let foo = 2;</span><br><span class="line"></span><br><span class="line">console.log(foo1); // Uncaught ReferenceError: foo1 is not defined</span><br><span class="line">let foo1;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>ES6明确规定</strong>，如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。所以在代码块内，使用let,const命令声明变量之前，该变量都是<strong>不可用</strong>的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></blockquote><blockquote><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p></blockquote><p>注：“暂时性死区”也意味着typeof不再是一个百分之百安全的操作，因为会使typeof报错。</p><blockquote><p>变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 <strong>let和 const</strong>的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。<br><strong>let不允许在相同作用域内，重复声明同一个变量。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  let aa;</span><br><span class="line">  let aa; // Uncaught SyntaxError: Identifier &apos;aa&apos; has already been declared</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">  var _aa;</span><br><span class="line">  let _aa; // Uncaught SyntaxError: Identifier &apos;_aa&apos; has already been declared</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">  let aa_;</span><br><span class="line">  var aa_; // Uncaught SyntaxError: Identifier &apos;aa_&apos; has already been declared</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>全局变量 vs 全局对象的属性</strong></p><blockquote><p>ES5中全局对象的属性与全局变量基本是等价的，但是也有区别，比如通过var声明的全局变量不能使用delete从 window/global （ global是针对与node环境）上删除，不过在变量的访问上基本等价。</p></blockquote><blockquote><p>ES6 中做了严格的区分，使用 var 和 function 声明的全局变量依旧作为全局对象的属性，使用 let, const 命令声明的全局变量<strong>不属于全局对象的属性</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let let_test = &apos;test&apos;;</span><br><span class="line">console.log(window.let_test);   // undefined</span><br><span class="line">console.log(this.let_test);   // undefined</span><br><span class="line"></span><br><span class="line">var var_test = &apos;test&apos;;</span><br><span class="line">console.log(window.var_test);  // test</span><br><span class="line">console.log(this.var_test);  // test</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>const</strong></p><blockquote><p>除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是<strong>固定的（常量）。使用const声明变量的时候，必须同时赋值，否则会报错。并且之后任何试图修改值的操作都会引起错误</strong>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const data;  //Uncaught SyntaxError: Missing initializer in const declaration</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    const b = 3; // 包含在 if 中的块作用域常量</span><br><span class="line">    a = 3; // 正常 !</span><br><span class="line">    b = 4; // Uncaught TypeError: Assignment to constant variable.</span><br><span class="line">&#125;</span><br><span class="line">console.log( a ); // 3</span><br><span class="line">console.log( b ); // Uncaught ReferenceError: b is not defined</span><br></pre></td></tr></table></figure><blockquote><p>注：复合类型const变量保存的是引用。因为复合类型的常量不指向数据，而是指向数据(heap)所在的地址(stack)，所以通过 const 声明的复合类型只能保证其地址引用不变，但不能保证其数据不变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr= [1, 2];</span><br><span class="line">// 修改数据而不修改引用地址，正确执行</span><br><span class="line">arr.push(3);  // [1, 2, 3]</span><br><span class="line">// 修改 arr 常量所保存的地址的值，报错</span><br><span class="line">arr = [];     // Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>简单的使用const无法完成对象的冻结。可以通过<strong>Object.freeze</strong>()方法实现对对象的冻结。使用Object.freeze()方法返回的对象将不能对其属性进行配置(definedProperty()不可用)同时<strong>不能添加新的属性和移除(remove)已有属性</strong>。彻底冻结对象时需要递归的对它的对象属性进行冻结。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    b1: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.b.b1 = 3;</span><br><span class="line">console.log(obj.b.b1 ); //3</span><br><span class="line">function freeze(obj)&#123;</span><br><span class="line">  Object.freeze(obj);</span><br><span class="line">  Object.values(obj).forEach(function (value,index) &#123;</span><br><span class="line">    if(typeof value === &apos;object&apos;)&#123;</span><br><span class="line">      freeze(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">freeze(obj);</span><br><span class="line">obj.b.b1 = 4;</span><br><span class="line">console.log(obj.b.b1); //3</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="二：执行环境"><a href="#二：执行环境" class="headerlink" title="二：执行环境"></a>二：执行环境</h3><p><strong>什么是js的”执行环境”？</strong></p><blockquote><p> 执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其它数据，决定了各自的行为。每个执行环境中包含这三部分：变量对象/活动对象，作用域链，this的值,当JavaScript代码执行的时候，会进入不同的执行环境，这些不同的执行环境就构成了执行环境栈。</p></blockquote><p><strong>执行环境的类型</strong></p><blockquote><p>执行环境总共有三种类型<br>1.全局执行环境：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。<br>2.函数执行环境：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行环境。<br>3.Eval 函数执行环境： 指的是运行在 eval 函数中的代码，不用很少用而且不建议使用。</p></blockquote><p><strong>执行栈</strong></p><blockquote><p>用于存储在代码执行期间创建的所有执行环境。</p></blockquote><blockquote><p>JavaScript解释器在浏览器中是<strong>单线程</strong>的（<strong>下面再说进程和线程</strong>），这意味着浏览器在同一时间内只执行一个事件，对于其他的事件我们把它们排队在一个称为 执行栈的地方。下表是一个单线程栈的抽象视图。</p></blockquote><p><img src="/img/zhixing.jpg" alt="image"></p><blockquote><p>当浏览器第一次加载你的script，它默认的进了全局执行环境。如果在你的全局代码中你调用了一个函数，那么顺序流就会进入到你调用的函数当中，创建一个新的执行环境并且把这个环境添加到执行栈的顶部。如果在当前的函数中调用了其他函数，同样的事会再次发生。执行流进入内部函数，并且创建一个新的执行环境，把它添加到已经存在的执行栈的顶部。浏览器始终执行当前在栈顶部的执行环境。一旦函数完成了当前的执行环境，它就会被弹出栈的顶部, 把控制权返回给当前执行环境的下个执行环境。下面例子展示了一个递归函数和该程序的执行栈：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">foo(++i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;(<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这段代码简单地调用了自己三次，由1递增i的值。每次函数foo被调用，一个新的执行环境就会被调用。一旦一个环境完成了执行，它就会被弹出执行栈并且把控制权返回给当前执行环境的下个执行环境直到再次到达全局执行环境。</p></blockquote><p><strong>记住执行栈，有五个关键点</strong></p><ul><li>单线程</li><li>同步执行</li><li>一个全局环境</li><li>无限的函数环境</li><li>函数被调用就会创建一个新的执行环境，甚至调用自己。</li></ul><p><strong>执行环境的详情</strong></p><blockquote><p>一个函数被调用就会创建一个新的执行环境。然而解释器的内部，每次调用执行环境会有<strong>两个阶段：</strong></p><ol><li>创建阶段</li></ol><ul><li>当函数被调用，但是为执行内部代码之前:</li><li>创建一个<a href="http://davidshariff.com/blog/javascript-scope-chain-and-closures/" target="_blank" rel="noopener">作用域链</a>。</li><li>创建变量，函数和参数。</li><li>确定this的值。</li></ul><ol start="2"><li>激活/代码执行阶段</li></ol><ul><li>赋值，引用函数，解释/执行代码。<br>这可能意味着每个执行环境在概念上作为一个对象并带有三个属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executionContextObj = &#123;</span><br><span class="line">scopeChain: &#123; <span class="comment">/* variableObject + all parent execution context's variableObject */</span> &#125;,</span><br><span class="line"><span class="comment">//作用域链：&#123;变量对象＋所有父执行环境的变量对象&#125;</span></span><br><span class="line">variableObject: &#123; <span class="comment">/* function arguments / parameters, inner variable and function declarations */</span> &#125;,</span><br><span class="line"><span class="comment">//变量对象:&#123;函数形参＋内部的变量＋函数声明(但不包含表达式)&#125;</span></span><br><span class="line"><span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><strong>活动／变量 对象(AO/VO)</strong><br>当函数被调用，executionContextObj就被创建，该对象在实际函数执行前就已创建。这就是已知的第一个阶段创建阶段.在第一阶段，解释器创建了executionContextObj对象，通过扫描函数，传递形参，函数声明和局部变量声明。扫描的结果成为了变量对象在executionContextObj中。</p><ul><li>这有一个解释器是如何评估代码的伪概述：</li></ul><ol><li>找到一些代码来调用函数</li><li>在执行函数代码前，创建执行环境</li><li>进入创建阶段：</li></ol><ul><li>初始化作用域链</li><li>创建变量对象:</li><li>创建arguments对象，检查环境中的参数，初始化名和值，创建一个参考副本</li><li>扫描环境中内的函数声明：</li><li>某个函数被发现，在变量对象创建一个属性，它是函数的确切名。它是一个指针在内存中，指向这个函数。</li><li>如果这个函数名已存在，这个指针的值将会重写。</li><li>扫描环境内的变量声明</li><li>某个变量声明被发现，在变量对象中创建一个属性，他是变量的名，初始化它的值为undefined。</li><li>如果变量名在变量对象中已存在，什么也不做，继续扫描。</li><li>在环境中确定this的值。</li></ul><ol start="4"><li>激活/代码执行阶段：在当前环境上运行/解释函数代码，并随着代码一行行执行指派变量的值</li></ol><p>看下面例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">privateB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">22</span>);</span><br></pre></td></tr></table></figure></p><p>On calling foo(22), the creation stage looks as follows:<br>在调用foo(22)时，创建阶段像下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">scopeChain: &#123; ... &#125;,</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">22</span>,</span><br><span class="line">c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">a</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function"><span class="title">b</span>: <span class="title">undefined</span></span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">this</span>: </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正如你看到的，创建阶段处理了定义属性的名，但是并不把值赋给变量，不包括形参和实参。一旦创建阶段完成,执行流进入函数并且激活/代码执行阶段,在函数执行结束之后，看起来像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fooExecutionContext = &#123;</span><br><span class="line">scopeChain: &#123; ... &#125;,</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">22</span>,</span><br><span class="line">c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">a</span>: '<span class="title">hello</span>',</span></span><br><span class="line"><span class="function"><span class="title">b</span>: <span class="title">pointer</span> <span class="title">to</span> <span class="title">function</span> <span class="title">privateB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">this</span>: </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>进阶一言</strong></p><p>你可以在网上找到大量的术语来描述JavaScript进阶。解释变量和函数声明被提升到它们函数作用域的顶端。然而，没有一个详细的解释为什么这样， 现在你配备了关于解释器怎么创建活动对象的新知识，这会很明白这是为什么。看看下面例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">​(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo); <span class="comment">// function pointer</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'hello'</span>,</span><br><span class="line">bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'world'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;());​</span><br></pre></td></tr></table></figure></p><p>现在我们能解答的问题有：</p><p>为什么在声明foo之前我们就可以调用?<br>如果我们按照创建阶段进行，我们知道变量在激活/执行阶段之前已经被创建了。因此，在函数流开始执行，foo已经在活动对象中被定义了。<br>foo被声明了两次, 为什么foo展现出来的是functiton，而不是undefined或者string<br>我们从创建阶段知道,尽管foo被声明了两次，函数在活动对象中是在变量之前被创建的，并且如果属性名在活动对象已经存在,我们会简单地绕过这个声明。</p><p>所以，引用函数foo（）是在活动对象上第一次被创建的， 当我们解释到 var foo的时候，我们发现属性名foo已经存在，所以代码不会做任何处理，只是继续进行</p><p>为什么bar是undefined？</p><p>bar确实是一个变量，并且值是一个函数。我们知道变量是在创建阶段被创建的，但是它们的值被初始化为undefined。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="基础1.1:变量（变量提升,暂时性死区）、执行环境、执行栈、作用域" scheme="https://93qlin.github.io/categories/%E5%9F%BA%E7%A1%801-1-%E5%8F%98%E9%87%8F%EF%BC%88%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%EF%BC%89%E3%80%81%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E3%80%81%E6%89%A7%E8%A1%8C%E6%A0%88%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
    
      <category term="基础" scheme="https://93qlin.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://93qlin.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
