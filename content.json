{"meta":{"title":"永不言弃","subtitle":"一步一脚印，一岁一枯荣，never never give up","description":null,"author":"lin","url":"https://93qlin.github.io"},"pages":[{"title":"categories","date":"2018-09-04T13:16:35.000Z","updated":"2019-02-28T03:12:12.522Z","comments":false,"path":"categories/index.html","permalink":"https://93qlin.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-02-28T03:12:12.524Z","updated":"2019-02-28T03:12:12.524Z","comments":true,"path":"dist/music.js","permalink":"https://93qlin.github.io/dist/music.js","excerpt":"","text":"const ap = new APlayer({ container: document.getElementById('aplayer'), fixed: true, autoplay: false, audio: [{ name: \"PDD洪荒之力\", artist: '徐梦圆', url: 'http://up.mcyt.net/?down/39868.mp3', cover: 'http://oeff2vktt.bkt.clouddn.com/image/84.jpg', }, { name: '9420', artist: '麦小兜', url: 'http://up.mcyt.net/?down/45967.mp3', cover: 'http://oeff2vktt.bkt.clouddn.com/image/8.jpg', }, { name: '风筝误', artist: '刘珂矣', url: 'http://up.mcyt.net/?down/46644.mp3', cover: 'http://oeff2vktt.bkt.clouddn.com/image/96.jpg', } ] });"},{"title":"tags","date":"2018-09-04T13:15:05.000Z","updated":"2019-02-28T03:12:12.525Z","comments":false,"path":"tags/index.html","permalink":"https://93qlin.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-02-28T03:12:12.522Z","updated":"2019-02-28T03:12:12.522Z","comments":true,"path":"dist/APlayer.min.css","permalink":"https://93qlin.github.io/dist/APlayer.min.css","excerpt":"","text":".aplayer{background:#fff;font-family:Arial,Helvetica,sans-serif;margin:5px;box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);border-radius:2px;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;position:relative}.aplayer *{box-sizing:content-box}.aplayer svg{width:100%;height:100%}.aplayer svg circle,.aplayer svg path{fill:#fff}.aplayer.aplayer-withlist .aplayer-info{border-bottom:1px solid #e9e9e9}.aplayer.aplayer-withlist .aplayer-list{display:block}.aplayer.aplayer-withlist .aplayer-icon-order,.aplayer.aplayer-withlist .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu{display:inline}.aplayer.aplayer-withlrc .aplayer-pic{height:90px;width:90px}.aplayer.aplayer-withlrc .aplayer-info{margin-left:90px;height:90px;padding:10px 7px 0}.aplayer.aplayer-withlrc .aplayer-lrc{display:block}.aplayer.aplayer-narrow{width:66px}.aplayer.aplayer-narrow .aplayer-info,.aplayer.aplayer-narrow .aplayer-list{display:none}.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic{height:66px;width:66px}.aplayer.aplayer-fixed{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;overflow:visible;max-width:400px;box-shadow:none}.aplayer.aplayer-fixed .aplayer-list{margin-bottom:65px;border:1px solid #eee;border-bottom:none}.aplayer.aplayer-fixed .aplayer-body{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;background:#fff;padding-right:18px;transition:all .3s ease;max-width:400px}.aplayer.aplayer-fixed .aplayer-lrc{display:block;position:fixed;bottom:10px;left:0;right:0;margin:0;z-index:98;pointer-events:none;text-shadow:-1px -1px 0 #fff}.aplayer.aplayer-fixed .aplayer-lrc:after,.aplayer.aplayer-fixed .aplayer-lrc:before{display:none}.aplayer.aplayer-fixed .aplayer-info{-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transform-origin:0 0;transform-origin:0 0;transition:all .3s ease;border-bottom:none;border-top:1px solid #e9e9e9}.aplayer.aplayer-fixed .aplayer-info .aplayer-music{width:calc(100% - 105px)}.aplayer.aplayer-fixed .aplayer-miniswitcher{display:block}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-info{display:block;-webkit-transform:scaleX(0);transform:scaleX(0)}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{width:66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-miniswitcher .aplayer-icon{-webkit-transform:rotateY(0);transform:rotateY(0)}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-lrc,.aplayer.aplayer-fixed .aplayer-icon-play{display:inline-block}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-menu,.aplayer.aplayer-fixed .aplayer-icon-play{position:absolute;bottom:27px;width:20px;height:20px}.aplayer.aplayer-fixed .aplayer-icon-back{right:75px}.aplayer.aplayer-fixed .aplayer-icon-play{right:50px}.aplayer.aplayer-fixed .aplayer-icon-forward{right:25px}.aplayer.aplayer-fixed .aplayer-icon-menu{right:0}.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order,.aplayer.aplayer-mobile .aplayer-icon-volume-down{display:none}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-loading-icon{display:block}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-body{position:relative}.aplayer .aplayer-icon{width:15px;height:15px;border:none;background-color:transparent;outline:none;cursor:pointer;opacity:.8;vertical-align:middle;padding:0;font-size:12px;margin:0;display:inline-block}.aplayer .aplayer-icon path{transition:all .2s ease-in-out}.aplayer .aplayer-icon-back,.aplayer .aplayer-icon-forward,.aplayer .aplayer-icon-lrc,.aplayer .aplayer-icon-order,.aplayer .aplayer-icon-play{display:none}.aplayer .aplayer-icon-lrc-inactivity svg{opacity:.4}.aplayer .aplayer-icon-forward{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.aplayer .aplayer-lrc-content{display:none}.aplayer .aplayer-pic{position:relative;float:left;height:66px;width:66px;background-size:cover;background-position:50%;transition:all .3s ease;cursor:pointer}.aplayer .aplayer-pic:hover .aplayer-button{opacity:1}.aplayer .aplayer-pic .aplayer-button{position:absolute;border-radius:50%;opacity:.8;text-shadow:0 1px 1px rgba(0,0,0,.2);box-shadow:0 1px 1px rgba(0,0,0,.2);background:rgba(0,0,0,.2);transition:all .1s ease}.aplayer .aplayer-pic .aplayer-button path{fill:#fff}.aplayer .aplayer-pic .aplayer-hide{display:none}.aplayer .aplayer-pic .aplayer-play{width:26px;height:26px;border:2px solid #fff;bottom:50%;right:50%;margin:0 -15px -15px 0}.aplayer .aplayer-pic .aplayer-play svg{position:absolute;top:3px;left:4px;height:20px;width:20px}.aplayer .aplayer-pic .aplayer-pause{width:16px;height:16px;border:2px solid #fff;bottom:4px;right:4px}.aplayer .aplayer-pic .aplayer-pause svg{position:absolute;top:2px;left:2px;height:12px;width:12px}.aplayer .aplayer-info{margin-left:66px;padding:14px 7px 0 10px;height:66px;box-sizing:border-box}.aplayer .aplayer-info .aplayer-music{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 0 13px 5px;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default;padding-bottom:2px;height:20px}.aplayer .aplayer-info .aplayer-music .aplayer-title{font-size:14px}.aplayer .aplayer-info .aplayer-music .aplayer-author{font-size:12px;color:#666}.aplayer .aplayer-info .aplayer-controller{position:relative;display:flex}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap{margin:0 0 0 5px;padding:4px 0;cursor:pointer!important;flex:1}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar{position:relative;height:2px;width:100%;background:#cdcdcd}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded{position:absolute;left:0;top:0;bottom:0;background:#aaa;height:2px;transition:all .5s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played{position:absolute;left:0;top:0;bottom:0;height:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{position:absolute;top:0;right:5px;margin-top:-4px;margin-right:-10px;height:10px;width:10px;border-radius:50%;cursor:pointer;transition:all .3s ease-in-out;-webkit-transform:scale(0);transform:scale(0)}.aplayer .aplayer-info .aplayer-controller .aplayer-time{position:relative;right:0;bottom:4px;height:17px;color:#999;font-size:11px;padding-left:7px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-time-inner{vertical-align:middle}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon{cursor:pointer;transition:all .2s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#666}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-loop{margin-right:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon:hover path{fill:#000}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-mode{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap{position:relative;display:inline-block;margin-left:3px;cursor:pointer!important}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap:hover .aplayer-volume-bar-wrap{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap{position:absolute;bottom:15px;right:-3px;width:25px;height:0;z-index:99;overflow:hidden;transition:all .2s ease-in-out}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap.aplayer-volume-bar-wrap-active{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar{position:absolute;bottom:0;right:10px;width:5px;height:35px;background:#aaa;border-radius:2.5px;overflow:hidden}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar .aplayer-volume{position:absolute;bottom:0;right:0;width:5px;transition:all .1s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon svg{position:absolute;-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}.aplayer .aplayer-lrc{display:none;position:relative;height:30px;text-align:center;overflow:hidden;margin:-10px 0 7px}.aplayer .aplayer-lrc:before{top:0;height:10%;background:linear-gradient(180deg,#fff 0,hsla(0,0%,100%,0));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ffffff\",endColorstr=\"#00ffffff\",GradientType=0)}.aplayer .aplayer-lrc:after,.aplayer .aplayer-lrc:before{position:absolute;z-index:1;display:block;overflow:hidden;width:100%;content:\" \"}.aplayer .aplayer-lrc:after{bottom:0;height:33%;background:linear-gradient(180deg,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.8));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#00ffffff\",endColorstr=\"#ccffffff\",GradientType=0)}.aplayer .aplayer-lrc p{font-size:12px;color:#666;line-height:16px!important;height:16px!important;padding:0!important;margin:0!important;transition:all .5s ease-out;opacity:.4;overflow:hidden}.aplayer .aplayer-lrc p.aplayer-lrc-current{opacity:1;overflow:visible;height:auto!important;min-height:16px}.aplayer .aplayer-lrc.aplayer-lrc-hide{display:none}.aplayer .aplayer-lrc .aplayer-lrc-contents{width:100%;transition:all .5s ease-out;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default}.aplayer .aplayer-list{overflow:auto;transition:all .5s ease;will-change:height;display:none;overflow:hidden}.aplayer .aplayer-list.aplayer-list-hide{max-height:0!important}.aplayer .aplayer-list ol{list-style-type:none;margin:0;padding:0;overflow-y:auto}.aplayer .aplayer-list ol::-webkit-scrollbar{width:5px}.aplayer .aplayer-list ol::-webkit-scrollbar-thumb{border-radius:3px;background-color:#eee}.aplayer .aplayer-list ol::-webkit-scrollbar-thumb:hover{background-color:#ccc}.aplayer .aplayer-list ol li{position:relative;height:32px;line-height:32px;padding:0 15px;font-size:12px;border-top:1px solid #e9e9e9;cursor:pointer;transition:all .2s ease;overflow:hidden;margin:0}.aplayer .aplayer-list ol li:first-child{border-top:none}.aplayer .aplayer-list ol li:hover{background:#efefef}.aplayer .aplayer-list ol li.aplayer-list-light{background:#e9e9e9}.aplayer .aplayer-list ol li.aplayer-list-light .aplayer-list-cur{display:inline-block}.aplayer .aplayer-list ol li .aplayer-list-cur{display:none;width:3px;height:22px;position:absolute;left:0;top:5px;cursor:pointer}.aplayer .aplayer-list ol li .aplayer-list-index{color:#666;margin-right:12px;cursor:pointer}.aplayer .aplayer-list ol li .aplayer-list-author{color:#666;float:right;cursor:pointer}.aplayer .aplayer-notice{opacity:0;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-size:12px;border-radius:4px;padding:5px 10px;transition:all .3s ease-in-out;overflow:hidden;color:#fff;pointer-events:none;background-color:#f4f4f5;color:#909399}.aplayer .aplayer-miniswitcher{display:none;position:absolute;top:0;right:0;bottom:0;height:100%;background:#e6e6e6;width:18px;border-radius:0 2px 2px 0}.aplayer .aplayer-miniswitcher .aplayer-icon{height:100%;width:100%;-webkit-transform:rotateY(180deg);transform:rotateY(180deg);transition:all .3s ease}.aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#666}.aplayer .aplayer-miniswitcher .aplayer-icon:hover path{fill:#000}@-webkit-keyframes aplayer-roll{0%{left:0}to{left:-100%}}@keyframes aplayer-roll{0%{left:0}to{left:-100%}}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}} /*# sourceMappingURL=APlayer.min.css.map*/"},{"title":"","date":"2019-02-28T03:12:12.523Z","updated":"2019-02-28T03:12:12.523Z","comments":true,"path":"dist/APlayer.min.js","permalink":"https://93qlin.github.io/dist/APlayer.min.js","excerpt":"","text":"!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"APlayer\",[],t):\"object\"==typeof exports?exports.APlayer=t():e.APlayer=t()}(window,function(){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var a=t[i]={i:i,l:!1,exports:{}};return e[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.r=function(e){Object.defineProperty(e,\"__esModule\",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"/\",n(n.s=41)}([function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=/mobile/i.test(window.navigator.userAgent),a={secondToTime:function(e){var t=Math.floor(e/3600),n=Math.floor((e-3600*t)/60),i=Math.floor(e-3600*t-60*n);return(t>0?[t,n,i]:[n,i]).map(function(e){return e=0;t--){var n=Math.floor(Math.random()*(t+1)),i=e[n];e[n]=e[t],e[t]=i}return e}([].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);ti?t:e+(t-e)*((a=n/i)n?\"function\"==typeof i&&i(t):l(u)}()},n=function(e){if(!e.defaultPrevented){e.preventDefault(),location.hash!==this.hash&&window.history.pushState(null,null,this.hash);var n=document.getElementById(this.hash.substring(1));if(!n)return;t(n,500,function(e){location.replace(\"#\"+e.id)})}};return document.addEventListener(\"DOMContentLoaded\",function(){for(var e,t=document.querySelectorAll('a[href^=\"#\"]:not([href=\"#\"])'),i=t.length;e=t[--i];)e.addEventListener(\"click\",n,!1)}),t}})?i.call(t,n,t,e):i)||(e.exports=a)},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=function(){function e(e,t){for(var n=0;nt&&!e.player.audio.paused&&(e.player.container.classList.remove(\"aplayer-loading\"),i=!1),t=n)},100)}},{key:\"enable\",value:function(e){this[\"enable\"+e+\"Checker\"]=!0,\"fps\"===e&&this.initfpsChecker()}},{key:\"disable\",value:function(e){this[\"enable\"+e+\"Checker\"]=!1}},{key:\"destroy\",value:function(){var e=this;this.types.forEach(function(t){e[\"enable\"+t+\"Checker\"]=!1,e[t+\"Checker\"]&&clearInterval(e[t+\"Checker\"])})}}]),e}();t.default=a},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=function(){function e(e,t){for(var n=0;n1?\"one\"===e.player.options.loop?(e.player.options.loop=\"none\",e.player.template.loop.innerHTML=r.default.loopNone):\"none\"===e.player.options.loop?(e.player.options.loop=\"all\",e.player.template.loop.innerHTML=r.default.loopAll):\"all\"===e.player.options.loop&&(e.player.options.loop=\"one\",e.player.template.loop.innerHTML=r.default.loopOne):\"one\"===e.player.options.loop||\"all\"===e.player.options.loop?(e.player.options.loop=\"none\",e.player.template.loop.innerHTML=r.default.loopNone):\"none\"===e.player.options.loop&&(e.player.options.loop=\"all\",e.player.template.loop.innerHTML=r.default.loopAll)})}},{key:\"initMenuButton\",value:function(){var e=this;this.player.template.menu.addEventListener(\"click\",function(){e.player.list.toggle()})}},{key:\"initMiniSwitcher\",value:function(){var e=this;this.player.template.miniSwitcher.addEventListener(\"click\",function(){e.player.setMode(\"mini\"===e.player.mode?\"normal\":\"mini\")})}},{key:\"initSkipButton\",value:function(){var e=this;this.player.template.skipBackButton.addEventListener(\"click\",function(){e.player.skipBack()}),this.player.template.skipForwardButton.addEventListener(\"click\",function(){e.player.skipForward()}),this.player.template.skipPlayButton.addEventListener(\"click\",function(){e.player.toggle()})}},{key:\"initLrcButton\",value:function(){var e=this;this.player.template.lrcButton.addEventListener(\"click\",function(){e.player.template.lrcButton.classList.contains(\"aplayer-icon-lrc-inactivity\")?(e.player.template.lrcButton.classList.remove(\"aplayer-icon-lrc-inactivity\"),e.player.lrc&&e.player.lrc.show()):(e.player.template.lrcButton.classList.add(\"aplayer-icon-lrc-inactivity\"),e.player.lrc&&e.player.lrc.hide())})}}]),e}();t.default=s},function(e,t,n){var i=n(2);e.exports=function(e){\"use strict\";e=e||{};var t=\"\",n=i.$each,a=e.lyrics,r=(e.$value,e.$index,i.$escape);return n(a,function(e,n){t+=\"\\n \" ,t+=\"r(e[1]),t+=\"this.current.length-1||e=this.current[this.index+1][0])for(var t=0;t=this.current[t][0]&&(!this.current[t+1]||e=200&&n.status/g,\"\").replace(/^\\s+|\\s+$/g,\"\");if(r)for(var s=r.length,l=0;l]/;a.$escape=function(e){return function(e){var t=\"\"+e,n=r.exec(t);if(!n)return e;var i=\"\",a=void 0,o=void 0,s=void 0;for(a=n.index,o=0;a\\n \\n \" ,l(n(1)(u({theme:a.theme,audio:a.audio,index:1}))),t+=\"\\n \\n\\n\\n \\n ',t+=s.play,t+='\\n \\n \\n \\n No audio\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n ',t+=s.loading,t+='\\n \\n \\n \\n \\n \\n \\n 00:00 / 00:00\\n \\n \\n ',t+=s.skip,t+='\\n \\n \\n ',t+=s.play,t+='\\n \\n \\n ',t+=s.skip,t+='\\n \\n \\n \\n ',t+=s.volumeDown,t+='\\n \\n \\n \\n \\n \\n \\n \\n \\n ',\"list\"===a.order?t+=s.orderList:\"random\"===a.order&&(t+=s.orderRandom),t+='\\n \\n \\n ',\"one\"===a.loop?t+=s.loopOne:\"all\"===a.loop?t+=s.loopAll:\"none\"===a.loop&&(t+=s.loopNone),t+='\\n \\n \\n ',t+=s.menu,t+='\\n \\n \\n ',t+=s.lrc,t+='\\n \\n \\n \\n \\n \\n ',t+=s.right,t+='\\n\\n\\n \\n \" ,l(n(1)(u({theme:a.theme,audio:a.audio,index:1}))),t+=\"\\n \\n\\n\" ),t}},function(e,t,n){\"use strict\";object.defineproperty(t,\"__esmodule\",{value:!0});var i=\"function(){function\" e(e,t){for(var n=\"0;n2&&void 0!==arguments[2])||arguments[2])&&this.list.audios[t]&&(this.list.audios[t].theme=e),this.template.listCurs[t]&&(this.template.listCurs[t].style.backgroundColor=e),t===this.list.index&&(this.template.pic.style.backgroundColor=e,this.template.played.style.background=e,this.template.thumb.style.background=e,this.template.volume.style.background=e)}},{key:\"seek\",value:function(e){e=Math.max(e,0),e=Math.min(e,this.duration),this.audio.currentTime=e,this.bar.set(\"played\",e/this.duration,\"width\"),this.template.ptime.innerHTML=r.default.secondToTime(e)}},{key:\"setUIPlaying\",value:function(){var e=this;if(this.paused&&(this.paused=!1,this.template.button.classList.remove(\"aplayer-play\"),this.template.button.classList.add(\"aplayer-pause\"),this.template.button.innerHTML=\"\",setTimeout(function(){e.template.button.innerHTML=o.default.pause},100),this.template.skipPlayButton.innerHTML=o.default.pause),this.timer.enable(\"loading\"),this.options.mutex)for(var t=0;t=.95?this.template.volumeButton.innerHTML=o.default.volumeUp:this.volume()>0?this.template.volumeButton.innerHTML=o.default.volumeDown:this.template.volumeButton.innerHTML=o.default.volumeOff}},{key:\"volume\",value:function(e,t){return e=parseFloat(e),isNaN(e)||(e=Math.max(e,0),e=Math.min(e,1),this.bar.set(\"volume\",e,\"height\"),t||this.storage.set(\"volume\",e),this.audio.volume=e,this.audio.muted&&(this.audio.muted=!1),this.switchVolumeIcon()),this.audio.muted?0:this.audio.volume}},{key:\"on\",value:function(e,t){this.events.on(e,t)}},{key:\"toggle\",value:function(){this.template.button.classList.contains(\"aplayer-play\")?this.play():this.template.button.classList.contains(\"aplayer-pause\")&&this.pause()}},{key:\"switchAudio\",value:function(e){this.list.switch(e)}},{key:\"addAudio\",value:function(e){this.list.add(e)}},{key:\"removeAudio\",value:function(e){this.list.remove(e)}},{key:\"destroy\",value:function(){m.splice(m.indexOf(this),1),this.pause(),this.container.innerHTML=\"\",this.audio.src=\"\",this.timer.destroy(),this.events.trigger(\"destroy\")}},{key:\"setMode\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"normal\";this.mode=e,\"mini\"===e?this.container.classList.add(\"aplayer-narrow\"):\"normal\"===e&&this.container.classList.remove(\"aplayer-narrow\")}},{key:\"notice\",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2e3,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;this.template.notice.innerHTML=e,this.template.notice.style.opacity=i,this.noticeTime&&clearTimeout(this.noticeTime),this.events.trigger(\"noticeshow\",{text:e}),n&&(this.noticeTime=setTimeout(function(){t.template.notice.style.opacity=0,t.events.trigger(\"noticehide\")},n))}},{key:\"prevIndex\",value:function(){if(!(this.list.audios.length>1))return 0;if(\"list\"===this.options.order)return this.list.index-11))return 0;if(\"list\"===this.options.order)return(this.list.index+1)%this.list.audios.length;if(\"random\"===this.options.order){var e=this.randomOrder.indexOf(this.list.index);return e===this.randomOrder.length-1?this.randomOrder[0]:this.randomOrder[e+1]}}},{key:\"skipBack\",value:function(){this.list.switch(this.prevIndex())}},{key:\"skipForward\",value:function(){this.list.switch(this.nextIndex())}},{key:\"duration\",get:function(){return isNaN(this.audio.duration)?0:this.audio.duration}}],[{key:\"version\",get:function(){return\"1.10.1\"}}]),e}();t.default=g},,function(e,t,n){},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),n(40);var i,a=n(38),r=(i=a)&&i.__esModule?i:{default:i};console.log(\"\\n %c APlayer v1.10.1 af84efb %c http://aplayer.js.org \\n\",\"color: #fadfa3; background: #030307; padding:5px 0;\",\"background: #fadfa3; padding:5px 0;\"),t.default=r.default}]).default}); //# sourceMappingURL=APlayer.min.js.map"}],"posts":[{"title":"2.1原型与原型链(继承)","slug":"基础2.1：原型和原型链(继承)","date":"2019-04-11T06:56:46.496Z","updated":"2019-04-14T12:21:03.953Z","comments":true,"path":"2019/04/11/基础2.1：原型和原型链(继承)/","link":"","permalink":"https://93qlin.github.io/2019/04/11/基础2.1：原型和原型链(继承)/","excerpt":"","text":"目录 &emsp;1. 原型 &emsp;2. 原型链 &emsp;2. 继承 前因后果 原因OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际方法。由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，所以其实现 继承 主要是依靠原型链继续 原型链是用来实现继承的，因為沒有類的結構，用prototype實現有類語言的繼承特性(創建構造器，指向對象)原型的作用，则是实现对象的继承 1. 原型 原型传送门 2. 原型链 原型链是实现继承的\b主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 概念： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例\b都包含一个指向原型对象的指针。假如原型对象是另一个\b构造函数的实例，那么原型对象也包含一个指向另一个原型的指针，如此层层递进，就叫原型链。简而言之：因为没有类的结构，用prototype实现有类语言的继承特性（创建构造器，指向对象） 注：所有引用类型都默认继承自 object ，object 的原型为null。 确定原型与实例之间的关系：instanceof isPrototypeOf 3. 继承 七种继承的方式传送门 使用原型继承的缺陷 缺陷一：引用类型值的原型属性会被所有实例共享 举个例： 12345678910111213141516function SuperType() &#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123;&#125;SubType.prototype = new SuperType();var instance1 = new SuperType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green,black&quot; 例子中，SubType（子类）通过原型链继承了SuperType，SubType.prototype就变成了SuperType（超类，也就是我们所说的父类）的一个实例。也就是说，SubType.prototype中会有一个colors的数组，SubType的所有实例都将共享colors这个数组（引用类型值）。因此只要SubType其中一个实例对colors做了修改，就会影响到其他所有SubType的实例。 缺陷二：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 针对问题二中的第一句话，“在创建子类型的实例时，不能向超类型的构造函数中传递参数”，我举个例子：12345678910111213141516function SuperType(name) &#123; // 超类型 this.name = name;&#125;function SubType(age) &#123; //子类型 this.age = age;&#125;SubType.prototype = new SuperType(&quot;Allan&quot;);var instance1 = new SubType(10);console.log(instance1.name); // Allanconsole.log(instance1.age); // 10var instance2 = new SubType(20);console.log(instance2.name); // 10 上面代码中构造函数SuperType完全等价于下面声明的形式。 123function SuperType() &#123; name = &quot;Allan&quot;;&#125; instance1通过原型链继承的name属性值，在instance1创建之前就已经被确定为Allan了。无论怎么new SuperType()都更改不了name属性值，这就是所谓的“在创建子类型的实例时，不能向超类型的构造函数中传递参数”。 针对问题二中的第二句话，“实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数”,这句话应该怎么理解？ 其实在上面的代码中，我在创建SuperType实例的时候，向它传递了一个”Allan”的字符串参数。但是我们看到后面所有的SubType的实例，无论是instance1还是instance2的name属性都是Allan，也就是说SuperType创建实例时传递的参数，影响了后面所有SubType的实例。这就是所谓“没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数”。 js通过沿着作用域链还是原型链查找变量?首先，要分清作用域链与原型链的区别，简单来说 作用域链是相对于函数的，原型链是相对于对象的 js中访问变量有多种方式 直接通过标识符访问 通过 . 或 [] 访问对象中的标识符 猜想访问方式不同，导致了查找的方式不同： 直接通过标识符访问，访问的可能是函数中的标识符，也可能是全局对象（浏览器中是 window）的标识符，也就是说，可能沿着作用域链也可能沿着原型链访问 通过 . 或 [] 访问对象中的标识符，js会沿着原型链查找 对于第二点，以下的小测试可以证明123456789101112131415Object.prototype.a = 1;a = 2var o = &#123; a: 3&#125;function test() &#123; console.log(this.a)&#125;test(); // 2 (1)test.call(o); // 3 (2)delete o.a;test.call(o); // 1 (3)delete a;test(); // 1 (4) ① 相当于调用 window.test（），this 指向 window，访问的是 window.a； ② 中 this 指向 o，访问的是 o.a； 将全局的 a， 也就是 window.a 和 o.a 删除之后，得到的结果均是 1。 因此，通过 . 或 [] 访问对象中的标识符，js会沿着原型链查找。 第一点，直接通过标识符访问，也就是访问当前执行上下文EC的作用域中的变量，这一过程称为标识符解析，依赖于作用域链。作用域链Scope其实就是对执行上下文EC中的变量对象VO|AO有序访问的链表 关于作用域链与执行上下文 EC 的关系，请看这里 测试1234567891011121314151617181920Object.prototype.a = 1;Window.prototype.a = 4a = 2var o = &#123; a: 3&#125;function test() &#123; console.log(a)&#125;test(); // 2 (1)test.call(o); // 2 (2)delete a;test() // 4 (3)test.call(o); // 4 (4)delete Window.prototype.atest() //1 (6)test.call(o) //1 (6) 把 this.a 改为 a，②的结果就变啦。 ① 和 ② 的执行上下文EC（即 this 的指向）分别为 window 和 o，但作用域链都是 test变量对象 + 全局变量对象。而test变量对象中没有 a，全局变量对象含有 a 。这就说明，在函数中直接通过标识符变量，js会沿着作用域中查找。 有趣的是，当删除了全局变量对象中的 a，再访问 a，浏览器并没有报错，而是输出 4；删除 Window.prototype.a 之后，输出的这是 1.在 test 中添加一下代码 ：12console.log(a === Window.prototype.a)console.log(a === Object.prototype.a) 由结果可知，访问到的a 分别为 Window.prototype 和 Object.prototype 中的变量。 为什么呢？因为在浏览器中，全局变量对象在浏览器中指向 window， window 也是对象，且位于作用域链的末尾；作用域链查找完，仍然找不到，js 就会沿着全局变量对象的原型链查找。 结论 直接通过标识符访问变量，首先沿着作用域链查找每一个变量对象，直到全局变量对象（window）仍没有，就沿着全局变量对象（window）的原型链查找 通过 . 或 [] 访问对象中的标识符，就直接沿着原型链查找","categories":[{"name":"2.1原型与原型链(继承)","slug":"2-1原型与原型链-继承","permalink":"https://93qlin.github.io/categories/2-1原型与原型链-继承/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"}]},{"title":"小程序","slug":"小程序","date":"2019-04-03T13:28:04.214Z","updated":"2019-04-03T13:31:39.841Z","comments":true,"path":"2019/04/03/小程序/","link":"","permalink":"https://93qlin.github.io/2019/04/03/小程序/","excerpt":"","text":"目录 &emsp;1. 简单描述下微信小程序的相关文件类型 &emsp;2. 简述微信小程序原理 &emsp;3. 小程序的双向绑定和vue哪里不一样 &emsp;4. 小程序的wxss和css有哪些不一样的地方 &emsp;5. 小程序页面间有哪些传递数据的方法 &emsp;6. 小程序的生命周期函数 &emsp;7. 怎么封装微信小程序的数据请求 &emsp;8. 哪些方法可以用来提高微信小程序的应用速度 &emsp;9. 微信小程序的优劣势 &emsp;10. 怎么解决小程序的异步请求问题 &emsp;11. 小程序关联微信公众号如何确定用户的唯一性 &emsp;12. 如何实现下拉刷新 &emsp;13. bindtap和catchtap的区别是什么 &emsp;14. 简述下wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别 1. 简单描述下微信小程序的相关文件类型 微信小程序项目结构主要有四个文件类型 WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件 WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式 js 逻辑处理，网络请求 json 小程序设置，如页面注册，页面标题及tabBar 主要文件 app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 window 背景色，配置导航条样式，配置默认标题 app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量 app.wxss 可选 2. 简述微信小程序原理 微信小程序采用 JavaScript、WXML、WXSS 三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口 微信的架构，是数据驱动的架构模式，它的 UI 和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现 小程序分为两个部分 webview 和 appService 。其中 webview 主要用来展现 UI，appService 有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理 3. 小程序的双向绑定和vue哪里不一样 小程序直接 this.data 的属性是不可以同步到视图的，必须调用： 123this.setData(&#123; // 这里设置&#125;) 4. 小程序的wxss和css有哪些不一样的地方 WXSS 和 CSS 类似，不过在 CSS 的基础上做了一些补充和修改 尺寸单位 rpx rpx 是响应式像素,可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素 使用 @import 标识符来导入外联样式。@import 后跟需要导入的外联样式表的相对路径，用;表示语句结束 123456/** index.wxss **/@import './base.wxss';.container&#123; color: red;&#125; 5. 小程序页面间有哪些传递数据的方法 使用全局变量实现数据传递在 app.js 文件中定义全局变量 globalData， 将需要存储的信息存放在里面 12345678// app.jsApp(&#123; // 全局变量 globalData: &#123; userInfo: null &#125;&#125;) 使用的时候，直接使用 getApp() 拿到存储的信息 使用 wx.navigateTo 与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面 onLoad 的时候初始化 1234567891011121314151617181920212223//pageA.js// Navigatewx.navigateTo(&#123; url: '../pageD/pageD?name=raymond&amp;gender=male',&#125;)// Redirectwx.redirectTo(&#123; url: '../pageD/pageD?name=raymond&amp;gender=male',&#125;)// pageB.js...Page(&#123; onLoad: function(option)&#123; console.log(option.name + 'is' + option.gender) this.setData(&#123; option: option &#125;) &#125;&#125;) 需要注意的问题： wx.navigateTo 和 wx.redirectTo 不允许跳转到 tab 所包含的页面 onLoad 只执行一次 使用本地缓存 Storage 相关 6. 小程序的生命周期函数 onLoad 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数 onShow() 页面显示/切入前台时触发 onReady() 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互 onHide() 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等 onUnload() 页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时 详见 生命周期回调函数 7. 怎么封装微信小程序的数据请求 参考 这里 8. 哪些方法可以用来提高微信小程序的应用速度 1、提高页面加载速度 2、用户行为预测 3、减少默认 data 的大小 4、组件化方案 9. 微信小程序的优劣势 优势 即用即走，不用安装，省流量，省安装时间，不占用桌面 依托微信流量，天生推广传播优势 开发成本比 App 低 缺点 用户留存，即用即走是优势，也存在一些问题 入口相对传统 App 要深很多 限制较多,页面大小不能超过1M。不能打开超过5个层级的页面 10. 怎么解决小程序的异步请求问题 小程序支持 ES6 语法 在返回成功的回调里面处理逻辑 Promise 异步 async/await 11. 小程序关联微信公众号如何确定用户的唯一性 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 unionid 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid 是相同的 12. 如何实现下拉刷新 首先在全局 config 中的 window 配置 enablePullDownRefresh 在 Page 中定义 onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法 请求返回后，调用 wx.stopPullDownRefresh 停止下拉刷新 参考 这里 13. bindtap和catchtap的区别是什么 相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分 不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的 14. 简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别 wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面 wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面 wx.switchTab()：跳转到 abBar 页面，并关闭其他所有非 tabBar 页面 wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层 wx.reLaunch()：关闭所有页面，打开到应用内的某个页面","categories":[{"name":"小程序总结","slug":"小程序总结","permalink":"https://93qlin.github.io/categories/小程序总结/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://93qlin.github.io/tags/小程序/"}]},{"title":"面试","slug":"vue面试题","date":"2019-04-02T13:08:50.063Z","updated":"2019-04-09T13:56:25.059Z","comments":true,"path":"2019/04/02/vue面试题/","link":"","permalink":"https://93qlin.github.io/2019/04/02/vue面试题/","excerpt":"","text":"目录 &emsp;1. 说一下Vue的双向绑定数据的原理 &emsp;2. 解释单向数据流和双向数据绑定 &emsp;3. Vue如何去除url中的 # &emsp;4. 对 MVC、MVVM的理解 &emsp;5. 介绍虚拟DOM &emsp;6. vue生命周期的理解 &emsp;7. 组件通信 &emsp;8. 路由实现 &emsp;9. v-if 和 v-show 区别 &emsp;10. $route和$router的区别 &emsp;11. NextTick 是做什么的 &emsp;12. Vue 组件 data 为什么必须是函数 &emsp;13. 计算属性computed 和事件 methods 有什么区别 &emsp;14. 对比 jQuery ，Vue 有什么优缺点 &emsp;15. Vue 中怎么自定义指令 &emsp;16. Vue 中怎么自定义过滤器 &emsp;17. 对 keep-alive 的了解 &emsp;18. Vue 中 key 的作用 &emsp;19. 你觉得 Vue 的核心是什么 &emsp;20. vue 等单页面应用的优缺点 &emsp;21. vue-router 使用params与query传参有什么区别 1. 说一下Vue的双向绑定数据的原理 vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调 2. 解释单向数据流和双向数据绑定 单向数据流： 顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使UI发生变更就必须创建各种 action 来维护对应的 state 双向数据绑定：数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度 3. Vue 如何去除url中的 # vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 url 会自带 #。如果不想使用 #， 可以使用 vue-router 的另一种模式 history 1234new Router(&#123; mode: 'history', routes: [ ]&#125;) 需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 404 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面 4. 对 MVC、MVVM的理解 MVC 特点： View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的 MVVM 特点： 各部分之间的通信，都是双向的 采用双向绑定：View 的变动，自动反映在 ViewModel，反之亦然 具体请移步 这里 5. 介绍虚拟DOM 参考这里 6. vue生命周期的理解 vue实例有一个完整的生命周期，生命周期也就是指一个实例从开始创建到销毁的这个过程 beforeCreated() 在实例创建之间执行，数据未加载状态 created() 在实例创建、数据加载后，能初始化数据，dom渲染之前执行 beforeMount() 虚拟dom已创建完成，在数据渲染前最后一次更改数据 mounted() 页面、数据渲染完成，真实dom挂载完成 beforeUpadate() 重新渲染之前触发 updated() 数据已经更改完成，dom 也重新 render 完成,更改数据会陷入死循环 beforeDestory() 和 destoryed() 前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行 7. 组件通信 父组件向子组件通信 子组件通过 props 属性，绑定父组件数据，实现双方通信 子组件向父组件通信 将父组件的事件在子组件中通过 $emit 触发 非父子组件、兄弟组件之间的数据传递 12345678910/*新建一个Vue实例作为中央事件总嫌*/let event = new Vue();/*监听事件*/event.$on('eventName', (val) =&gt; &#123; //......do something&#125;);/*触发事件*/event.$emit('eventName', 'this is a message.') Vuex 数据管理 8. vue-router 路由实现 路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能 参考 这里 9. v-if 和 v-show 区别 使用了 v-if 的时候，如果值为 false ，那么页面将不会有这个 html 标签生成。 v-show 则是不管值为 true 还是 false ，html 元素都会存在，只是 CSS 中的 display 显示或隐藏 10. $route和$router的区别 $router 为 VueRouter 实例，想要导航到不同 URL，则使用 $router.push 方法 $route 为当前 router 跳转对象里面可以获取 name 、 path 、 query 、 params 等 11. NextTick 是做什么的 $nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM 具体可参考官方文档 深入响应式原理 12. Vue 组件 data 为什么必须是函数 因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了 13. 计算属性computed 和事件 methods 有什么区别 我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 不同点： computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值 对于 method ，只要发生重新渲染，method 调用总会执行该函数 14. 对比 jQuery ，Vue 有什么不同 jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作 Vue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发 15. Vue 中怎么自定义指令 全局注册 12345678// 注册一个全局自定义指令 `v-focus`Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 局部注册 12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 参考 官方文档-自定义指令 16. Vue 中怎么自定义过滤器 可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值 123Vue.filter('reverse', function (value) &#123; return value.split('').reverse().join('')&#125;) 12&lt;!-- 'abc' =&gt; 'cba' --&gt;&lt;span v-text=\"message | reverse\"&gt;&lt;/span&gt; 过滤器也同样接受全局注册和局部注册 17. 对 keep-alive 的了解 keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染 12345&lt;keep-alive&gt; &lt;component&gt; &lt;!-- 该组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 可以使用API提供的props，实现组件的动态缓存 具体参考 官方API 18. Vue 中 key 的作用 key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误 具体参考 官方API 19. Vue 的核心是什么 数据驱动 组件系统 20. vue 等单页面应用的优缺点 优点： 良好的交互体验 良好的前后端工作分离模式 减轻服务器压力 缺点： SEO难度较高 前进、后退管理 初次加载耗时多 21. vue-router 使用params与query传参有什么区别 vue-router 可以通过 params 与 query 进行传参 12345678// 传递this.$router.push(&#123;path: './xxx', params: &#123;xx:xxx&#125;&#125;)this.$router.push(&#123;path: './xxx', query: &#123;xx:xxx&#125;&#125;)// 接收this.$route.paramsthis.$route.query params 是路由的一部分,必须要有。query 是拼接在 url 后面的参数，没有也没关系 params 不设置的时候，刷新页面或者返回参数会丢，query 则不会有这个问题","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://93qlin.github.io/categories/面试总结/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://93qlin.github.io/tags/vue/"}]},{"title":"偶尔练练css之小胡子","slug":"偶尔练练css之小胡子","date":"2019-03-30T12:12:54.502Z","updated":"2019-03-30T12:32:58.150Z","comments":true,"path":"2019/03/30/偶尔练练css之小胡子/","link":"","permalink":"https://93qlin.github.io/2019/03/30/偶尔练练css之小胡子/","excerpt":"","text":"css实现之小胡子 知识要点1.hsl(h,s,l):CSS3 颜色值HSL表示方式&amp;简单实例HSL色彩模式：就是色调(Hue)、饱和度(Saturation)、亮度(Lightness)三个颜色通道的改变以及它们相互之间的叠加来获得各种颜色，色调(Hue)色调最大值360，饱和度和亮度有百分比表示0-100%之间。2.js操作css变量（变量要用–开头）： 设置：1root.style.setProperty(&quot;--mouse-x&quot;, x); 使用：1var(--mouse-y,0.5) //0.5表示默认值 直接上代码（喜欢干货，不喜欢啰嗦，我也喜欢看别人的代码直接，然后看不懂的就去查资料，因为别人啰嗦一堆，很快失去兴趣很难集中精力） html1&lt;div class=&quot;mustache&quot;&gt; &lt;/div&gt; css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768.mustache&#123; width: 180px; height: 180px; left: 100px; border-radius: 50%; position: absolute; color: hsl(calc(360*var(--mouse-x)),100%, 75%); /* background-color: currentColor; */ box-shadow: 150px 240px 0 0 currentColor, 300px 240px 0 0 currentColor&#125;.mustache::before&#123; width: 210px; height: 120px; content: &apos;&apos;; position: absolute; left: 30px; /* 150+90-210 */ top: 120px; border-bottom: solid 180px currentColor; /* background-color: red; */ border-radius: 0 0 0 100%; /* transform: rotate(-40deg); */ transform: rotate(calc(-20deg - var(--mouse-y,0.5)*40deg)); transform-origin: right 210px; /* 300-90 */&#125;.mustache::after&#123; width: 210px; height: 120px; content: &apos;&apos;; position: absolute; left: 390px; top: 120px; border-bottom: solid 180px currentColor; /* background-color: red; */ border-radius: 0 0 100% 0; /* transform: rotate(40deg); */ transform: rotate(calc(20deg + var(--mouse-y,0.5)*40deg)); transform-origin: left 210px /* 300-90 */&#125;/* .mustache:before&#123; animation: shakeLeft 1s ease-in-out infinite;&#125;.mustache:after&#123; animation: shakeRight 1s ease-in-out infinite;&#125;@keyframes shakeLeft&#123; 0%&#123; transform: rotate(-50deg); &#125; 50%&#123; transform: rotate(-30deg); &#125; 100%&#123; transform: rotate(-50deg); &#125;&#125;@keyframes shakeRight&#123; 0%&#123; transform: rotate(50deg); &#125; 50%&#123; transform: rotate(30deg); &#125; 100%&#123; transform: rotate(50deg); &#125;&#125; */ js1234567var root = document.getElementsByTagName(&apos;body&apos;)[0]document.addEventListener(&apos;mousemove&apos;, evt =&gt; &#123; let x= evt.clientX / innerWidth; let y = evt.clientY / innerHeight; root.style.setProperty(&quot;--mouse-x&quot;, x); root.style.setProperty(&quot;--mouse-y&quot;, y);&#125;) 最终实现效果（鼠标上下移动胡须上下摆动，鼠标左右移动，颜色随之改变）图略","categories":[{"name":"css","slug":"css","permalink":"https://93qlin.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://93qlin.github.io/tags/css/"}]},{"title":"webpack4","slug":"webpack4","date":"2019-03-12T11:24:16.643Z","updated":"2019-04-08T13:50:36.899Z","comments":true,"path":"2019/03/12/webpack4/","link":"","permalink":"https://93qlin.github.io/2019/03/12/webpack4/","excerpt":"","text":"plugin: 扩张webpack功能的 loader: 转换文件（js, css, 图片） model: 模式配置 可设置的值为mode：none，development或production（默认值） 用法 只需mode在配置中提供选项：123module.exports = &#123; mode: &apos;production&apos;&#125;; 或者将其作为CLI参数传递：1webpack --mode=productio 命令来指定打包文件到指定文件夹1webpack --mode=development ./src/hello.js --output ./build/main.js 命令很麻烦，所以需要配置文件package.json1npm init -y(-y的意思是不需要回车) Getting Start1.现在项目中装两个插件1npm install webpack webpack-cli --save-dev 全局安装webapck的问题123The following NPM installation will make webpack available globally:npm install --global webpackNote that this is not a recommended practice. Installing globally locks you down to a specific version of webpack and could fail in projects that use a different version. 全局安装webpack会锁定webpack版本，当我们运行不同版本的webpack项目时会有问题两种方法 1.自定义命令 devnow123&quot;scripts&quot;: &#123; &quot;devnow&quot;: &quot;./node_modules/webpack/bin/webpack.js --mode=development&quot;, &#125; 2.安装npx解决这个问题 只要是可执行文件前面都可以加npx,他首先会在当前项目里找不到就去全局找 1npm install -g npx 123&quot;scripts&quot;: &#123; &quot;devnpx&quot;: &quot;npx webpack --mode=development&quot; &#125;, webpack默认的配制文件（webpack-config.js）（全部自定义命令配置的话很长，不好看），1.直接建个 webpack-config.js,因为webpack会默认去找这个文件。12345678moduls.exports = &#123; mode: &quot;development&quot;, entry: &quot;./src/index.js&quot;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), // __dirname: node.js里__dirname 总是指向被执行 js 文件的绝对路径所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。 filename: &quot;app.bundle.js&quot; &#125;&#125; 然后自定义的命令就可以删了（删了devnpx命令里的–mode=development）12345&quot;scripts&quot;: &#123; &quot;devnpx&quot;: &quot;npx webpack&quot;, &quot;dev&quot;: &quot;webpack --mode=development&quot;, &quot;build&quot;: &quot;webpack --mode=production&quot; &#125;, 配置多入口文件编译多个js文件123456789101112const path = require(&apos;path&apos;)module.exports = &#123; mode: &quot;development&quot;, entry:&#123; app: &quot;./src/index.js&quot;, hello: &apos;./src/hello.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), // __dirname: node.js里__dirname 总是指向被执行 js 文件的绝对路径所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。 filename: &quot;[name].bundle.js&quot; // name是入口文件的名字作为key &#125;&#125; babel(js转换插件为了解决低版本的浏览器不支持新的js语法)12npm install --save-dev @babel/core // babel核心插件npm install -D babel-loader // webpack和babel结合插件 babel插件（plugin）12345678910arrow-functionsblock-scoped-functionsblock-scopingclassescomputed-propertiesdestructuringduplicate-keysfor-offunction-nameinstanceof babel插件两种使用方法1234567.babelrc（项目根目录新建此文件，然后复制进去）Without options:&#123; &quot;plugins&quot;: [&quot;@babel/plugin-transform-arrow-functions&quot;]&#125; 12345678910111213141516171819202122With options: （在webpack配置文件里加）&lt;!-- &#123; &quot;plugins&quot;: [ [&quot;@babel/plugin-transform-arrow-functions&quot;, &#123; &quot;spec&quot;: true &#125;] ]&#125; --&gt;module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; plugins: [&apos;@babel/plugin-proposal-object-rest-spread&apos;] &#125; &#125; &#125; ]&#125; @babel/preset-env babel (preset)预设 作用： 解决每写一个js新语法都装一个插件比如箭头函数，class,bable-env// 不包含装饰器插件，所以es6装饰器可能要加装1234567891011121314module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-env&apos;,&#123;debug: true&#125;], //预设,包含某些es6常用插件,debug可以看到预设了那些插件 &#125; &#125; &#125; ]&#125; @babel/polifillbable能转换一些语法，但是一些新的api不能处理（Promise，，，）原理： 往windows全局对象导入一些内容// 安装略{ “presets”: [[“@babel/preset-env”,{“debug”: true, “useBuiltIns”: “usage”,”corejs”: “3.0.0”}]], “plugins”: [ [“@babel/plugin-proposal-decorators”, { “legacy”: true }], ]}注意 1.”useBuiltIns”: “usage” //按需编译123456[/Users/qinlin/Desktop/webpack/hello-webpack-4/src/index.js] Added following core-js polyfills: es.array.from &#123;&#125; es.object.assign &#123;&#125; es.object.to-string &#123;&#125; es.promise &#123;&#125; es.string.iterator &#123;&#125; “corejs”: “3.0.0”它依赖corejs需指定版本不然会报错 @babel/runtime 解决polifill全局污染的问题123polifill:ar process = global.process;var Promise = global.Promise; 所以不太好 用法：npm install –save @babel/runtimenpm install –save-dev @babel/plugin-transform-runtimenpm install –save @babel/runtime-corejs2@babel/plugin-transform-runtime的作用是避免重复的问题比如：1234567function _classCallCheck(instance, Constructor) &#123; //...&#125;var Circle = function Circle() &#123; _classCallCheck(this, Circle);&#125;; 变为12345var _classCallCheck = require(&quot;@babel/runtime/helpers/classCallCheck&quot;);var Circle = function Circle() &#123; _classCallCheck(this, Circle);&#125;; 配置一下123456789101112131415161718&#123; &quot;presets&quot;: [[&quot;@babel/preset-env&quot;,&#123;&quot;debug&quot;: true&#125;]], &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125; ], [ &quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;absoluteRuntime&quot;: false, &quot;corejs&quot;: 2, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125; ] ]&#125; 搭建react环境1.npm install react react-dom 预设npm install –save-dev @babel/preset-react plugin(插件作用扩展webpack功能)html-webpack-plugin（可以自动生成html,可以解决浏览器缓存问题，因为每次文件名都会更新）npm i –save-dev html-webpack-plugin 12345678const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; .... plugins: [ new HtmlWebpackPlugin() ]&#125; 可以加参数123456new HtmlWebpackPlugin(&#123; title: &apos;admin&apos;, filename: &apos;admin/index.html&apos;, // 放在dist/admin目录下 template: &apos;public/index.html&apos;, // 模板文件 chunks: [&quot;admin&quot;] // 指定chunk&#125;) 配资多个html1234567891011121314plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;admin&apos;, filename: &apos;admin/index.html&apos;, template: &apos;public/index.html&apos;, chunks: [&quot;admin&quot;] &#125;), new HtmlWebpackPlugin(&#123; title: &apos;index&apos;, filename: &apos;app/index.html&apos;, template: &apos;public/index.html&apos;, chunks: [&quot;app&quot;] &#125;)] css-loader1npm install sass-loader node-sass --save-dev less等略最终 webapck.config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const path = require(&apos;path&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = &#123; // mode: &quot;development&quot;, entry:&#123; // app: [&quot;@babel/polyfill&quot;,&quot;./src/index.js&quot;], app: &quot;./src/index.js&quot;, admin: &apos;./src/hello.js&apos; &#125;, devtool: false, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), // __dirname: node.js里__dirname 总是指向被执行 js 文件的绝对路径所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。 filename: &quot;[name]/[hash].bundle.js&quot;, // name是入口文件的名字作为key // chunkFilename: &quot;[name]-[hash].[id].bundle.js&quot;, // name是入口文件的名字作为key &#125;, module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, // options: &#123; // presets: [[&apos;@babel/preset-env&apos;,&#123;debug: true&#125;]], //预设,包含某些es6常用插件,debug可以看到预设了那些插件 // &#125; &#125; &#125;, &#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;], // 右边到左边执行css =&gt; style &#125;, &#123; test: /\\.(scss|sass)$/, use: [ &quot;style-loader&quot;, // creates style nodes from JS strings &quot;css-loader&quot;, // translates CSS into CommonJS &quot;sass-loader&quot; // compiles Sass to CSS, using Node Sass by default ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;admin&apos;, filename: &apos;admin/index.html&apos;, template: &apos;public/index.html&apos;, chunks: [&quot;admin&quot;] &#125;), new HtmlWebpackPlugin(&#123; title: &apos;index&apos;, filename: &apos;app/index.html&apos;, template: &apos;public/index.html&apos;, chunks: [&quot;app&quot;] &#125;) ]&#125; mini-css-extract-plugin把js释放css文件1npm install --save-dev mini-css-extract-plugin 12345678910111213141516171819202122232425262728webpack.config.jsconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const devMode = process.env.NODE_ENV !== &apos;production&apos;module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: devMode ? &apos;[name].css&apos; : &apos;[name].[hash].css&apos;, chunkFilename: devMode ? &apos;[id].css&apos; : &apos;[id].[hash].css&apos;, &#125;) ], module: &#123; rules: [ &#123; test: /\\.(sa|sc|c)ss$/, use: [ devMode ? &apos;style-loader&apos; : MiniCssExtractPlugin.loader, &apos;css-loader&apos;, &apos;postcss-loader&apos;, &apos;sass-loader&apos;, ], &#125; ] &#125;&#125; webpack-dev-server(开启一个本地服务器，热加载，自动打开浏览器)1npm install webpack-dev-server --save-dev 1&quot;devnpx&quot;: &quot;npx webpack-dev-server --open&quot;, clean-webpack-plugin(清空之前生成的hash文件)1npm install --save-dev clean-webpack-plugin 1npm install -g serve 123let pathToClean = [&apos;dist&apos;]....new CleanWebpackPlugin(&#123;pathToClean:pathToClean&#125;) 执行命令1serve -s dist 处理图片1npm install file-loader --save-dev 压缩图片1npm install image-webpack-loader --save-dev 查看文件体积命令ls -lh src 最终webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091const path = require(&apos;path&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const devMode = process.env.NODE_ENV !== &apos;production&apos;const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);let pathToClean = [&apos;dist&apos;]module.exports = &#123; // mode: &quot;development&quot;, entry:&#123; // app: [&quot;@babel/polyfill&quot;,&quot;./src/index.js&quot;], app: &quot;./src/index.js&quot;, admin: &apos;./src/hello.js&apos; &#125;, devtool: false, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), // __dirname: node.js里__dirname 总是指向被执行 js 文件的绝对路径所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。 // filename: &quot;[name]/[hash].bundle.js&quot;, // name是入口文件的名字作为key filename: &quot;js/[name]-[hash].bundle.js&quot;, // name是入口文件的名字作为key &#125;, module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, // options: &#123; // presets: [[&apos;@babel/preset-env&apos;,&#123;debug: true&#125;]], //预设,包含某些es6常用插件,debug可以看到预设了那些插件 // &#125; &#125; &#125;, &#123; test: /\\.css$/, use: [ devMode ? &apos;style-loader&apos; : MiniCssExtractPlugin.loader, &apos;css-loader&apos; ], // 右边到左边执行css =&gt; style &#125;, &#123; test: /\\.(scss|sass)$/, use: [ devMode ? &apos;style-loader&apos; : MiniCssExtractPlugin.loader, // creates style nodes from JS strings &quot;css-loader&quot;, // translates CSS into CommonJS &quot;sass-loader&quot; // compiles Sass to CSS, using Node Sass by default ] &#125;, &#123; test: /\\.(png|jpe?g|gif)$/, use: [ &#123; loader: &apos;file-loader&apos;, options: &#123; name: &apos;[name].[ext]&apos;, outputPath: &apos;images/&apos;, &#125; &#125;, &#123; loader: &apos;image-webpack-loader&apos;, &#125; ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;admin&apos;, filename: &apos;admin.html&apos;, template: &apos;public/index.html&apos;, chunks: [&quot;admin&quot;] &#125;), new HtmlWebpackPlugin(&#123; title: &apos;index&apos;, filename: &apos;index.html&apos;, template: &apos;public/index.html&apos;, chunks: [&quot;app&quot;] &#125;), new HtmlWebpackPlugin(&#123; title: &apos;index&apos;, filename: &apos;index.html&apos;, template: &apos;public/index.html&apos;, chunks: [&quot;app&quot;] &#125;), new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: devMode ? &apos;css/[name].css&apos; : &apos;css/[name].[hash].css&apos;, chunkFilename: devMode ? &apos;css/[id].css&apos; : &apos;css/[id].[hash].css&apos;, &#125;), new CleanWebpackPlugin(&#123;pathToClean:pathToClean&#125;) ]&#125; .babelrc12345678910111213141516171819202122232425&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;,&#123;&quot;debug&quot;: true&#125; ], [ &quot;@babel/preset-react&quot; ] ], &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125; ], [ &quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;absoluteRuntime&quot;: false, &quot;corejs&quot;: 2, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125; ] ]&#125;","categories":[{"name":"webpack4","slug":"webpack4","permalink":"https://93qlin.github.io/categories/webpack4/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://93qlin.github.io/tags/webpack/"}]},{"title":"项目中第一次向数据库连续添加多条数据","slug":"项目中第一次向数据库连续添加多条数据","date":"2019-02-28T03:12:12.522Z","updated":"2019-02-28T03:12:12.522Z","comments":true,"path":"2019/02/28/项目中第一次向数据库连续添加多条数据/","link":"","permalink":"https://93qlin.github.io/2019/02/28/项目中第一次向数据库连续添加多条数据/","excerpt":"","text":"记录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152toPing() &#123; if (this.n &lt; 37) &#123; let jse = new JSEncrypt() let publicKey = &apos;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDGDTI8/oBklUDPNKGOrKFGdLQuJZien2kXi5e3HaMivY/I/Q6CZcO3m3rXjJAzhfPXnAEPbfg1Kw9Ndd1mKRqn/0EdtF4zsoBfJHsVzg3/eb+2OEdmDvqf5OXzOn1i9AANwz8iCgkabzwrUF/RnQ7zYWw+EwkBFi2d0FAttDGWjQIDAQAB&apos; jse.setPublicKey(publicKey) let param = &#123;&#125;; let formData = &#123; userName: this.pinData[this.n].consumer_name, userPhone: this.pinData[this.n].mobile, userAge: &apos;23-55岁&apos;, city: this.pinData[this.n].province_ctiy, cityCode: this.pinData[this.n].city + &apos;&apos;, userCreditCard: &apos;YES&apos;, houseLoan: &apos;YES&apos;, insurancePolicy: &apos;YES&apos;, providentFund: &apos;YES&apos;, encryptFlag: &quot;YES&quot;, outerSource: this.pinData[this.n].outer_source, source: &quot;******&quot;, outerid: &quot;*****&quot;, cid: this.pinData[this.n].outersource, &#125; param[&apos;encryptParam&apos;] = encodeURIComponent(jse.encrypt(formData[&apos;userName&apos;] + &apos;|&apos; + formData[&apos;userPhone&apos;])); for (var i in formData) &#123; if (i !== &apos;userName&apos; &amp;&amp; i !== &apos;userPhone&apos; &amp;&amp; formData[i] !== &apos;&apos; &amp;&amp; formData[i] !== null) &#123; param[i] = formData[i]; &#125; &#125; $.ajax(&#123; // 前人用得jq的ajax，待优化，，，， url: &apos;*****&apos;, type: &apos;get&apos;, dataType: &apos;jsonp&apos;, data: param, &#125;) .done((data) =&gt; &#123; if (data.responseCode == &quot;000000&quot; || data.responseCode == &quot;900116&quot;) &#123; console.log(this.pinData[this.n].order_id + &apos;\\n&apos;) ++this.n setTimeout(() =&gt; &#123; this.toPing() &#125;, 200) // _this.$router.push(&apos;/card/success/&apos; + &apos;submit_pingan&apos;); &#125; else &#123; Toast(&quot;操作失败&quot;); &#125; &#125;) .fail(() =&gt; &#123; Toast(&quot;操作失败&quot;); &#125;); &#125; &#125;","categories":[{"name":"项目中第一次向数据库连续添加多条数据","slug":"项目中第一次向数据库连续添加多条数据","permalink":"https://93qlin.github.io/categories/项目中第一次向数据库连续添加多条数据/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://93qlin.github.io/tags/es6/"},{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"}]},{"title":"面试","slug":"面试","date":"2019-02-28T03:12:12.522Z","updated":"2019-04-03T13:30:38.528Z","comments":true,"path":"2019/02/28/面试/","link":"","permalink":"https://93qlin.github.io/2019/02/28/面试/","excerpt":"","text":"常见面试题1.CSS3选择器:nth-child和:nth-of-type之间的差异 p:nth-child(2)表示这个元素要是p标签，且是第二个子元素，是两个必须满足的条件而p:nth-of-type(2)表示父标签下的第二个p元素 JS获取URL中参数值（QueryString）123456789101112function getQueryString(name) &#123; var reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;, &apos;i&apos;); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; return null;&#125;// 这样调用：alert(GetQueryString(&quot;参数名1&quot;));alert(GetQueryString(&quot;参数名2&quot;));alert(GetQueryString(&quot;参数名3&quot;)); HTML5头部meta整理1.页面关键词&#39;&lt;&#39;meta name=&quot;keywords&quot; content=&quot;关键字，多个关键字用，隔开&quot; /&gt;2.页面描述&#39;&lt;&#39;meta name=&quot;description&quot; content=&quot;150个字符以内&quot; /&gt;3.搜索引擎索引方式&#39;&lt;&#39;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;以下是content里面可以有的索引值，多个索引方式用，隔开！！ all：文件将被检索，且页面上的链接可以被查询；none：文件将不被检索，且页面上的链接不可以被查询；index：文件将被检索；follow：页面上的链接可以被查询；noindex：文件将不被检索；nofollow：页面上的链接不可以被查询。 4.页面重定向和刷新&#39; &lt;&#39;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;注：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。5.其他 &lt;’meta name=”author” content=”author name” /&gt; &lt;’meta name=”google” content=”index,follow” /&gt;&lt;’meta name=”googlebot” content=”index,follow” /&gt;&lt;’meta name=”verify” content=”index,follow” /&gt; 6.移动设备viewport：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。 &lt;’meta name=”viewport” content=”width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no”/&gt;width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素）height：高度（数值 / device-height）（范围从223 到10,000）initial-scale：初始的缩放比例 （范围从&gt;0 到10）minimum-scale：允许用户缩放到的最小比例maximum-scale：允许用户缩放到的最大比例user-scalable：用户是否可以手动缩 (no,yes)minimal-ui：可以在页面加载时最小化上下状态栏。 7.WebApp全屏模式&lt;&#39;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;!-- 启用 WebApp 全屏模式 --&gt;隐藏状态栏/设置状态栏颜色：只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。 &lt;&#39;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;添加到主屏后的标题 &lt;&#39;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;忽略数字自动识别为电话号码 &lt;&#39;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt;忽略识别邮箱 &lt;&#39;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;添加智能 App 广告条 Smart App Banner：告诉浏览器这个网站对应的app，并在页面上显示下载banner &lt;&#39;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;其他 &lt;’!– 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 –&gt;&lt;&#39;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;’!– 微软的老式浏览器 –&gt;&lt;&#39;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;’!– uc强制竖屏 –&gt;&lt;&#39;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;’!– QQ强制竖屏 –&gt;&lt;&#39;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;’!– UC强制全屏 –&gt;&lt;&#39;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;’!– QQ强制全屏 –&gt;&lt;&#39;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;’!– UC应用模式 –&gt;&lt;&#39;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;’!– QQ应用模式 –&gt;&lt;&#39;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;’!– windows phone 点击无高光 –&gt;&lt;&#39;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; ##网页相关 申明编码&lt;&#39;meta charset=&#39;utf-8&#39; /&gt;优先使用 IE 最新版本和 Chrome &lt;’meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1” /&gt;&lt;’!– 关于X-UA-Compatible –&gt;&lt;’meta http-equiv=”X-UA-Compatible” content=”IE=6” &gt;&lt;’meta http-equiv=”X-UA-Compatible” content=”IE=7” &gt;&lt;’meta http-equiv=”X-UA-Compatible” content=”IE=8” &gt; 浏览器内核控制 &lt;’meta name=”renderer” content=”webkit|ie-comp|ie-stand”&gt;禁止浏览器从本地计算机的缓存中访问页面内容&lt;’meta http-equiv=”Pragma” content=”no-cache”&gt;Windows 8&lt;’meta name=”msapplication-TileColor” content=”#000”/&gt; &lt;’meta name=”msapplication-TileImage” content=”icon.png”/&gt; 站点适配 &lt;’meta name=”mobile-agent”content=”format=[wml|xhtml|html5]; url=url”&gt; 转码申明&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加此meta #数组去重用数组和对象做对比。1234567891011121314Array.prototype.unique3 = function()&#123; var res = []; var json = &#123;&#125;; for(var i = 0; i &lt; this.length; i++)&#123; if(!json[this[i]])&#123; res.push(this[i]); json[this[i]] = 1; console.log(json); &#125; &#125; return res;&#125;;var arr = [112,112,34,&apos;你好&apos;,112,112,34,&apos;你好&apos;,&apos;str&apos;,&apos;str1&apos;];console.log(arr.unique3()); 建立一个空数组和空对象，循环这个数组，到对象中匹配数组中的元素，如果不存在，则在空数组中添加这个元素，在空对象中添加这个key并随便给个值。 函数链式调用以下回答假设您已经了解闭包的的相关知识 可以解析为add(2)返回函数AA(3)返回函数BB(4)返回函数C那么初步的做法是add函数执行后返回一个函数对象，这个函数对象执行后再返回一个新函数，这样一直执行下去1234567891011function add(num)&#123; var sum=0; sum= sum+num; return function(numB)&#123; sum= sum+ numB; return function(numC)&#123; sum= sum+ numC; return sum; &#125; &#125;&#125; 代码这样实现后，执行输出9var result=add(2)(3)(4); 输出的result为9,符合题目的要求然后再考虑他的拓展性上面的代码符合我只调用3次函数的情况，如果要求计算var result=add(2)(3)(4)(5);上面的实现代码就歇菜了~~~子所以出现问题是上面的实现最后返回一个变量值，而不是一个函数对象。好吧，那么我们按前面的写法，继续返回函数，1234567891011121314function add(num)&#123; var sum=0; sum= sum+num; return function(numB)&#123; sum= sum+ numB; return function(numC)&#123; sum= sum+ numC; return function(numD)&#123; sum= sum+ numD; return function.... &#125;; &#125; &#125;&#125; 接下来的问题是如果要调用的次数是未知的（实际上也是未知的），继续按上面代码的写法，是一个不可能完成的任务但是我们可以发现返回的每一个函数执行的逻辑都是一样的，就此我们可以精简下代码,让函数返回后返回自身，哈哈这就是链式调用的写法，嗯嗯add(2)(3)(4)就是一个链式调用12345678function add(num)&#123; var sum=0; sum= sum+num; return function tempFun(numB)&#123; sum= sum+ numB; return tempFun; &#125;&#125; 但是12var result=add(2)(3)(4)(5);console.log(result); 并没有输出我们预料的结果14而是一个函数的字符串表示，想想也不奇怪，你每次函数调用后返回的一个函数对象，那么console.log输出就是一个函数对象的字符串表示了。那么怎么能把结果输出呢？2种方法第1种方法,在函数中添加判断，当没有输入参数时，直接返回调用的结果而不是返回函数 调用时和前面的有点区别12var result=add(2)(3)(4)(5)();console.log(result);//输出14 第2中方法利用JS中对象到原始值的转换规则当一个对象转换成原始值时，先查看对象是否有valueOf方法，如果有并且返回值是一个原始值，那么直接返回这个值，否则没有valueOf或返回的不是原始值，那么调用toString方法，返回字符串表示我们就为函数对象添加一个valueOf方法和toString方法12345678910111213141516171819202122232425function add(num)&#123; var sum=0; sum= sum+num; var tempFun=function(numB)&#123; if(arguments.length===0)&#123; return sum; &#125;else&#123; sum= sum+ numB;r return tempFun; &#125; &#125; tempFun.valueOf=function()&#123; return sum; &#125; tempFun.toString=function()&#123; return sum+&apos;&apos;; &#125; return tempFun;&#125;var result=add(2)(3)(4)(5);console.log(+result);//输出14 valueOfconsole.log(result);//输出14 toString 个人认为这样的写法很不好~函数调用语义不清晰PS:还可以这样实现12345678910111213141516171819202122232425var add=(function()&#123; var args=[]; function addInner()&#123; if(arguments.length===0)&#123; return calResult; &#125;else&#123; Array.prototype.push.apply(args,Array.prototype.splice.call(arguments,0)); return add; &#125; &#125; function calResult()&#123; var result=args.reduce(function(previousValue, currentValue)&#123; return previousValue+currentValue; &#125;,0); args=[]; return result; &#125; addInner.valueOf=function()&#123; return calResult(); &#125;; addInner.toString=function()&#123; return calResult()+&apos;&apos;; &#125;; typeof 返回七种可能的值：“number”、“string”、“boolean”、“object”、”symbol”、“function”和“undefined”。基础类型包括：Number、String、Boolean、Null、Undefined、Symbol（该类型位 ES2015 中新增类型）","categories":[{"name":"面试总结","slug":"面试总结","permalink":"https://93qlin.github.io/categories/面试总结/"}],"tags":[{"name":"体会","slug":"体会","permalink":"https://93qlin.github.io/tags/体会/"},{"name":"生活","slug":"生活","permalink":"https://93qlin.github.io/tags/生活/"}]},{"title":"设计模式","slug":"设计模式","date":"2019-02-28T03:12:12.521Z","updated":"2019-02-28T03:12:12.522Z","comments":true,"path":"2019/02/28/设计模式/","link":"","permalink":"https://93qlin.github.io/2019/02/28/设计模式/","excerpt":"","text":"基础知识什么是设计模式？ 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。通俗理解:==给好的设计取个名字。== 设计模式的作用？ 当某个类似的场景出现的时候，很快的找到某种模式作为解决方案。 javaScript和其他静态类型的语言有差异，不应照搬设计模式。 多态什么是多态 同一操作作用于不同对象的上面，可以产生不同的解释和不同的执行效果。通俗理解：主人说发出叫的命令，不同动物发出不同的叫声。代码理解多态：123456789101112131415var makeSound=function(animal) &#123; animal.sound()&#125;var Duck = function()&#123;&#125;Dunk.prototype.sound = function() &#123; console.log(&apos;嘎嘎嘎&apos;)&#125;var Dog = function()&#123;&#125;Dog.prototype.sound = function() &#123; console.log(&apos;汪汪汪&apos;)&#125;mackSound(new Duck)mackSound(new Dog)还有其他动物就简单追加一些代码就可以了。 多态思想是把”做什么”和”谁去做”分开，那如何分开？消除类型之间的耦合关系。如果makeSound指定了发出叫声的对向是某个类型，那就不能被替换另一类型所以:==静态类型语言的多态==：涉及到类型检查，所以像（java）通过向上转型，通过继承来实现多态。==javaScript的多态==：由于变量类型在运行期间是可变的，不存在类型耦合，所以它的多态是与生俱来的。 javaScript函数也是对象，函数用来封装行为并到处传递，当对函数发出“调用”的消息时，这些函数会返回不同的执行效果。这是多态的一种体现。这也是很多设计模式在JavaScript中使用高阶函数来实现的原因。 封装 封装的目的是将信息影藏。广义上包括封装数据和封装实现，封装类型和封装变化。 封装数据 许多语言封装数据是通过语法解析来实现的，用（private,public,protect）等关键字来提供不同的访问权限。JavaScript没有这些关键字的支持，只能通过==变量的作用域==来实现封装特性而且只能模拟public和private两种封装性12345678910var myObject = (function() &#123; var _name = &quot;haha&quot; //私有变量（&apos;private&apos;） return &#123; getName: function()&#123; // 公开方法（&apos;public&apos;） return _name &#125; &#125;&#125;)();console.log(myObject._name) // 输出：hahaconsole.log(myObject.getName()) // 输出undefined 封装实现封装使得对象之间的耦合变松散，对象之间只通过暴露api接口来通信。 封装类型 它是静态类型语言的一种重要的封装方式。一般通过抽象类和接口来进行的。JavaScript是类型模糊的语言没有抽象类和接口的支持，所以在封装类型方面没有能力也没必要做的更多。 封装变化找到系统稳定不变的部分和容易变化的部分隔离开，系统演变的过程中只需要替换容易变化的部分。 原型模式和基于原型模式的JavaScript对象系统。第一个设计模式————原型模式使用克隆的原型模式 es5提供了Object.created()来克隆对象。123456789var Plane = function() &#123; this.aa = 11&#125;var plane = new Plane()plane.aa = 22var clonePlane = Object.create(plane)console.log(clonePlane.aa) // 22plane.aa = 33console.log(clonePlane.aa) // 33 克隆是创建对象的手段在javaScript创建对象非常容易，不存在类型耦合，所以原型模式的意义并不大，但是他的对象系统就是使用原型模式来搭建的。 原型编程泛型 object是animal的原型，而animal是Dog原型，他们之间形成了一个原型链，这个原型链很有用处当调用Dog对象的某个方法时，它本身没有，Dog对象会把这个请求委托給它的原型animal对象这样顺着原型链一直委托下去，便得到继承的效果。==这样基于原型链的委托机制就是原型继承的本质==。 JavaScript中的原型继承==原型编程的基本规则：== 所有数据都是对象 要得到一个对象不是通过实例化类，而是找到一个对象并克隆它 对象会记住它的原型 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型 1，所有数据都是对象javascrit模仿java有两套类型机制：基本类型和对象类型。javaScript并不是所有数据都是对象，按设计者本意除undefined外一切都应是对象，为了实现这个number，boolean,string这几种基本类型也可以通过“包装类”的方式变成对象类型的数据处理。 javaSript中的根对象是object.prototype对象（一个空对象）。javascripty中遇到的每个对象都是从Object.prototype对象克隆而来的。Object.prototype对象就是他们的原型，比如：12345var obj1 = new Object();var obj2 = &#123;&#125;;查看这两个对象的原型(es5的Object.getPrototypeOf)console.log(Object.getPrototypeOf(obj1)===Object.prototype) //trueconsole.log(Object.getPrototypeOf(obj2)===Object.prototype) //true 2.要得到一个对象不是通过实例化类，而是找到一个对象并克隆它JavaScript引擎内部负责实现克隆，调用var obj1 = new Object()和var obj2 = {};时内部会从Object.prototype上克隆一个对象；一段熟悉的代码：12345678910funtion Person(name)&#123; this.name = name&#125;Person.prototype.getName = function()&#123; return this.name&#125;var a = new Person(&apos;seven&apos;)console.log(a.name) //sevenconsole.log(a.getName())console.log(Object.getPrototypeOf(a)===Person.prototype) ==javascript没有类的概念==这里的Person不是类而是函数构造器，因为js的函数既可以作为普通函数调用也可以作为构造器被调用，用new运算符调用时就是一个构造器，创建对象的过程就是先克隆Object.prototype对象，再进行一些其他额外的操作的过程（实际上并不是真的克隆了一个新对象《内存方面出发还做了其他处理，参考js精髓和编程实战）","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://93qlin.github.io/categories/设计模式/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://93qlin.github.io/tags/设计模式/"}]},{"title":"指数化退避","slug":"指数化退避","date":"2019-02-28T03:12:12.521Z","updated":"2019-02-28T03:12:12.521Z","comments":true,"path":"2019/02/28/指数化退避/","link":"","permalink":"https://93qlin.github.io/2019/02/28/指数化退避/","excerpt":"","text":"指数化退避是一种失败后重试 API 的技巧，它会在每次连续的失败之后让重试时间逐渐变长，超过最大重试次数之后就会彻底放弃。 如果使用承诺和其它跟踪 AJAX 调用的方法会非常复杂，而使用可观察对象，这非常简单：1234567891011121314151617181920212223import &#123; pipe, range, timer, zip &#125; from &apos;rxjs&apos;;import &#123; ajax &#125; from &apos;rxjs/ajax&apos;;import &#123; retryWhen, map, mergeMap &#125; from &apos;rxjs/operators&apos;;function backoff(maxTries, ms) &#123; return pipe( retryWhen(attempts =&gt; range(1, maxTries) .pipe( zip(attempts, (i) =&gt; i), map(i =&gt; i * i), mergeMap(i =&gt; timer(i * ms)) ) ) );&#125;ajax(&apos;/api/endpoint&apos;) .pipe(backoff(3, 250)) .subscribe(data =&gt; handleData(data));function handleData(data) &#123; // ...&#125;","categories":[{"name":"指数化退避","slug":"指数化退避","permalink":"https://93qlin.github.io/categories/指数化退避/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"},{"name":"技巧","slug":"技巧","permalink":"https://93qlin.github.io/tags/技巧/"}]},{"title":"2018面试题","slug":"百度阿里网易大疆等大小厂前端面试题","date":"2019-02-28T03:12:12.521Z","updated":"2019-02-28T03:12:12.521Z","comments":true,"path":"2019/02/28/百度阿里网易大疆等大小厂前端面试题/","link":"","permalink":"https://93qlin.github.io/2019/02/28/百度阿里网易大疆等大小厂前端面试题/","excerpt":"","text":"怎么从十万个节点中找到想要的节点，怎么快速在某个节点前插入一个节点？ 负载均衡方式和容错机制 描述一个文件从硬盘读取到进程内存中的过程 TCP三次握手和挥手的过程，除了这些书本上的还有哪些? 画一下OSI七层模型 写一个你最熟悉的算法 有哪些伪类和伪元素 IE盒模型和标准盒模型，用哪个属性改变 怎么清除浮动，原理是什么 em,rem,px的区别 大疆大疆是我校招面的第一家公司，从六月份投简历，然后笔试面试到拿到录用意向书，前后用了近四个月，来之不易啊。 一面二面因为时间太久，就直接放在一起了，问的都是基础吧，讲真，大疆前端面试不难，都是很基础的，就是时间长，等的捉急。一面是电话面，两个面试官轮流问；二面是视频面，是三个面试官一起微信视频，视频面还是蛮累的，上下左右都得顾上；终面是去的现场面，就跟一个面试官聊了十几分钟人生。 meta标签 meta标签：提供给页面的一些元信息（名称/值对）， 比如针对搜索引擎和更新频度的描述和关键词。 name：名称/值对中的名称。常用的有author、description、keywords、generator、revised、others。 把 content 属性关联到一个名称。http-equiv：没有name时，会采用这个属性的值。常用的有content-type、expires、refresh、set-cookie。把content属性关联到http头部。content： 名称/值对中的值， 可以是任何有效的字符串。 始终要和 name 属性或 http-equiv 属性一起使用。scheme： 用于指定要用来翻译属性值的方案。 css哪些属性可以继承 字体相关：line-height, font-family, font-size, font-style, font-variant, font-weight, font文本相关： letter-spacing, text-align, text-indent, text-transform, word-spacing列表相关：list-style-image, list-style-position, list-style-type, list-style颜色：color css3有哪些新属性 （1）边框： border-radius：圆角边框，border-radius:25px;box-shadow：边框阴影，box-shadow: 10px 10px 5px #888888;border-image：边框图片，border-image:url(border.png) 30 30 round;（2）背景： background-size：规定背景图片的尺寸，background-size:63px 100px;background-origin：规定背景图片的定位区域，背景图片可以放置于 content-box、padding-box 或 border-box 区域。background-origin:content-box;CSS3 允许您为元素使用多个背景图像。background-image:url(bg_flower.gif),url(bg_flower_2.gif);（3）文本效果： text-shadow：向文本应用阴影，可以规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。text-shadow: 5px 5px 5px #FF0000;word-wrap：允许文本进行换行。word-wrap:break-word;（4）字体：CSS3 @font-face 规则可以自定义字体。 （5）2D 转换（transform） translate()：元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数。 transform: translate(50px,100px);rotate()：元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。transform: rotate(30deg);scale()：元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数。transform: scale(2,4);skew()：元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数。transform: skew(30deg,20deg);matrix()： 把所有 2D 转换方法组合在一起，需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。transform:matrix(0.866,0.5,-0.5,0.866,0,0);（6）3D 转换 rotateX()：元素围绕其 X 轴以给定的度数进行旋转。transform: rotateX(120deg);rotateY()：元素围绕其 Y 轴以给定的度数进行旋转。transform: rotateY(130deg);（7）transition：过渡效果，使页面变化更平滑 transition-property ：执行动画对应的属性，例如 color，background 等，可以使用 all 来指定所有的属性。transition-duration：过渡动画的一个持续时间。transition-timing-function：在延续时间段，动画变化的速率，常见的有：ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier 。transition-delay：延迟多久后开始动画。简写为：transition: [ || || || ]; （8）animation：动画 使用CSS3 @keyframes 规则。 animation-name: 定义动画名称animation-duration: 指定元素播放动画所持续的时间长animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , )： 指元素根据时间的推进来改变属性值的变换速率，说得简单点就是动画的播放方式。animation-delay: 指定元素动画开始时间animation-iteration-count:infinite | ：指定元素播放动画的循环次animation-direction: normal | alternate： 指定元素动画播放的方向，其只有两个值，默认值为normal，如果设置为normal时，动画的每次循环都是向前播放；另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。animation-play-state:running | paused ：控制元素动画的播放状态。简写为： animation:[ || || || || || ] 这里只列出了一部分，详情可以去看w3school的CSS3 教程。 闭包是什么，什么时候闭包会消除? 因为作用域链，外部不能访问内部的变量和方法，这时我们就需要通过闭包，返回内部的方法和变量给外部，从而就形成了一个闭包。 JavaScript是一门具有自动垃圾回收机制的编程语言，主要有两种方式： 标记清除（最常用）垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 引用计数引用计数（reference counting）的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。 导致问题：会导致循环引用的变量和函数无法回收。 解决：将用完的函数或者变量置为null。 怎么理解js是单线程的 主要说一下异步以及事件循环机制，还有事件队列中的宏任务、微任务。 macrotask：主代码块，setTimeout，setInterval、setImmediate等。microtask：process.nextTick（相当于node.js版的setTimeout），Promise 。process.nextTick的优先级高于Promise。更详细可以看这篇博客：这一次，彻底弄懂 JavaScript 执行机制，讲的非常清晰。 有哪些排序算法，时间复杂度是多少？什么时候快排的效率最低？ 排序算法 最坏事件复杂度 平均时间复杂度 稳定度 空间复杂度冒泡排序 O(n^2) O(n^2) 稳定 O(1)插入排序 O(n^2) O(n^2) 稳定 O(1)选择排序 O(n^2) O(n^2) 稳定 O(1)快速排序 O(n^2) O(nlog2n) 不稳定 O(log2n)~O(n)二叉树排序 O(n^2) O(nlog2n) 不一定 O(n)堆排序 O(nlog2n) O(nlog2n) 不稳定 O(1)整个序列已经有序或完全倒序时，快排的效率最低。 原生ajax的请求过程 创建全平台兼容的XMLHttpRequest对象： function getXHR(){ var xhr = null; if(window.XMLHttpRequest) {// 兼容 IE7+, Firefox, Chrome, Opera, Safari xhr = new XMLHttpRequest(); } else if (window.ActiveXObject) { try { xhr = new ActiveXObject(“Msxml2.XMLHTTP”);// 即MSXML3 } catch (e) { try { xhr = new ActiveXObject(“Microsoft.XMLHTTP”);// // 兼容 IE6, IE5，很老的api,虽然浏览器支持,功能可能不完善,故不建议使用 } catch (e) { alert(“您的浏览器暂不支持Ajax!”); } } } return xhr;}Ajax请求数据的过程： var xhr = getXHR();xhr.open(‘GET’, url/file,true); //设置请求方式，url，以及是否异步xhr.onreadystatechange = function() { //设置回调监听函数 if(xhr.readyState==4){ if(xhr.status==200){ var data=xhr.responseText; console.log(data); }};xhr.onerror = function() { console.log(“Oh, error”);};xhr.send(); //发送请求 http状态码，cookie字段，cookie一般存的是什么，session怎么存在的？ 这部分可以参考我的博客：HTTP协议知识点总结 http请求方式有哪些？ HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。更多请看：HTTP请求方法 怎么用原生js实现一个轮播图，以及滚动滑动 之前我使用轮播图都是用的antd的组件，所以我大致说了一下思路，用定时器去实现，以及如何实现平滑的滚动效果。详情请看： 原生js实现轮播图 用过哪些开源的组件 说了antd和element-ui。 怎么实现上传下载的功能 主要说了下form表单和input标签。 react生命周期，以及diff算法，diff算法是对树的深度优先遍历还是广度优先遍历？ 对React、Redux、React-Redux详细剖析是深度优先遍历。 diff的实现 强缓存和协商缓存 参考：HTTP协议知识点总结 react-router的原理 react-router就是控制不同的url渲染不同的组件。react-router在history库的基础上，实现了URL与UI的同步。 原理：DOM渲染完成之后，给window添加onhashchange事件监听页面hash的变化，并且在state属性中添加了route属性，代表当前页面的路由。 具体步骤： 当点击链接，页面hash改变时，触发绑定在 window 上的 onhashchange 事件；在 onhashchange 事件中改变组件的 state中的 route 属性，react组件的state属性改变时，自动重新渲染页面；页面随着 state 中的route属性改变，自动根据不同的hash给Child变量赋值不同的组件，进行渲染。参考：react-router的实现原理 怎么用无人机捕获天空上的鸟 这个题目我也不造啊，毕竟我没用过无人机，有知道的大神可以在评论中回答一下~ 终面终面是去的现场，在深圳总部那边，基本就是闲聊了二十来分钟吧，面完还有hr小姐姐给我们介绍和参观了无人机，酷炫~ 做的项目中，哪个做的最深入最久为什么要做前端，喜欢做前端么未来的职业规划了解大疆么，大疆的文化是什么除了实习，还做过哪些项目如果生活富足，衣食无忧，你会选择干什么阿里巴巴阿里是提前批，找人内推了菜鸟网络，面了六轮，面的我怀疑人生了，中途四面本来已经挂了，后面三面面试官又捞起来给我加面了一轮，不过最后还是挂在了hr。 一面 css选择器，怎么选择相同的类 id、class、标签、伪类、通配符等。可以用getElementsByClassName（）选择相同的类。 css3有哪些伪类，伪类选择器有哪些 这里要区分一下伪类和伪元素的概念。根本区别在于它们是否创造了新的元素(抽象)。 伪类：用于向某些选择器添加特殊的效果。例如，a标签的:link, :visited, :hover, :active; 以及 :first-child, :last-child。伪元素：是html中不存在的元素，用于将特殊的效果添加到某些选择器。例如:before,:after, :first-letter, :first-line。css3只新增了一个伪元素 ::selection（改变用户所选取部分的样式）。参考： CSS3 选择器——伪类选择器 OSI七层网络模型 OSI七层模型 作用 对应协议 对应设备应用层 它是计算机用户，以及各种应用程序和网络之间的接口 HTTP, FTP, SMTP, POP3 计算机设备表示层 信息的语法语义以及它们的关系，如加密解密、转换翻译、压缩解压缩 IPX, LPP, XDP会话层 建立、维护、管理应用程序之间的会话 SSL, TLS, DAP, LDAP传输层 服务点编址，分段与重组、连接控制、流量控制、差错控制 TCP, UDP 防火墙网络层 为网络设备提供逻辑地址，进行路由选择、分组转发 IP ARP RARP ICMP IGMP 路由器数据链路层 物理寻址，同时将原始比特流转变为逻辑传输路线 PPTP, ARP, RARP 交换机物理层 机械、电子、定时接口通道信道上的原始比特流传输 IEEE 802.2, Ethernet v.2, Internetwork 网卡参考： 一张非常强大的OSI七层模型图解 MVC和MVVM的区别 Model用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法；View作为视图层，主要负责数据的展示；Controller定义用户界面对用户输入的响应方式，它连接模型和视图，用于控制应用程序的流程，处理用户的行为和数据上的改变。MVC将响应机制封装在controller对象中，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了。 MVVM把View和Model的同步逻辑自动化了。以前Controller负责的View和Model同步不再手动地进行操作，而是交给框架所提供的数据绑定功能进行负责，只需要告诉它View显示的数据对应的是Model哪一部分即可。也就是双向数据绑定，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。 参考： 浅析前端开发中的 MVC/MVP/MVVM 模式 用过哪些设计模式 （1）单例模式 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 实现方法：先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 适用场景：一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。 （2）发布/订阅模式定义：又叫观察者模式,它定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。 场景：订阅感兴趣的专栏和公众号。 （3）策略模式定义：将一个个算法（解决方案）封装在一个个策略类中。 优点： 策略模式可以避免代码中的多重判断条件。策略模式很好的体现了开放-封闭原则，将一个个算法（解决方案）封装在一个个策略类中。便于切换，理解，扩展。策略中的各种算法可以重复利用在系统的各个地方，避免复制粘贴。策略模式在程序中或多或少的增加了策略类。但比堆砌在业务逻辑中要清晰明了。违反最少知识原则，必须要了解各种策略类，才能更好的在业务中应用。应用场景：根据不同的员工绩效计算不同的奖金；表单验证中的多种校验规则。 （4）代理模式 定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。 应用场景：图片懒加载（先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。） （5）中介者模式 定义：通过一个中介者对象，其他所有相关对象都通过该中介者对象来通信，而不是互相引用，当其中的一个对象发生改变时，只要通知中介者对象就可以。可以解除对象与对象之间的紧耦合关系。 应用场景： 例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。 （6）装饰者模式 定义：在不改变对象自身的基础上，在程序运行期间给对象动态的添加方法。 应用场景： 有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。 参考： JavaScript设计模式 Http状态码 https怎么加密 参考： HTTP协议知识点总结 es6相比es5有哪些优点 大概说一下：let、const，模板字符串，箭头函数，做异步处理的promise、generator、async await，es6模块等。 参考： 阮一峰 —— ECMAScript 6 入门 ajax请求过程 不多说，上面有。 有哪些性能优化 参考： 嗨，送你一张Web性能优化地图前端优化不完全指南 懒加载怎么实现 场景：一个页面中很多图片，但是首屏只出现几张，这时如果一次性把图片都加载出来会影响性能。这时可以使用懒加载，页面滚动到可视区在加载。优化首屏加载。 实现：img标签src属性为空，给一个data-xx属性，里面存放图片真实地址，当页面滚动直至此图片出现在可视区域时，用js取到该图片的data-xx的值赋给src。 优点：页面加载速度快，减轻服务器压力、节约流量，用户体验好。 项目中写过什么组件，组件有哪些功能 主要介绍了下实习项目写过的组件，说了下如何实现的。 二面 react框架有哪些设计的好的地方 主要介绍了以下几个部分： JSX语法组件化react单项数据流虚拟DOMreact生命周期 react是怎么工作的，怎么提高性能 主要还是说了下react的生命周期，还有shouldComponentUpdate这个函数，以及diff算法。 redux有哪些需要改进，你觉得你用的不怎么舒服的地方？ 我当时说的是redux的subscribe方法有点麻烦，每次更新数据都要手动的subscribe一下，所以觉得react-redux的api封装的更好，用起来比较简单。 参考： 这段时间研究了下Redux，写写自己对它的感觉Redux数据流管理架构有什么致命缺陷,未来会如何改进? 怎么设计一个类似于antd 的 react 组件库 这个问题把我给问懵了额，我是按照软件工程的生命周期流程来答的。 你做的最自豪的一个项目 这个略过…言之有理即可 mysql 的左关联和右关联 左关联：保留左表中所有的元组，右表中没有的属性填充NULL。 右关联：保留右表中所有的元组，左表中没有的属性填充NULL。 有没有折腾过后端 直接说了没有，之前学了点PHP，不过都快忘得差不多了额。 学习方法和未来的学习路线 言之有理即可。 浏览器页面渲染机制 解析html建立dom树解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）布局render树（Layout/reflow），负责各元素尺寸、位置的计算绘制render树（paint），绘制页面像素信息浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。参考： 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 XSS和CSRF防范措施 （1）XSS：跨站脚本攻击 攻击方式：在URL或者页面输入框中插入JavaScript代码。 防范： 设置httpOnly，禁止用document.cookie操作；输入检查：在用户输入的时候进行格式检查；对输出转义。（2）CSRF：跨站点伪造请求 攻击方式：攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。主要是拿到了用户的登录态。 防范： 检查 Referer 字段：这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下。添加校验 Token：这种数据通常是表单中的一个数据项。服务器生成token并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 Token 的值为空或者错误，拒绝这个可疑请求。通过输入验证码来校验合法请求。三面这一面基本问的是个人知识沉淀了，如实回答就可以了。 在项目中的难点，怎么解决的你的优势是什么redux 源码学到了什么，怎么看源码的了解哪些前端的前沿技术平时看什么书，兴趣爱好是什么异步有哪些方法博客写了什么除了实习经历，还做过哪些项目四面这一面是在杭州菜鸟现场面的，尴尬的是通知我的小姐姐一直强调是hr面，我天真的以为是hr面了，然鹅问了很多技术，当时候想的是阿里的hr都这么厉害了，都能直接问技术了。临走之前，特意问了面试官是hr面么，他说是技术，然后我……大概就知道自己凉了。 mysql的索引用的什么，介绍一下b树，b+树，红黑树这些 mysql的索引用的是B+树。 参考： 数据结构中常见的树（BST二叉搜索树、AVL平衡二叉树、RBT红黑树、B-树、B+树、B*树） Mysql的基本写法 参考： 一千行 MySQL 学习笔记 估算下杭州上空现在有多少架飞机 这个题目，也真的是为难我了额。在网上搜到了个答案，可以参考下：高盛的面试题 两组数据，都存储五亿条url，内存有4G，如何找出相同的两条url 参考： 面试- 阿里-. 大数据题目- 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url? 如何找到一个字符串中最长的两个字符串 解法：后缀数组。首先生成字符串的所有后缀数组，在进行排序，找出相邻两个最长的公共子串（从第一位开始相同的） 例如：abcdeabc 生成后缀数组：【abcdeabc，bcdeabc，cdeabc，deabc，eabc，abc，bc，c】 再排序：【abcdeabc，abc，bcdeabc，bc，cdeabc，c，deabc，eabc】 找出相邻的最长公共子串：【abc，bc，c】 因此，最长的串是abc。 在白板上画出这个项目的整个架构 画了下项目的功能架构什么的。 XSS, CSRF,token 怎么来的，sql 注入知道么 sql注入： 攻击方式：服务器上的数据库运行非法的 SQL 语句，主要通过拼接字符串的形式来完成，改变sql语句本身的语义。通过sql语句实现无账号登陆，甚至篡改数据库。 防御： 使用参数化查询：使用预编译语句，预先编译的 SQL 语句，并且传入适当参数多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。 使用preparedStatement的参数化sql，通过先确定语义，再传入参数，就不会因为传入的参数改变sql的语义。（通过setInt，setString，setBoolean传入参数）单引号转换：将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。检查变量数据类型和格式。使用正则表达式过滤传入的参数，对特殊符号过滤或者转义处理。 怎么设计一个ant的组件 你觉得你实习做的项目有什么改进的地方 你做过印象最深刻的项目 算法了解过吗 就知道一些基本的排序额… Setstate 会发生什么 setState会引发一次组件的更新过程，从而引发页面的重新绘制。主要会涉及以下几个生命周期函数： shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）componentWillUpdate（被调用时this.state没有更新）render（被调用时this.state得到更新）componentDidUpdate 平时处理过什么兼容性 参考： web前端兼容性问题总结 了解分布式和负载均衡么 然鹅我并不了解呃。 参考： 服务器负载均衡的基本功能和实现原理 五面第四面确实是挂了，没面hr就让我走了，后面过了两天之后，三面面试官又把我捞起来了，说我计算机基础还有数据库基础不怎么好，然后说问我几个简单的，之后给了我机会面了hr，感谢三面面试官让我体验了阿里的整个面试流程，很满足了。 进程和线程的区别 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 冒泡排序和快速排序的区别 简述了下冒泡和快排的思想，以及冒泡和快排的时间复杂度。 OSI七层模型以及作用 上面有写噢，不知道的往上翻。 你有哪些优势，或者打动他的 呃，最怕这种自夸的问题额，然后就是夸了一顿，手动捂脸。 面向对象和非面向对象有什么区别 面向对象三大特性：封装,继承,多态。 面向对象的好处： 将对象进行分类，分别封装它们的数据和可以调用的方法，方便了函数、变量、数据的管理，方便方法的调用（减少重复参数等），尤其是在编写大型程序时更有帮助。用面向对象的编程可以把变量当成对象进行操作，让编程思路更加清晰简洁，而且减少了很多冗余变量的出现参考： 面向对象（一）|面向对象概念及优点 设计模式有哪些，说下装饰者模式和代理模式 前面有总结，往前翻。 重载和重写有什么区别 方法重写(overriding)： 也叫子类的方法覆盖父类的方法，要求返回值、方法名和参数都相同。子类抛出的异常不能超过父类相应方法抛出的异常。(子类异常不能超出父类异常)子类方法的的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)。方法重载(overloading): 重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但是参数却不相同，方法体也不相同，最常见的重载的例子就是类的构造函数。 参考： 方法重载和重写的区别 hr面为什么选择前端开发什么事情让你最有成就感什么让你最有挫败感为什么选择阿里平时是怎么学习的职业发展百度二面三面都有手写代码的环节，对于我这种动手能力弱的人来说还是挺吃力。当时提前批投递的是深圳百度，总共只招五个前端，没过也很正常。后面正式批笔试过了，但是要去北京面试，也就直接放弃了。 为什么要用flex布局，align-items和justify-content的区别 传统布局基于盒模型，非常依赖 display属性 、position属性 、float属性。而flex布局更灵活，可以简便、完整、响应式地实现各种页面布局，比如水平垂直居中。 align-items：定义在垂直方向上的对齐方式； justify-content：定义在水平方向上的对齐方式。 webpack是怎么打包的，babel又是什么？ 把项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。 babel将es6、es7、es8等语法转换成浏览器可识别的es5或es3语法。 saas和less不同于普通css的地方 定义变量，可以把反复使用的css属性值定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值；嵌套写法，父子关系一目了然；使用运算符，可以进行样式的计算；内置一些颜色处理函数用来对颜色值进行处理，例如加亮、变暗、颜色梯度等；继承：为多个元素定义相同样式的时候，我们可以考虑使用继承的做法；Mixins （混入）：有点像是函数或者是宏，当某段 CSS经常需要在多个元素中使用时，可以为这些共用的 CSS 定义一个Mixin，然后只需要在需要引用这些 CSS 地方调用该 Mixin 即可。 es 6模块和其他模块不同的地方 对比了一下es6模块和CommonJS模块： 区别 CommonJS es6加载原理 第一次加载模块就会执行整个模块，再次用到时，不会执行该模块，而是到缓存中取值。 不会缓存运行结果，动态的去被加载的模块中取值，并且变量总是绑定其所在模块。输出 值的拷贝（模块中值的改变不会影响已经加载的值） 值的引用（静态分析，动态引用，原来模块值改变会改变加载的值）加载方式 运行时加载（加载整个模块，即模块中的所有接口） 编译时加载（只加载需要的接口）this指向 指向当前模块 指向undefined循环加载 只输出已经执行的部分，还未执行的部分不会输出 遇到模块加载命令import时不会去执行模块，而是生成一个动态的只读引用，等到真正用到时再去模块中取值。只要引用存在，代码就能执行。 有没有用过es6的一些异步处理函数 Promise，generator，async await redux怎么处理异步操作 可以引入Redux-thunk或者redux-promise这种中间件，可以延迟事件的派发。 其中的原理：是因为他们用了applymiddleware()包装了store的dispatch方法，拥有可以处理异步的能力。 为什么reducer要是个纯函数，纯函数是什么？ 纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。 原因：Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同（浅比较）。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。两个state相同的话，页面就不会重新渲染了。 因为比较两个Javascript对象所有的属性是否相同的的唯一方法是对它们进行深比较。但是深比较在真实的应用当中代价昂贵，因为通常js的对象都很大，同时需要比较的次数很多。因此一个有效的解决方法是作出一个规定：无论何时发生变化时，开发者都要创建一个新的对象，然后将新对象传递出去。同时，当没有任何变化发生时，开发者发送回旧的对象。也就是说，新的对象代表新的state。 高阶函数是什么，怎么去写一个高阶函数 高阶函数：参数值为函数或者返回值为函数。例如map，reduce，filter，sort方法就是高阶函数。 编写高阶函数，就是让函数的参数能够接收别的函数。 vue跟react的区别是什么 没有用过vue，所以就只说了vue具有双向绑定，react是单向数据流。 参考： Vue.js与React的全面对比 nodejs处理了什么问题 可以处理高并发的I/O，也能与websocket配合，开发长连接的实时交互应用程序。 响应式布局，怎么做移动端适配 使用媒体查询可以实现响应式布局。 移动端适配方案： （1）meta viewport：让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。 width=device-width: 让当前viewport宽度等于设备的宽度 user-scalable=no: 禁止用户缩放 initial-scale=1.0: 设置页面的初始缩放值为不缩放 maximum-scale=1.0: 允许用户的最大缩放值为1.0 minimum-scale=1.0: 允许用户的最小缩放值为1.0 （2）媒体查询（响应式) （3）动态 rem 方案 参考： 移动端是怎么做适配的？ 二面 怎么做一个实时的聊天系统 使用WebSocket和nodejs，《nodejs实战》这本书详细介绍了这个项目。 当消息有延迟的时候，怎么保证消息的正确顺序 每个消息在被创建时，都将被赋予一个全局唯一的、单调递增的、连续的序列号（SerialNumber，SN）。可以通过一个全局计数器来实现这一点。通过比较两个消息的SN，确定其先后顺序。 怎么做一个登陆窗口，input有哪些兼容性 使用form表单。 input按钮如何校验 使用正则表达式。 如何实现水平垂直居中，relative、absolute、fixed 我说了三种方式： （1）使用表格 .container{ width: 600px; height: 600px; background: #eee; display: table-cell; text-align: center; vertical-align: middle;}.center{ background: blue;}（2）css3的transform属性 .container{ width: 100%; height: 400px; background: #eee; position: relative;}.center{ background: blue; position:absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);}（3）flex布局 .container{ width: 100%; height: 400px; background: #eee; display: flex; justify-content: center; align-items: center;}.center{ width: 100px; height: 100px; background: blue; text-align: center;}relative：相对于自己的定位；absolute：相对于最近一级定位元素的定位；fixed：相对于窗口的定位。 写一个函数，1s之后依次输出1,2,3,4,5 直接使用了let和定时器。 for(let i = 1 ; i &lt; 6; i++){ setTimeout(() =&gt; { conosle.log(i) }, 1000)} 事件队列（宏任务、微任务） 参考：：这一次，彻底弄懂 JavaScript 执行机制 如何每隔三个数加一个逗号，还要考虑小数点的情况 这道题就是大疆的笔试题，当时候笔试题也是瞎写的，后面也没仔细看，没想到又成了一道面试题。 function transform(number){ var num = number.toString() var numArr = num.split(‘.’) var [num, dotNum] = numArr var operateNum = num.split(&apos;&apos;).reverse() var result = [], len = operateNum.length for(var i = 0; i&lt; len; i++){ result.push(operateNum[i]) if(((i+1) % 3 === 0) &amp;&amp; (i !== len-1)){ result.push(&apos;,&apos;) } } if(dotNum){ result.reverse().push(&apos;.&apos;， ...dotNum) return result.join(&apos;&apos;) }else{ return result.reverse().join(&apos;&apos;) } } webpack有配置过吗？原理知道吗 参考前面。 父子组件如何通信，子组件怎么跟父组件通信？ 父组件把state作为props传递给子组件进行通信。 父组件写好state和处理该state的函数，同时将函数名通过props属性值的形式传入子组件，子组件调用父组件的函数，同时引起state变化。 简单说一下pwa 面试的这个部门就是做pwa的，所以说了下自己对pwa的理解。 三面 手写indexOf function indexOf(str, val){ var strLen = str.length, valLen = val.length for(var i = 0; i &lt; strLen; i++){ var matchLen = i + valLen var matchStr = str.slice(i, matchLen) if(matchLen &gt; strLen){ return -1 } if(matchStr === val){ return i } } return -1} 实现 JS 的继承 function A () { this.name = ‘a’;} A.prototype.getName = function () { return this.name;} function B () {} // B 如何继承 A参考： JS实现继承的几种方式 从url输入到页面显示会有哪些步骤 （1）DNS服务器解析域名，找到对应服务器的IP地址; （2）和服务器建立TCP三次握手连接； （3）发送HTTP请求，服务器会根据HTTP请求到数据服务器取出相应的资源，并返回给浏览器； （4）浏览器处理响应 加载：浏览器对一个html页面的加载顺序是从上而下的。当加载到外部css文件、图片等资源，浏览器会再发起一次http请求，来获取外部资源。当加载到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，等待js文件加载、解析完毕才可以恢复html文档的渲染线程。 解析：解析DOM树和CSSDOM树。渲染：构建渲染树，将DOM树进行可视化表示，将页面呈现给用户。 method有哪些方法，分别是什么意思？post和put的区别 post：上传资源 put：修改资源 https有几次握手 http2比http1好的地方 主要是考察http2的几个特性。 参考：HTTP协议知识点总结 页面刷新不出来，是有哪些问题 可以从第三题的每个步骤进行分析，大概是： 域名不存在，或者ip地址错误网络问题，不能建立正常的tcp连接服务器找不到正确的资源 上一次系统性的学习是什么时候，怎么学习的 学习react的时候，看文档、博客，照着网上写了点小项目。 你觉得项目中最自豪的是什么 上家公司有哪些不好的地方 网易网易是在杭州网易大厦面的，一天面完三轮，然后录用排序，择优录取的吧。我投的是网易考拉，哭唧唧，后面被拒了之后还伤心的卸载了考拉。之后正式批投了杭研，过了笔试，要去武汉面，本来海康也是在武汉面的，考虑到还要住一晚上，有点怕怕，就没去了。 1.css3动画 flex布局 实现call Function.prototype.call2 = function (context) { var context = Object(context) || window context.fn = this var args = [] for (var i = 1; i &lt; arguments.length; i++) { args.push(‘arguments[‘ + i +’]’) } var res = eval(&apos;context.fn(&apos; + args + &apos;)&apos;) delete context.fn return res } 图片懒加载data-src Promise异步 水平垂直居中 数组有哪些方法，哪些会改变原数组 改变原数组的方法：pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill； 不改变原数组（复制）：concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf、未标准的toSource以及ES7新增的方法includes； 循环遍历：forEach、every、some、filter、map、reduce、reduceRight 以及ES6新增的方法entries、find、findIndex、keys、values。 操作dom有哪些方法 创建： createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 添加：appendChild() 移出：removeChild() 替换：replaceChild() 插入：insertBefore() 复制：cloneNode(true) 查找： getElementsByTagName() //通过标签名称 getElementsByClassName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 左边定宽右边自适应 （1）左盒子左浮动，右盒子width=100% （2）左盒子左浮动，右盒子margin-left=左盒子宽度 （3）左盒子左浮动，右盒子右浮动，设置calc（100vw-盒子宽度） （4）父容器设置display=flex，右盒子flex：1 事件代理 利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行。打个比方：一个button对象，本来自己需要监控自身的点击事件，但是自己不来监控这个点击事件，让自己的父节点来监控自己的点击事件。 后端了解么 直接说了不了解，笑哭。 二面 节流和防抖，手写一下代码 （1）防抖： 定义： 合并事件且不会去触发事件，当一定时间内没有触发这个事件时，才真正去触发事件。 原理：对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。 场景： keydown事件上验证用户名，输入法的联想。 实现： function debounce(fn, delay) { var timer return function () { var that = this var args = arguments clearTimeout(timer) timer = setTimeout(function () { fn.apply(that, args) }, delay) } }（2）节流： 定义： 持续触发事件时，合并一定时间内的事件，在间隔一定时间之后再真正触发事件。每间隔一段时间触发一次。 原理：对处理函数进行延时操作，若设定的延时到来之前，再次触发事件，则清除上一次的延时操作定时器，重新定时。 场景： resize改变布局时，onscroll滚动加载下面的图片时。 实现： 方法一：使用时间戳。当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为0)，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。 缺陷：第一次事件会立即执行，停止触发后没办法再激活事件。 function throttle(fn, interval) { var previousTime = +new Date() return function () { var that = this var args = arguments var now = +new Date() if (now - previousTime &gt;= interval) { previousTime = now fn.apply(that, args) } }}方法二：使用定时器当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。 缺陷：第一次事件会在n秒后执行，停止触发后依然会再执行一次事件。 function throttle(fn, interval) { var timer return function (){ var that = this var args = arguments if(!timer){ timer = setTimeout(function () { fn.apply(that, args) timer = null }, interval) } }}方法三：优化鼠标移入能立刻执行，停止触发的时候还能再执行一次。 var throttle = function(func,delay){ var timer = null; var startTime = Date.now(); return function(){ var curTime = Date.now(); var remaining = delay-(curTime-startTime); var context = this; var args = arguments; clearTimeout(timer); if(remaining&lt;=0){ func.apply(context,args); startTime = Date.now(); }else{ timer = setTimeout(func,remaining); } } } 知道哪些性能优化 react为什么比其他要快，虚拟dom知道吗 写过什么组件 平时怎么学习的 node，webpack了解么 模块化，commonjs,es6模块 redux怎么实现的 hr面项目上有哪些难点，项目中学到了什么不喜欢跟什么样的人共事平时怎么学习为什么来杭州职业发展搜狗搜狗是内推的，面试也很迷，第一面到第二面中间隔了二十几天，然后二面完了也毫无反馈。 一面 说一下项目，整个网络过程，从前端到后台 Ajax 底层实现，readystate 有哪些 0-（未初始化）还没有调用send()方法 1-（载入）已调用send()方法，正在发送请求 2-（载入完成）send()方法执行完成，已经接收到全部响应内容 3-（交互）正在解析响应内容 4-（完成）响应内容解析完成，可以在客户端调用了 状态码有哪些，100,307 OSI七层模型 TCP三次握手 SSL握手过程 jQuery 有哪些方法 display 有哪些属性，说一下flex的属性 Es6的async awiat ，generator Map有哪些方法 Map的方法：set, get, has, delete, clear 遍历方法： keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 参考： Set 和 Map 数据结构 正则用过吗？exec, 匹配一个手机号 css3动画了解吗，怎么写一个loading动画 怎么实现跨域,cors涉及哪些请求字段 编程: 判断两个网络地址是否属于同一个子网掩码 用与运算符就可以了。当时是在牛客网的面试系统上写的，一直AC不出，也是很迷了额。 怎么上传文件 二面 怎么计算在一个页面上的停留时间 方案1：websocket，前端开个长连接，后台统计长连接时间。 方案2：ajax轮询，隔几秒发一个查询，后台记录第一与最后一个查询间隔时间。 方案3： 关闭窗口或者跳转的时候会触发window.onbeforeunload函数，可以在该函数中做处理（有兼容性问题）；统计完数据记录到本地cookies中，一段时间后统一发送。 给你一亿个数，是连续的，怎么找出两个不存在的数 用bitmap就能搞定了，存在为1，不存在为0。 一个搜索框的输入联想，会遇到什么问题？如果第一个请求延迟，第二个请求先到，请问怎么处理？ 键盘输入太快，每次输入都去联想，需要多次发送请求，会导致用户体验太差，可以使用防抖优化。 在前端做判断，判断此时的值是否与返回的值相同，不同就丢弃，相同就显示在页面。 Http的缓存 二维码怎么工作的，扫描pc端的二维码，怎么让pc端登录？ pc端随机生成一个含有唯一uid的二维码，并与服务器建立一个长连接；手机扫描二维码，解析出二维码中的uid，并把这个uid和手机端的用户密码进行绑定，上传给服务器；服务器获得客户端信息之后，pc端的长连接轮询操作会获得该消息，显示该账号的信息；pc端会再开一个长连接与手机端保持通信，等待手机端确认登陆后，获得服务器授权的token，就可以在pc端登陆进行正常通信了。 Promise 做什么的，有哪几种状态 异步处理的，有三个状态：resolve，pending，reject。 项目有哪些难点，怎么处理的 遇到过哪些性能优化 电信IT研发中心当时听说电信对学历要求很高，本科基本都是211起的，想着自己本科太渣，就直接放弃了网上的笔试。之后电信来了学校宣讲会，跟朋友吃完饭看到了，就去说凑凑热闹，刚好有笔试也就做了。做完之后笔试居然考了最高分，比第二名高出二十分，手动捂脸额。一面完分数也挺高的，有95分，运气爆棚。重点是今年电信开的薪资实在太高了，目前还在纠结选哪个。 Xhtml和html的区别 XHTML 元素必须被正确地嵌套。XHTML 元素必须被关闭。标签名必须用小写字母。XHTML 文档必须拥有根元素。 遇到过哪些兼容性问题 浏览器内核有哪些，移动端用的是哪个 Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。[又称为MSHTML]Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等；Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink]Webkit内核：Safari,Chrome等。[Chrome的:Blink(Webkit的分支)]对于Android手机而言，使用率最高的就是Webkit内核。 怎么实现标签页的通信 Cookie、session,localstorage，sessionstorage React 和jquery 之间的区别，哪个好用 怎么实现继承 Es6,es7有哪些特性 怎么跨域 Commonjs用的js哪个特性? 因为js之前只能在浏览器运行，为了能让js能在服务器上运行，所以设计了commonjs规范，而且js之前没有模块化的概念。 选择器优先级 伪类知道吗，有哪些 块级元素有哪些，怎么转成行内元素 一个完整的http请求，页面渲染过程，js和css文件怎么渲染 二面一面问的都很常规的，不知道为啥给了这么高的分。二面的时候三个面试官，总共就问了三个问题，然后就说面试结束了，不超过五分钟。 TCP怎么工作的 三次握手 OSI七层模型，路由器工作在哪一层？ 网络层 平时用什么语言，用过哪些框架 深信服深信服给的薪资居然比电信还低，而且加班还严重，就直接拒了。 一面 跨域，同源策略，webpack里面有个跨域的方式知道么 怎么把es6转成es5，babel怎么工作的 解析：将代码字符串解析成抽象语法树变换：对抽象语法树进行变换操作再建：根据变换后的抽象语法树再生成代码字符串 反向代理知道么，Nginx 继承有哪些方式 怎么实现一个sleep ，手写一个promise 能写一个二叉树么，怎么去遍历 深拷贝怎么写 （1）var new_arr = JSON.parse( JSON.stringify(arr) ); （2）for in 加递归 function isObj(obj) {//判断是否为对象或者函数，但不是null return (typeof obj === ‘object’ || typeof obj === ‘function’) &amp;&amp; obj !== null} function deepCopy(obj) { let newObj = Array.isArray(obj) ? [] : {} for(let key in obj) { newObj[key] = isObj(obj[key]) ? deepCopy(obj[key]) : obj[key] } return newObj}（3）$.extend() （4）函数库lodash，提供_.cloneDeep（） 在公司除了完成上级交待的任务，还做了什么 怎么实现垂直中间布局 Call和apply，哪个性能开销大 在思否上提问了，已有大神回答。 参考： call和apply的哪个性能更好 正则写一个手机号，全局匹配是什么 删除一个数组中的某个数 splice方法 模块化介绍一下，什么是编译时优化 有哪些网络安全名词，怎么防范 平时怎么学习 二面二面小哥哥问了几个问题之后，就一直跟我介绍深信服内部的一些管理、技术氛围、晋升机制什么的，全程都是笑脸额。 git push -u 是什么意思 绑定默认提交的远程版本库，加了参数-u后，以后即可直接用git push 代替git push origin master git rebase解释下 有test和dev两个分支，分别有两个commit，此时执行下列命令： git checkout testgit rebase dev以dev为基准将test的提交进行回放，挨个的应用到dev上去，然后test的那些提交就会废弃。 等价于git merge dev。 git merge 和git rebase区别： merge不会修改提交历史，rebase会修改提交历史。 rebase只应用于本地没有提交的代码，如果应用到已经提交到远程的分支不要应用，不然会非常的麻烦，git merge 可以应用于远程分支。 linux命令，怎么打开一个文件 cat abc.txt 你的上级给你review 代码时会提什么建议 怎么看待加班和工作效率 get和post分别进行几次数据交互 get请求过程：（2次交互） 浏览器请求tcp连接（第一次握手） 服务器答应进行tcp连接（第二次握手） 浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送） 服务器返回200 ok响应。post请求过程：（3次交互） 浏览器请求tcp连接（第一次握手） 服务器答应进行tcp连接（第二次握手） 浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送） 服务器返回100 continue响应 浏览器开始发送数据 服务器返回200 ok响应 怎么打断点，如何确定一个结果来自于哪个函数 ThoughtWorksTW是内推的，做了内推作业后，就面了技术和文化面。技术面是在作业的基础上加两个功能，只写出来一个，后面一个没时间写了，然后就只讲了下思路。 文化面面了快一个小时，听说TW不加班，对女程序员还很友好，挺中意的公司，不过最后还是挂了额。 华为华为的面试就不多说了，基本不问前端的，进去是随机分岗的。华为的面试阵仗是我见过的最大的，听说要招一万人，在万达那里面的，全是人啊，阔怕。现在正泡在offer池里，估计国庆后发正式offer吧。 二面碰到的是个女面试官，太恐怖了，一直在怼我，最怕碰到女面试官了，惨。 小米小米是内推的，电话面了一面，国庆后要我去武汉现场面，那会学校刚好有事应该也不会去了。 redux主要做什么的，用过redux的一些中间件吗，简单说一下 react生命周期说一下，diff算法说一下 setstate时会合并修改，是在哪个函数里修改的？宏事件和微事件 setstate是异步更新的，通过一个队列机制实现state的更新，当执行setState时，会将需要更新的state合并后放入状态队列，而不会立即更新，队列可以高效的批量更新state。 let、const、var的区别；如果const定义的是个对象，能够修改对象的属性吗？ const实际上保证的并不是变量的值不得改动，而是变量指向的那个指针不得改动，可以给对象添加属性。如果真的想将对象冻结，应该使用Object.freeze方法。 Object.freeze和Object.seal的区别 Object.preventExtension：禁止对象添加新属性并保留已有属性; Object.seal：在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false; Object.freeze：在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false。 说一下防抖，应用场景是什么 快速排序算法说下，基点怎么选？如果一个数组是已经排序好的怎么选基点？ 数组元素随机，取固定基准；数组元素已排序或逆序，取随机基准；更好的方法：三数取中，选取数组开头，中间和结尾的元素，通过比较，选择中间的值作为快排的基准。 算法的稳定性，冒泡、快排 lodash，underscore的库了解么？有哪些方法 整个项目的架构，包括前端、后台、运营 sort的底层实现机制，看过源码么？ 数组长度&lt;=22时采用插入排序，大于22用快排。 怎么调试bug？打过断点么？如果前端代码被压缩，如何去找到相应元素？ chromre控制台下，在 Scripts 面板下面有个 Pretty print 按钮(这种符号 {})，点击会将压缩 js 文件格式化缩进规整的文件，这时候在设定断点可读性就大大提高了。","categories":[{"name":"2018面试题","slug":"2018面试题","permalink":"https://93qlin.github.io/categories/2018面试题/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://93qlin.github.io/tags/面试/"}]},{"title":"用Hexo + github搭建自己的博客","slug":"用Hexo + github搭建自己的博客","date":"2019-02-28T03:12:12.521Z","updated":"2019-04-12T02:30:52.038Z","comments":true,"path":"2019/02/28/用Hexo + github搭建自己的博客/","link":"","permalink":"https://93qlin.github.io/2019/02/28/用Hexo + github搭建自己的博客/","excerpt":"","text":"","categories":[{"name":"用Hexo + github搭建自己的博客","slug":"用Hexo-github搭建自己的博客","permalink":"https://93qlin.github.io/categories/用Hexo-github搭建自己的博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://93qlin.github.io/tags/Hexo/"},{"name":"github","slug":"github","permalink":"https://93qlin.github.io/tags/github/"}]},{"title":"扁平化数据树形化 ,树形数据扁平化","slug":"树形数据扁平化，扁平化数据树形化","date":"2019-02-28T03:12:12.521Z","updated":"2019-02-28T03:12:12.521Z","comments":true,"path":"2019/02/28/树形数据扁平化，扁平化数据树形化/","link":"","permalink":"https://93qlin.github.io/2019/02/28/树形数据扁平化，扁平化数据树形化/","excerpt":"","text":"扁平化数据树形化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207var list = [ &#123;&quot;Id&quot;: 19, &quot;Name&quot;: &quot;App&quot;, &quot;PId&quot;: null, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;, &#123;&quot;Id&quot;: 1025, &quot;Name&quot;: &quot;企业查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 1051, &quot;Name&quot;: &quot;企业列表&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,&#125;,&#123; &quot;Id&quot;: 1029, &quot;Name&quot;: &quot;企业明细&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;,&#125;,&#123; &quot;Id&quot;: 1030, &quot;Name&quot;: &quot;投标战绩&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;, &#123; &quot;Id&quot;: 1026, &quot;Name&quot;: &quot;业绩查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1031, &quot;Name&quot;: &quot;业绩列表&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;, &#123; &quot;Id&quot;: 1032, &quot;Name&quot;: &quot;业绩明细&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Children&quot;: [] &#125;, &#123; &quot;Id&quot;: 1, &quot;Name&quot;: &quot;后台&quot;, &quot;PId&quot;: null, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 22, &quot;Name&quot;: &quot;首页&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-home&quot;, &#125;, &#123; &quot;Id&quot;: 38, &quot;Name&quot;: &quot;查询&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-home&quot;, &#125;, &#123; &quot;Id&quot;: 2, &quot;Name&quot;: &quot;管理&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 99, &quot;Class&quot;: &quot;iconfont icon-home&quot; &#125;, &#123; &quot;Id&quot;: 12, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 3, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 4, &quot;Name&quot;: &quot;添加用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1001&quot;, &#125;, &#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;修改用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1002&quot;, &#125;, &#123; &quot;Id&quot;: 8, &quot;Name&quot;: &quot;开启、关闭用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 6, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1009&quot;, &#125;, &#123; &quot;Id&quot;: 9, &quot;Name&quot;: &quot;重置密码&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 7, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;2001&quot;, &#125;, &#123; &quot;Id&quot;: 10, &quot;Name&quot;: &quot;导出用户信息&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 8, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1008&quot;, &#125;, &#123; &quot;Id&quot;: 39, &quot;Name&quot;: &quot;金币管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;, &#123; &quot;Id&quot;: 40, &quot;Name&quot;: &quot;使用量&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;, &#123; &quot;Id&quot;: 41, &quot;Name&quot;: &quot;业余采集&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;, &#123; &quot;Id&quot;: 14, &quot;Name&quot;: &quot;相关设置&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 42, &quot;Name&quot;: &quot;预测参数管理&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;, &#123; &quot;Id&quot;: 43, &quot;Name&quot;: &quot;优惠活动&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;, &#123; &quot;Id&quot;: 44, &quot;Name&quot;: &quot;统计分析&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;, &#123; &quot;Id&quot;: 45, &quot;Name&quot;: &quot;CA设置&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;, &#123; &quot;Id&quot;: 46, &quot;Name&quot;: &quot;VIP价格&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 5, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;] 123456789101112131415161718192021222324function listChangeTree(data) &#123; // 删除 所有 children,以防止多次调用 data.forEach(function (item) &#123; delete item.child; &#125;); // 将数据存储为 以 id 为 KEY 的 map 索引数据列 let map = &#123;&#125;; data.forEach(function (item) &#123; map[item.Id] = item; &#125;); let val = []; data.forEach(function (item) &#123; // 以当前遍历项，的pid,去map对象中找到索引的id let parent = map[item.PId]; // 如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中 if (parent) &#123; (parent.child || (parent.child = [])).push(item); &#125; else &#123; //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级 val.push(item); &#125; &#125;); return val; &#125; 1listChangeTree(list) 结果得到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202[&#123; &quot;Id&quot;: 19, &quot;Name&quot;: &quot;App&quot;, &quot;PId&quot;: null, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1025, &quot;Name&quot;: &quot;企业查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1051, &quot;Name&quot;: &quot;企业列表&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1029, &quot;Name&quot;: &quot;企业明细&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1030, &quot;Name&quot;: &quot;投标战绩&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 1026, &quot;Name&quot;: &quot;业绩查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1031, &quot;Name&quot;: &quot;业绩列表&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1032, &quot;Name&quot;: &quot;业绩明细&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Children&quot;: [] &#125;] &#125;]&#125;,&#123; &quot;Id&quot;: 1, &quot;Name&quot;: &quot;后台&quot;, &quot;PId&quot;: null, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 22, &quot;Name&quot;: &quot;首页&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-home&quot; &#125;, &#123; &quot;Id&quot;: 38, &quot;Name&quot;: &quot;查询&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-home&quot; &#125;, &#123; &quot;Id&quot;: 2, &quot;Name&quot;: &quot;管理&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 99, &quot;Class&quot;: &quot;iconfont icon-home&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 12, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 3, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 4, &quot;Name&quot;: &quot;添加用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1001&quot; &#125;, &#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;修改用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1002&quot; &#125;, &#123; &quot;Id&quot;: 8, &quot;Name&quot;: &quot;开启、关闭用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 6, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1009&quot; &#125;, &#123; &quot;Id&quot;: 9, &quot;Name&quot;: &quot;重置密码&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 7, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;2001&quot; &#125;, &#123; &quot;Id&quot;: 10, &quot;Name&quot;: &quot;导出用户信息&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 8, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1008&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 39, &quot;Name&quot;: &quot;金币管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 40, &quot;Name&quot;: &quot;使用量&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 41, &quot;Name&quot;: &quot;业余采集&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 14, &quot;Name&quot;: &quot;相关设置&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 42, &quot;Name&quot;: &quot;预测参数管理&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 43, &quot;Name&quot;: &quot;优惠活动&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 44, &quot;Name&quot;: &quot;统计分析&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 45, &quot;Name&quot;: &quot;CA设置&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 46, &quot;Name&quot;: &quot;VIP价格&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 5, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;] &#125;]&#125;] 树形数据扁平化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201var list = [&#123; &quot;Id&quot;: 19, &quot;Name&quot;: &quot;App&quot;, &quot;PId&quot;: null, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1025, &quot;Name&quot;: &quot;企业查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1051, &quot;Name&quot;: &quot;企业列表&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1029, &quot;Name&quot;: &quot;企业明细&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1030, &quot;Name&quot;: &quot;投标战绩&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 1026, &quot;Name&quot;: &quot;业绩查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1031, &quot;Name&quot;: &quot;业绩列表&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1032, &quot;Name&quot;: &quot;业绩明细&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &#125;] &#125;]&#125;,&#123; &quot;Id&quot;: 1, &quot;Name&quot;: &quot;后台&quot;, &quot;PId&quot;: null, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 22, &quot;Name&quot;: &quot;首页&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-home&quot; &#125;, &#123; &quot;Id&quot;: 38, &quot;Name&quot;: &quot;查询&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-home&quot; &#125;, &#123; &quot;Id&quot;: 2, &quot;Name&quot;: &quot;管理&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 99, &quot;Class&quot;: &quot;iconfont icon-home&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 12, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 3, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 4, &quot;Name&quot;: &quot;添加用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1001&quot; &#125;, &#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;修改用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1002&quot; &#125;, &#123; &quot;Id&quot;: 8, &quot;Name&quot;: &quot;开启、关闭用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 6, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1009&quot; &#125;, &#123; &quot;Id&quot;: 9, &quot;Name&quot;: &quot;重置密码&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 7, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;2001&quot; &#125;, &#123; &quot;Id&quot;: 10, &quot;Name&quot;: &quot;导出用户信息&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 8, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1008&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 39, &quot;Name&quot;: &quot;金币管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 40, &quot;Name&quot;: &quot;使用量&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 41, &quot;Name&quot;: &quot;业余采集&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 14, &quot;Name&quot;: &quot;相关设置&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 42, &quot;Name&quot;: &quot;预测参数管理&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 43, &quot;Name&quot;: &quot;优惠活动&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 44, &quot;Name&quot;: &quot;统计分析&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 45, &quot;Name&quot;: &quot;CA设置&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 46, &quot;Name&quot;: &quot;VIP价格&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 5, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;] &#125;]&#125;] 1234567891011121314151617function formatConversion (parent, child, index = 0, family = [], elderIdentity = &apos;x&apos;) &#123; // child如果长度等于0，则代表已经到了最低层 // let page = (this.startPage - 1) * 10 if (child&amp;&amp;child.length &gt; 0) &#123; child.map((x, i) =&gt; &#123; // 设置 __level 标志位 用于展示区分层级 // Vue.set(x, &apos;__level&apos;, index) // 设置 __family 为家族关系 为所有父级，包含本身在内 // Vue.set(x, &apos;__family&apos;, [...family, elderIdentity + &apos;_&apos; + i]) // 本身的唯一标识 可以理解为个人的身份证咯 一定唯一。 // Vue.set(x, &apos;__identity&apos;, elderIdentity + &apos;_&apos; + i) parent.push(x) // 如果仍有子集，则进行递归 if (x.child&amp;&amp;x.child.length &gt; 0) this.formatConversion(parent, x.child, index + 1, [...family, elderIdentity + &apos;_&apos; + i], elderIdentity + &apos;_&apos; + i) &#125;) &#125; return parent &#125; 1formatConversion([],list) 结果得到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683[&#123; &quot;Id&quot;: 19, &quot;Name&quot;: &quot;App&quot;, &quot;PId&quot;: null, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1025, &quot;Name&quot;: &quot;企业查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1051, &quot;Name&quot;: &quot;企业列表&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1029, &quot;Name&quot;: &quot;企业明细&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1030, &quot;Name&quot;: &quot;投标战绩&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 1026, &quot;Name&quot;: &quot;业绩查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1031, &quot;Name&quot;: &quot;业绩列表&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1032, &quot;Name&quot;: &quot;业绩明细&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;]&#125;,&#123; &quot;Id&quot;: 1025, &quot;Name&quot;: &quot;企业查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1051, &quot;Name&quot;: &quot;企业列表&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1029, &quot;Name&quot;: &quot;企业明细&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1030, &quot;Name&quot;: &quot;投标战绩&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;]&#125;,&#123; &quot;Id&quot;: 1051, &quot;Name&quot;: &quot;企业列表&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 1029, &quot;Name&quot;: &quot;企业明细&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 1030, &quot;Name&quot;: &quot;投标战绩&quot;, &quot;PId&quot;: 1025, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 1026, &quot;Name&quot;: &quot;业绩查询&quot;, &quot;PId&quot;: 19, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 1031, &quot;Name&quot;: &quot;业绩列表&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 1032, &quot;Name&quot;: &quot;业绩明细&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;]&#125;,&#123; &quot;Id&quot;: 1031, &quot;Name&quot;: &quot;业绩列表&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 1032, &quot;Name&quot;: &quot;业绩明细&quot;, &quot;PId&quot;: 1026, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 1, &quot;Name&quot;: &quot;后台&quot;, &quot;PId&quot;: null, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 22, &quot;Name&quot;: &quot;首页&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-home&quot; &#125;, &#123; &quot;Id&quot;: 38, &quot;Name&quot;: &quot;查询&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-home&quot; &#125;, &#123; &quot;Id&quot;: 2, &quot;Name&quot;: &quot;管理&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 99, &quot;Class&quot;: &quot;iconfont icon-home&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 12, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 3, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 4, &quot;Name&quot;: &quot;添加用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1001&quot; &#125;, &#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;修改用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1002&quot; &#125;, &#123; &quot;Id&quot;: 8, &quot;Name&quot;: &quot;开启、关闭用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 6, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1009&quot; &#125;, &#123; &quot;Id&quot;: 9, &quot;Name&quot;: &quot;重置密码&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 7, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;2001&quot; &#125;, &#123; &quot;Id&quot;: 10, &quot;Name&quot;: &quot;导出用户信息&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 8, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1008&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 39, &quot;Name&quot;: &quot;金币管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 40, &quot;Name&quot;: &quot;使用量&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 41, &quot;Name&quot;: &quot;业余采集&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 14, &quot;Name&quot;: &quot;相关设置&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 42, &quot;Name&quot;: &quot;预测参数管理&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 43, &quot;Name&quot;: &quot;优惠活动&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 44, &quot;Name&quot;: &quot;统计分析&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 45, &quot;Name&quot;: &quot;CA设置&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 46, &quot;Name&quot;: &quot;VIP价格&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 5, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;] &#125;]&#125;,&#123; &quot;Id&quot;: 22, &quot;Name&quot;: &quot;首页&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-home&quot;&#125;,&#123; &quot;Id&quot;: 38, &quot;Name&quot;: &quot;查询&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-home&quot;&#125;,&#123; &quot;Id&quot;: 2, &quot;Name&quot;: &quot;管理&quot;, &quot;PId&quot;: &quot;1&quot;, &quot;Order&quot;: 99, &quot;Class&quot;: &quot;iconfont icon-home&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 12, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 3, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 4, &quot;Name&quot;: &quot;添加用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1001&quot; &#125;, &#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;修改用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1002&quot; &#125;, &#123; &quot;Id&quot;: 8, &quot;Name&quot;: &quot;开启、关闭用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 6, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1009&quot; &#125;, &#123; &quot;Id&quot;: 9, &quot;Name&quot;: &quot;重置密码&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 7, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;2001&quot; &#125;, &#123; &quot;Id&quot;: 10, &quot;Name&quot;: &quot;导出用户信息&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 8, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1008&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 39, &quot;Name&quot;: &quot;金币管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 40, &quot;Name&quot;: &quot;使用量&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 41, &quot;Name&quot;: &quot;业余采集&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 14, &quot;Name&quot;: &quot;相关设置&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 42, &quot;Name&quot;: &quot;预测参数管理&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 43, &quot;Name&quot;: &quot;优惠活动&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 44, &quot;Name&quot;: &quot;统计分析&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 45, &quot;Name&quot;: &quot;CA设置&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 46, &quot;Name&quot;: &quot;VIP价格&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 5, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;] &#125;]&#125;,&#123; &quot;Id&quot;: 12, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 3, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 4, &quot;Name&quot;: &quot;添加用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1001&quot; &#125;, &#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;修改用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1002&quot; &#125;, &#123; &quot;Id&quot;: 8, &quot;Name&quot;: &quot;开启、关闭用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 6, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1009&quot; &#125;, &#123; &quot;Id&quot;: 9, &quot;Name&quot;: &quot;重置密码&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 7, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;2001&quot; &#125;, &#123; &quot;Id&quot;: 10, &quot;Name&quot;: &quot;导出用户信息&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 8, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1008&quot; &#125;] &#125;, &#123; &quot;Id&quot;: 39, &quot;Name&quot;: &quot;金币管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 40, &quot;Name&quot;: &quot;使用量&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 41, &quot;Name&quot;: &quot;业余采集&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;]&#125;,&#123; &quot;Id&quot;: 3, &quot;Name&quot;: &quot;用户管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 4, &quot;Name&quot;: &quot;添加用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1001&quot; &#125;, &#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;修改用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1002&quot; &#125;, &#123; &quot;Id&quot;: 8, &quot;Name&quot;: &quot;开启、关闭用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 6, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1009&quot; &#125;, &#123; &quot;Id&quot;: 9, &quot;Name&quot;: &quot;重置密码&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 7, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;2001&quot; &#125;, &#123; &quot;Id&quot;: 10, &quot;Name&quot;: &quot;导出用户信息&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 8, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1008&quot; &#125;]&#125;,&#123; &quot;Id&quot;: 4, &quot;Name&quot;: &quot;添加用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1001&quot;&#125;,&#123; &quot;Id&quot;: 5, &quot;Name&quot;: &quot;修改用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1002&quot;&#125;,&#123; &quot;Id&quot;: 8, &quot;Name&quot;: &quot;开启、关闭用户&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 6, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1009&quot;&#125;,&#123; &quot;Id&quot;: 9, &quot;Name&quot;: &quot;重置密码&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 7, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;2001&quot;&#125;,&#123; &quot;Id&quot;: 10, &quot;Name&quot;: &quot;导出用户信息&quot;, &quot;PId&quot;: 3, &quot;Order&quot;: 8, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;Code&quot;: &quot;1008&quot;&#125;,&#123; &quot;Id&quot;: 39, &quot;Name&quot;: &quot;金币管理&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 40, &quot;Name&quot;: &quot;使用量&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 41, &quot;Name&quot;: &quot;业余采集&quot;, &quot;PId&quot;: 12, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 14, &quot;Name&quot;: &quot;相关设置&quot;, &quot;PId&quot;: 2, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;, &quot;child&quot;: [&#123; &quot;Id&quot;: 42, &quot;Name&quot;: &quot;预测参数管理&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 43, &quot;Name&quot;: &quot;优惠活动&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 44, &quot;Name&quot;: &quot;统计分析&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 45, &quot;Name&quot;: &quot;CA设置&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;, &#123; &quot;Id&quot;: 46, &quot;Name&quot;: &quot;VIP价格&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 5, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot; &#125;]&#125;,&#123; &quot;Id&quot;: 42, &quot;Name&quot;: &quot;预测参数管理&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 1, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 43, &quot;Name&quot;: &quot;优惠活动&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 2, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 44, &quot;Name&quot;: &quot;统计分析&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 3, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 45, &quot;Name&quot;: &quot;CA设置&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 4, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;,&#123; &quot;Id&quot;: 46, &quot;Name&quot;: &quot;VIP价格&quot;, &quot;PId&quot;: 14, &quot;Order&quot;: 5, &quot;Class&quot;: &quot;iconfont icon-tuichu&quot;&#125;]","categories":[{"name":"扁平化数据树形化 ,树形数据扁平化","slug":"扁平化数据树形化-树形数据扁平化","permalink":"https://93qlin.github.io/categories/扁平化数据树形化-树形数据扁平化/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"},{"name":"tree","slug":"tree","permalink":"https://93qlin.github.io/tags/tree/"}]},{"title":"多个连续的箭头函数与柯里化","slug":"多个连续的箭头函数与柯里化","date":"2019-02-28T03:12:12.520Z","updated":"2019-02-28T03:12:12.520Z","comments":true,"path":"2019/02/28/多个连续的箭头函数与柯里化/","link":"","permalink":"https://93qlin.github.io/2019/02/28/多个连续的箭头函数与柯里化/","excerpt":"","text":"高阶函数高阶函数定义：将函数作为参数或者返回值是函数的函数。 所以高阶函数分两种： 是我们常见的 sort,reduce 等函数。返回值是函数的函数。一般而言，我们要理解常见的高阶函数还是很容易的。比如：1234567891011function add(a) &#123; return function(b) &#123; return a + b &#125;&#125;var add3 = add(3)add3(4) === 3 + 4 //trueadd 函数 在 es6 里的写法等价为let add = a =&gt; b =&gt; a + b 其实以上就是 柯里化函数 只不过用 es6 写，变了一个样子，后面详细介绍它的原理和特点。 多个连续的箭头函数but 当一堆箭头函数在你面前的时候，你会不会有一丝犹豫，我在此之前就是一脸懵逼。。。比如我看到下面的 redux-thunk 的源码（没错整个源码只有14行）里的多个连续箭头函数的时候。。。 // 形如1a =&gt; b =&gt; c =&gt; &#123;xxx&#125; 那怎么轻松理解这些箭头干了啥呢，当我看了柯里化后，瞬间就懂了， 多个连续箭头函数就是 es6的多次柯里化的写法 柯里化我们先看 stackoverflow 的关于如何理解多个箭头函数的最高票回答, 他说 这就是柯里化函数。(This is a curried function) wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术 好，现在懂没，我来简单说一下。 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如12let add = x =&gt; y =&gt; x + ylet add2 = add(2) 本来完成 add 这个操作，应该是1let add = (x, y) =&gt; x + y 它需要俩参数，而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。 详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y =&gt; x + y 函数 并且此时 x = 2，所以此时调用1add2(3) === 2 + 3 回归正题1let add = x =&gt; y =&gt; x + y add 函数按照 wiki 的定义可以理解成只柯里化了一次，那么下面这种呢？ a =&gt; b =&gt; c =&gt; {xxx}n 个连续箭头组成的函数实际上就是柯里化了 n - 1次。 具体调用过程如下： 前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值。 结合上文可知，这里的多个连续箭头（无论俩个箭头函数三个及以上）函数连在一起 就是在柯里化。 所以连续箭头函数就是多次柯里化函数的 es6 写法。1let test = a =&gt; b =&gt; c =&gt; &#123;xxx&#125; 调用特点1let test = a =&gt; b =&gt; c =&gt; &#123;xxx&#125; 比如对于上面的 test 函数，它有 3 个箭头， 这个函数要被调用 3 次 test(a)(b)(c)，前两次调用只是在传递参数，只有最后依次调用才会返回 {xxx} 代码段的返回值，并且在 {xxx} 代码段中可以调用 a,b,c 柯里化函数的功能可以惰性求值可以提前传递部分参数出自(https://www.cnblogs.com/xueandsi/p/6032578.html)","categories":[{"name":"多个连续的箭头函数与柯里化","slug":"多个连续的箭头函数与柯里化","permalink":"https://93qlin.github.io/categories/多个连续的箭头函数与柯里化/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://93qlin.github.io/tags/es6/"},{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"}]},{"title":"基础1.5.：面向对象之继承的的七种方式","slug":"基础1.5：面向对象之继承的的七种方式","date":"2019-02-28T03:12:12.520Z","updated":"2019-04-12T12:07:46.453Z","comments":true,"path":"2019/02/28/基础1.5：面向对象之继承的的七种方式/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础1.5：面向对象之继承的的七种方式/","excerpt":"","text":"七种方式： 1 .原型链继承 2 .借用构造函数继承 3 .组合继承 4 .原型式继承 5 .寄生式继承 6 .寄生组合式继承(最佳方式) 7 .混入方式继承多个对象 一.原型链继承基本思想： 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 1.1构造函数、原型和实例的关系： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。我们让原型对象等于另一个类型的实例,此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进,就构成了实例与原型的链条。这就是所谓原型链的基本概念。12345678910111213141516function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //true 1.2搜索机制 上一节中说到，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype；3）1.3确定原型和实例的关系两种方式123alert(instance instanceof Object); //truealert(instance instanceof SuperType); //truealert(instance instanceof SubType); //true 由于原型链的关系，我们可以说 instance 是 Object、SuperType 或SubType中任何一个类型的实例。因此，测试这三个构造函数的结果都返回了 true。第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true，如下所示。123alert(Object.prototype.isPrototypeOf(instance)); //truealert(SuperType.prototype.isPrototypeOf(instance)); //truealert(SubType.prototype.isPrototypeOf(instance)); //true 1.3 谨慎地定义方法 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。来看下面的例子。123456789101112131415161718192021function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();//添加新方法SubType.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;;//重写超类型中的方法SubType.prototype.getSuperValue = function ()&#123; return false;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //false 1.4 缺点(主要两方面) 最主要的问题来自包含引用类型值的原型。上一节说过包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。123456789101112function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType()&#123;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green,black&quot; 当 SubType 通过原型链继承了SuperType 之后，SubType.prototype 就变成了 SuperType 的一个实例，因此它也拥有了一个它自己的 colors 属性——就跟专门创建了一个 SubType.prototype.colors 属性一样。但结果是什么呢？结果是 SubType 的所有实例都会共享这一个 colors 属性。第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。 二.借用构造函数 解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数,即在子类型构造函数的内部调用超类型构造函数。因为，函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和call()方法也可以在（将来）新创建的对象上执行构造函数123456789101112function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType()&#123; //继承了 SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green&quot; 新创建的 SubType 实例的环境下调用了 SuperType 构造函数。这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的 colors 属性的副本了。 2.1. 传递参数 相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。看下面这个例子。12345678910111213function SuperType(name)&#123; this.name = name;&#125;function SubType()&#123; //继承了 SuperType，同时还传递了参数 SuperType.call(this, &quot;Nicholas&quot;); //实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); //&quot;Nicholas&quot;;alert(instance.age); //29 以上代码中的 SuperType 只接受一个参数 name，该参数会直接赋给一个属性。在 SubType 构造函数内部调用 SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。为了确保SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。 2.2. 缺点 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现复用，每个子类都有父类实例函数的副本，影响性能 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。 三 组合继承是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。1234567891011121314151617181920212223242526272829303132function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; //继承属性 // 第二次调用SuperType() SuperType.call(this, name); this.age = age;&#125;// 继承方法// 构建原型链// 第一次调用SuperType()SubType.prototype = new SuperType();// 重写SubType.prototype的constructor属性，指向自己的构造函数SubTypeSubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;;instance2.sayAge(); //27 缺点： 第一次调用SuperType()：给SubType.prototype写入两个属性name，color。第二次调用SuperType()：给instance1写入两个属性name，color。实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。 四 原型式继承 是借助原型可以基于已有的对象创建新对象12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。来看下面的例子。1234567891011var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; 这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是person对象，于是我们把它传入到 object()函数中，然后该函数就会返回一个新对象。这个新对象将person作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friends 不仅属于 person 所有，而且也会被anotherPerson以及yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本。es5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，123456789101112131415Object.create()与 object()方法的行为相同。var person = &#123;name: &quot;Nicholas&quot;,friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; Object.create()方法的第二个参数与Object.defineProperties()(理解对象的定义多个属性)方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如：1234567891011121314var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = Object.create(person, &#123;name: &#123;value: &quot;Greg&quot;&#125;&#125;);alert(anotherPerson.name); //&quot;Greg&quot; 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的缺点： 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。 无法传递参数五 寄生式继承 寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 1234567function createAnother(original)&#123; var clone = object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert(&quot;hi&quot;); &#125;; return clone; //返回这个对象&#125; 123456var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot; 这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person的所有属性和方法，而且还有自己的 sayHi()方法。在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。 缺点（同原型式继承）： 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。 无法传递参数六 寄生组合式继承 结合借用构造函数传递参数和寄生模式实现继承背景 前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。1234567891011121314151617function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); //第二次调用 SuperType() this.age = age;&#125;SubType.prototype = new SuperType(); //第一次调用 SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 加粗字体的行中是调用 SuperType 构造函数的代码。在第一次调用 SuperType 构造函数时，SubType.prototype 会得到两个属性：name 和 colors；它们都是 SuperType 的实例属性，只不过现在位于 SubType 的原型中。当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这一次又在新对象上创建了实例属性 name 和 colors。于是，这两个属性就屏蔽了原型中的两个同名属性。图 6-6 展示了上述过程。有两组 name 和 colors 属性：一组在实例上，一组在 SubType 原型中。（上面有图说明这就是调用两次 SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。12345678910111213141516171819202122232425262728293031323334function inheritPrototype(subType, superType)&#123; var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本 prototype.constructor = subType; // 增强对象，弥补因重写原型而失去的默认的constructor 属性 subType.prototype = prototype; // 指定对象，将新创建的对象赋值给子类的原型&#125;// 父类初始化实例属性和原型属性function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;// 将父类原型指向子类inheritPrototype(SubType, SuperType);// 新增子类原型属性SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new SubType(&quot;xyc&quot;, 23);var instance2 = new SubType(&quot;lxy&quot;, 23);instance1.colors.push(&quot;2&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]instance1.colors.push(&quot;3&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;] 这个例子的高效率体现在它只调用了一次SuperType 构造函数，并且因此避免了在SubType.prototype 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和isPrototypeOf() 这是最成熟的方法，也是现在库实现的方法 七 混入方式继承多个对象123456789101112131415function MyClass() &#123; SuperClass.call(this); OtherSuperClass.call(this);&#125;// 继承一个类MyClass.prototype = Object.create(SuperClass.prototype);// 混合其它Object.assign(MyClass.prototype, OtherSuperClass.prototype);// 重新指定constructorMyClass.prototype.constructor = MyClass;MyClass.prototype.myMethod = function() &#123; // do something&#125;; Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。","categories":[{"name":"基础1.5.：面向对象之继承的的七种方式","slug":"基础1-5-：面向对象之继承的的七种方式","permalink":"https://93qlin.github.io/categories/基础1-5-：面向对象之继承的的七种方式/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"基础1.4：面向对象之创建对象的七种模式","slug":"基础1.4：面向对象之创建对象的七种模式","date":"2019-02-28T03:12:12.519Z","updated":"2019-04-12T12:07:15.259Z","comments":true,"path":"2019/02/28/基础1.4：面向对象之创建对象的七种模式/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础1.4：面向对象之创建对象的七种模式/","excerpt":"","text":"七种模式：1.工厂模式2.构造函数模式3.原型模式4.组合使用构造函数模式和原型模式(最佳)5.动态原型模式6.寄生构造函数模式(和工厂模式差不多)7.稳妥构造函数模式(遵循与寄生构造函数类似的模式) 工厂模式1.工厂模式 考虑到在 ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示：1234567891011 function createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125; return o; &#125; var person1 = createPerson(&apos;Grey&apos;,27,&apos;Doctor&apos;); 函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建\\多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型？）。 什么是对象类型？ JS中，可以将对象分为“内部对象”、“宿主对象”和“自定义对象”三种。 1 内部对象js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError和TypeError。其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。 2 宿主对象宿主对象就是执行JS脚本的环境提供的对象。对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，增加开发难度。浏览器对象有很多，如Window和Document等等。 3 自定义对象顾名思义，就是开发人员自己定义的对象。JS允许使用自定义对象，使JS应用及功能得到扩充。 优点：主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复 缺点：工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例. 构造函数模式二.构造函数模式12345678910function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125; &#125; var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); var person2 = new Person(&apos;Grey&apos;,27,&apos;Doctor&apos;); 不同： 1 没有显式地创建对象 2 直接将属性和方法赋给了 this 对象 3 没有 return 语句 经历的步骤 (1) 创建一个新对象； (2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）； (3) 执行构造函数中的代码（为这个新对象添加属性）； (4) 返回新对象。 person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person，如下所示。12alert(person1.constructor == Person); //truealert(person2.constructor == Person); //true 对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person的实例，这一点通过 instanceof 操作符可以得到验证。1234alert(person1 instanceof Object); //truealert(person1 instanceof Person); //truealert(person2 instanceof Object); //truealert(person2 instanceof Person); //true 优点：实例标识为一种特定的类型，即知道person1（person2）是Person对象的实例 弊端：也就是说相同的Person实例都有不同Function的实例，造成作用域链和标识符解析不同。如：1alert(person1.sayName == person2.sayName); //false 原型模式三.原型模式 prototype（原型）属性：我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。12345678910111213function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //&quot;Nicholas&quot;var person2 = new Person();person2.sayName(); //&quot;Nicholas&quot;alert(person1.sayName == person2.sayName); //true 与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1 和 person2访问的都是同一组属性和同一个sayName()函数。要理解原型模式的工作原理，必须先理解 ECMAScript 中原型对象的性质。 1. 理解原型对象? 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说，Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。 创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从 Object继承而来的。m 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari和Chrome在每个对象上都支持一个属性proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。前面使用Person构造函数和Person.prototype创建实例的代码为例，下图展示了各个对象之间的关系。 虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。 isPrototypeOf(): 虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用 isPrototypeOf()方法的对象（Person.prototype），那么这个方法就返回 true，如下所示：12alert(Person.prototype.isPrototypeOf(person1)); //truealert(Person.prototype.isPrototypeOf(person2)); //true ES5:Object.getPrototypeOf() ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。例如：12alert(Object.getPrototypeOf(person1) == Person.prototype); //truealert(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot; 这里的第一行代码只是确定 Object.getPrototypeOf()返回的对象实际就是这个对象的原型。第二行代码取得了原型对象中 name 属性的值，也就是”Nicholas”。使用 Object.getPrototypeOf()可以方便地取得一个对象的原型 查找对象属性的过程 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值.这正是多个对象实例共享原型所保存的属性和方法的基本原理。 注意：前面提到过，原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问 前面的构造函数模式说person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person 问题这个constructor属性到底是在实例中还是在构造函数中？尝试解答1alert(person1.hasOwnProperty(&quot;constructor&quot;)); //false 以上说明person1的constructor（构造函数）属性不是实例属性 （1）.通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值（2）.如果在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。（3）.修改后的例子中，我们使用 delete 操作符删除了 person1.name，之前它保存的”Greg”值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 name 属性的连接。123456789101112131415function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = &quot;Greg&quot;;alert(person1.name); //&quot;Greg&quot;——来自实例alert(person2.name); //&quot;Nicholas&quot;——来自原型delete person1.name;alert(person1.name); //&quot;Nicholas&quot;——来自原型 hasOwnProperty()方法 使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。来看下面这个例子。12345678910111213141516171819function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();alert(person1.hasOwnProperty(&quot;name&quot;)); //falseperson1.name = &quot;Greg&quot;;alert(person1.name); //&quot;Greg&quot;——来自实例alert(person1.hasOwnProperty(&quot;name&quot;)); //truealert(person2.name); //&quot;Nicholas&quot;——来自原型alert(person2.hasOwnProperty(&quot;name&quot;)); //falsedelete person1.name;alert(person1.name); //&quot;Nicholas&quot;——来自原型alert(person1.hasOwnProperty(&quot;name&quot;)); //false ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()方法。 2. 原型与 in 操作符 有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。看一看下面的例子。1234567891011121314151617181920212223function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();alert(person1.hasOwnProperty(&quot;name&quot;)); //falsealert(&quot;name&quot; in person1); //trueperson1.name = &quot;Greg&quot;;alert(person1.name); //&quot;Greg&quot; ——来自实例alert(person1.hasOwnProperty(&quot;name&quot;)); //truealert(&quot;name&quot; in person1); //truealert(person2.name); //&quot;Nicholas&quot; ——来自原型alert(person2.hasOwnProperty(&quot;name&quot;)); //falsealert(&quot;name&quot; in person2); //truedelete person1.name;alert(person1.name); //&quot;Nicholas&quot; ——来自原型alert(person1.hasOwnProperty(&quot;name&quot;)); //falsealert(&quot;name&quot; in person1); //true 无论该属性存在于实例中还是存在于原型中。同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中，如下所示。123function hasPrototypeProperty(object, name)&#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; 由于 in 操作符只要通过对象能够访问到属性就返回 true，hasOwnProperty()只在属性存在于实例中时才返回 true，因此只要 in 操作符返回 true 而 hasOwnProperty()返回 false，就可以确定属性是原型中的属性。下面来看一看上面定义的函数 hasPrototypeProperty()的用法。123456789101112function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person = new Person();alert(hasPrototypeProperty(person, &quot;name&quot;)); //trueperson.name = &quot;Greg&quot;;alert(hasPrototypeProperty(person, &quot;name&quot;)); //false 在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了(重写或其他)原型中不可枚举属性（即将[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在 IE8 及更早版本中例外。IE 早期版本的实现中存在一个 bug，即屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中。例如：12345678910var o = &#123; toString : function()&#123; return &quot;My Object&quot;; &#125;&#125;;for (var prop in o)&#123; if (prop == &quot;toString&quot;)&#123; alert(&quot;Found toString&quot;); //在 IE 中不会显示 &#125;&#125; 这里的对象 o 定义了一个名为 toString()的方法，该方法屏蔽了原型中（不可枚举）的 toString()方法。在 IE 中，由于其实现认为原型的 toString()方法被打上了值为 false 的[[Enumerable]]标记，因此应该跳过该属性，结果我们就不会看到警告框。该 bug 会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和 valueOf()。ECMAScript 5 也将 constructor 和 prototype 属性的[[Enumerable]]特性设置为 false，但并不是所有浏览器都照此实现。 Object.keys() 这个方法可以取得对象上所有可枚举的实例属性，接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如：123456789101112131415function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var keys = Object.keys(Person.prototype);alert(keys); //&quot;name,age,job,sayName&quot;var p1 = new Person();p1.name = &quot;Rob&quot;;p1.age = 31;var p1keys = Object.keys(p1);alert(p1keys); //&quot;name,age 变量 keys 中将保存一个数组，数组中是字符串”name”、”age”、”job”和”sayName”。这个顺序也是它们在 for-in 循环中出现的顺序。如果是通过 Person 的实例调用，则 Object.keys()返回的数组只包含”name”和”age”这两个实例属性。如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()方法。12var keys = Object.getOwnPropertyNames(Person.prototype);alert(keys); //&quot;constructor,name,age,job,sayName&quot; 注意结果中包含了不可枚举的 constructor 属性。Object.keys()和 Object.getOwnProperty￾Names()方法都可以用来替代 for-in 循环。支持这两个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera12+和 Chrome。 更简单的原型语法 每添加一个属性和方法就要敲一遍 Person.prototype。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。 12345678910function Person()&#123;&#125;Person.prototype = &#123; name : &quot;Nicholas&quot;, age : 29, job: &quot;Software Engineer&quot;, sayName : function () &#123; alert(this.name); &#125;&#125;; 将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时，尽管 instanceof操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了，如下所示。12345var friend = new Person();alert(friend instanceof Object); //truealert(friend instanceof Person); //truealert(friend.constructor == Person); //falsealert(friend.constructor == Object); //true 解决方法： 在此，用 instanceof 操作符测试 Object 和 Person 仍然返回 true，但 constructor 属性则等于 Object 而不等于 Person 了。如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。1234567891011function Person()&#123;&#125;Person.prototype = &#123; constructor : Person, name : &quot;Nicholas&quot;, age : 29, job: &quot;Software Engineer&quot;, sayName : function () &#123; alert(this.name); &#125;&#125;; 又有个问题： 以上代码特意包含了一个 constructor 属性，并将它的值设置为 Person，从而确保了通过该属性能够访问到适当的值。注意，以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty()。12345678910function Person()&#123;&#125;Person.prototype = &#123; name : &quot;Nicholas&quot;, age : 29, job : &quot;Software Engineer&quot;, sayName : function () &#123; alert(this.name); &#125;&#125;; //重设构造函数，只适用于 ECMAScript 5 兼容的浏览器Object.defineProperty(Person.prototype, “constructor”, { enumerable: false, value: Person});4. 原型的动态性 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。请看下面的例子。12345var friend = new Person();Person.prototype.sayHi = function()&#123; alert(&quot;hi&quot;);&#125;;friend.sayHi(); //&quot;hi&quot;（没有问题！） 以上代码先创建了 Person 的一个实例，并将其保存在 person 中。然后，下一条语句在 Person.prototype 中添加了一个方法 sayHi()。即使 person 实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 person.sayHi()时，首先会在实例中搜索名为 sayHi 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数。尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。1234567891011121314function Person()&#123;&#125;var friend = new Person();Person.prototype = &#123; constructor: Person, name : &quot;Nicholas&quot;, age : 29, job : &quot;Software Engineer&quot;, sayName : function () &#123; alert(this.name); &#125;&#125;;friend.sayName(); //error 在这个例子中，我们先创建了 Person 的一个实例，然后又重写了其原型对象。然后在调用friend.sayName()时发生了错误，因为 friend 指向的原型中不包含以该名字命名的属性。图 6-3 展示了这个过程的内幕。 从图 6-3 可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。5. 原生对象的原型原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。例如，在 Array.prototype 中可以找到 sort()方法，而在 String.prototype 中可以找到substring()方法，如下所示。12alert(typeof Array.prototype.sort); //&quot;function&quot;alert(typeof String.prototype.substring); //&quot;function&quot; 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String 添加了一个名为 startsWith()的方法。12345String.prototype.startsWith = function (text) &#123; return this.indexOf(text) == 0;&#125;;var msg = &quot;Hello world!&quot;;alert(msg.startsWith(&quot;Hello&quot;)); //true 这里新定义的 startsWith()方法会在传入的文本位于一个字符串开始时返回 true。既然方法被添加给了 String.prototype，那么当前环境中的所有字符串就都可以调用它。由于 msg 是字符串，而且后台会调用 String 基本包装函数创建这个字符串，因此通过 msg 就可以调用 startsWith()方法。 缺点6. 原型对象的问题 原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。123456789101112131415161718function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name : &quot;Nicholas&quot;, age : 29, job : &quot;Software Engineer&quot;, friends : [&quot;Shelby&quot;, &quot;Court&quot;], sayName : function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(&quot;Van&quot;);alert(person1.friends); //&quot;Shelby,Court,Van&quot;alert(person2.friends); //&quot;Shelby,Court,Van&quot;alert(person1.friends === person2.friends); //true 假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。 组合使用构造函数模式和原型模式四.组合使用构造函数模式和原型模式组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子。12345678910111213141516171819function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; alert(this.name); &#125;&#125;var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.friends.push(&quot;Van&quot;);alert(person1.friends); //&quot;Shelby,Count,Van&quot;alert(person2.friends); //&quot;Shelby,Count&quot;alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法 sayName()则是在原型中定义的。而修改了 person1.friends（向其中添加一个新字符串），并不会影响到 person2.friends，因为它们分别引用了不同的数组。这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 动态原型模式五. 动态原型模式 有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。来看一个例子。12345678910111213141516function Person(name, age, job)&#123; //属性 this.name = name; this.age = age; this.job = job;//方法 if (typeof this.sayName != &quot;function&quot;)&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); 注意构造函数代码中加粗的部分。这里只在 sayName()方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可以说非常完美。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用 instanceof 操作符确定它的类型。 使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 寄生构造函数模式(和工厂模式差不多)六.寄生构造函数模式(和工厂模式差不多) 通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。123456789101112function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); //&quot;Nicholas&quot; 在这个例子中，Person 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。123456789101112131415function SpecialArray()&#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values, arguments); //添加方法 values.toPipedString = function()&#123; return this.join(&quot;|&quot;); &#125;; //返回数组 return values;&#125;var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);alert(colors.toPipedString()); //&quot;red|blue|green&quot; 关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。 稳妥构造函数模式(遵循与寄生构造函数类似的模式)七.稳妥构造函数模式(遵循与寄生构造函数类似的模式) 道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的 Person 构造函数重写如下。12345678910111213function Person(name, age, job)&#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function()&#123; alert(name); &#125;; //返回对象 return o;&#125; 注意，在以这种模式创建的对象中，除了使用 sayName()方法之外，没有其他办法访问 name 的值。可以像下面使用稳妥的 Person 构造函数。12var friend = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); //&quot;Nicholas&quot; 这样，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境——例如，ADsafe（www.adsafe.org）和 Caja（http://code.google.com/p/google-caja/）提供的环境——下使用。与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有意义。","categories":[{"name":"基础1.4：面向对象之创建对象的七种模式","slug":"基础1-4：面向对象之创建对象的七种模式","permalink":"https://93qlin.github.io/categories/基础1-4：面向对象之创建对象的七种模式/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"基础4.1：js内存与内存泄漏","slug":"基础4.1：js内存与内存泄漏","date":"2019-02-28T03:12:12.518Z","updated":"2019-04-12T03:04:13.673Z","comments":true,"path":"2019/02/28/基础4.1：js内存与内存泄漏/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础4.1：js内存与内存泄漏/","excerpt":"","text":"","categories":[{"name":"基础4.1：js内存与内存泄漏","slug":"基础4-1：js内存与内存泄漏","permalink":"https://93qlin.github.io/categories/基础4-1：js内存与内存泄漏/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"2.2作用域与作用域链","slug":"基础2.2：作用域和作用域链","date":"2019-02-28T03:12:12.518Z","updated":"2019-04-12T08:49:10.449Z","comments":true,"path":"2019/02/28/基础2.2：作用域和作用域链/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础2.2：作用域和作用域链/","excerpt":"","text":"1.作用域？ 变量a的作用域是什么？一会儿又问：函数a的作用域是什么？变量和函数的作用域分别是啥玩意？我们先来看看“作用域”是什么意思，“作用域”拆开来就是“作用”和“域”12作用：访问、操作、调用……域：区域、范围、空间…… 作用域: 就是变量和函数的可访问范围，或者说变量或函数起作用的区域。 1.javascript函数的作用域： 函数内的区域，就是这个函数的作用域，变量和函数在这个区域都可以访问操作。最外层函数外的区域叫全局作用域，函数内的区域叫局部作用域。 2.javascript变量的作用域： 在源代码中变量所在的区域，就是这个变量的作用域，变量在这个区域内可以被访问操作。在全局作用域上定义的变量叫全局变量，在函数内定义的变量叫局部变量。简单地理解，JS源代码被函数{ }划分成一块一块的区域，这些区域换个身份就是某函数或某变量的作用域，变量的作用域和函数的作用域在源代码中有可能指的是同一块区域。 2.作用域链作用域链（Scope Chain）是javascript内部中一种变量、函数查找机制，它决定了变量和函数的作用范围，即作用域链作用域链的形成原理，通过1999年的ECMAScript-262-3th第三版来说明作用域链的形成原理，将会介绍执行环境，变量对象和活动对象，arguments对象，作用域链等几个概念。2009年发布了ECMAScript-262-5th第五版，不同的是取消了变量对象和活动对象等概念，引入了词法环境（Lexical Environments）、环境记录（EnviromentRecord）等新的概念，所以两个版本的概念不要混淆了。","categories":[{"name":"2.2作用域与作用域链","slug":"2-2作用域与作用域链","permalink":"https://93qlin.github.io/categories/2-2作用域与作用域链/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"}]},{"title":"基础1.3：面向对象之理解对象","slug":"基础1.3：面向对象之理解对象","date":"2019-02-28T03:12:12.518Z","updated":"2019-04-12T12:06:44.389Z","comments":true,"path":"2019/02/28/基础1.3：面向对象之理解对象/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础1.3：面向对象之理解对象/","excerpt":"","text":"一.理解对象属性&emsp;1. 属性类型&emsp;2. 数据属性&emsp;3. 访问器属性二.多个属性三.读取属性的特性 理解对象属性 属性类型 首先理解特性与属性的关系?特性是内部值，描述了属性的特征，ECMA-262第五版把特性放在两对方括号中 数据属性 包含一个数据值的位置，这个位置可以读取和写入值，数据属性有4个描述其行为的特性。 [[Configurable]] 能否通过delete删除属性而定义新属性，能否修改属性的特性，能否把属性设置为访问器属性。直接在对象上定义的属性默认为true。 [[Enumberable]] 能否通过for-in循环返回属性，直接在对象上定义的属性默认为true。 [[Writeable]] 能否修改属性的值 直接在对象上定义的属性默认为true。 [[Value]] 包含这个属性的数据值，这个特性默认为undefined。Object.defineProperty()方法要修改这四个，默认属性必须使用这个方法这个方法接受三个参数（”属性所在的对象”，”属性的名字”，描述符对象），其中描述符对象属性必须是上面四个的一个或多个。可以修改对应的特性值。 访问器属性它不包含数据值，包含getter和setter(这两个 不是必须的)，在读取访问器属性时会调用getter函数，在写入访问器属性时会调用setter函数并传入新值，负责处理数据。 [[Configurable]] 能否通过delete删除属性而定义新属性，能否修改属性的特性，能否把属性设置为数据属性。直接在对象上定义的属性默认为true。 [[Enumberable]] 能否通过for-in循环返回属性，直接在对象上定义的属性默认为true。 [[Get]] 读取属性时调用的函数，默认undefined。 [[Value]] 设置属性时调用的函数，默认undefined。1234567891011121314151617var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, &quot;year&quot;, &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 以上代码创建了一个 book 对象，并给它定义两个默认的属性：_year 和 edition._year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性 year 则包含一个getter 函数和一个 setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此，把 year 属性修改为 2005 会导致_year 变成 2005，而 edition 变为 2。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。 多个属性Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例如：1234567891011121314151617181920var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;); 以上代码在 book对象上定义了两个数据属性（_year 和 edition）和一个访问器属性（year）。最终的对象与上一节中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。支持 Object.defineProperties()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。 读取属性的特性Object.getOwnPropertyDescriptor()可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。例如：12345678910111213141516171819202122232425262728var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;);var descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(typeof descriptor.get); //&quot;undefined&quot;var descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);alert(descriptor.value); //undefinedalert(descriptor.enumerable); //falsealert(typeof descriptor.get); //&quot;function&quot; 对于数据属性_year，value 等于最初的值，configurable 是 false，而 get 等于 undefined。对于访问器属性 year，value 等于 undefined，enumerable 是 false，而 get 是一个指向 getter函数的指针。在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 Object.getOwnPropertyDescriptor()方法。支持这个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 总结：本节应该知道以下三点： 属性类型。 定义多个属性 读取属性特性","categories":[{"name":"基础1.3：面向对象之理解对象","slug":"基础1-3：面向对象之理解对象","permalink":"https://93qlin.github.io/categories/基础1-3：面向对象之理解对象/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"this","slug":"基础2.4：this","date":"2019-02-28T03:12:12.518Z","updated":"2019-02-28T03:12:12.518Z","comments":true,"path":"2019/02/28/基础2.4：this/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础2.4：this/","excerpt":"","text":"http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html先来一道题12345678910111213141516var a = 10;//全局变量 值为10 function foo() &#123; console.log(this)//此处this一直指向window, 所以this.a一直是10 console.log(a); //a全局变量 打印10 &#125; (function() &#123;//自执行函数 此处this指代window,自执行函数其实是window对象调用它！函数分普通函数和构造函数普通函数的this指向window，构造函数的this指向它本身，谁调用它this就指向谁！ var a = 20; console.log(this.a)//10 foo();//依然打印10 &#125;)(); (function (func) &#123;//自执行函数 此处this指代window var a = 30; console.log(this.a)//10 func();//依然打印10 &#125;)(foo)","categories":[{"name":"this","slug":"this","permalink":"https://93qlin.github.io/categories/this/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"基础2.3：闭包,作用域链理解闭包","slug":"基础2.3：闭包，作用域链理解闭包","date":"2019-02-28T03:12:12.518Z","updated":"2019-04-12T03:02:11.775Z","comments":true,"path":"2019/02/28/基础2.3：闭包，作用域链理解闭包/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础2.3：闭包，作用域链理解闭包/","excerpt":"","text":"定义简洁版：保护一个可重用的局部变量的词法结构","categories":[{"name":"基础2.3：作用域链，作用域链理解闭包","slug":"基础2-3：作用域链，作用域链理解闭包","permalink":"https://93qlin.github.io/categories/基础2-3：作用域链，作用域链理解闭包/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"基础3.1：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！","slug":"基础3.1：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！","date":"2019-02-28T03:12:12.518Z","updated":"2019-04-12T03:03:29.741Z","comments":true,"path":"2019/02/28/基础3.1：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础3.1：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！/","excerpt":"","text":"","categories":[{"name":"基础3.1：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！","slug":"基础3-1：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！","permalink":"https://93qlin.github.io/categories/基础3-1：从输入URL到页面加载的过程？由一道题完善自己的前端知识体系！/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"基础1.2：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理","slug":"基础1.1：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理","date":"2019-02-28T03:12:12.517Z","updated":"2019-02-28T03:12:12.517Z","comments":true,"path":"2019/02/28/基础1.1：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础1.1：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理/","excerpt":"","text":"","categories":[{"name":"基础1.2：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理","slug":"基础1-2：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理","permalink":"https://93qlin.github.io/categories/基础1-2：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"图片上传","slug":"图片上传","date":"2019-02-28T03:12:12.517Z","updated":"2019-02-28T03:12:12.517Z","comments":true,"path":"2019/02/28/图片上传/","link":"","permalink":"https://93qlin.github.io/2019/02/28/图片上传/","excerpt":"","text":"图片上传（https://blog.csdn.net/qq_29712995/article/details/78839093）安装axios的话： 1利用npm安装npm install axios –save 2使用ES6的写法引入import axios from ‘axios’我们可能会想，如何使用axios上传照片：一般情况上传照片有两种方式： 1.本地图片转换成base64，然后通过普通的post请求发送到服务端。操作简单，适合小图，以及如果想兼容低版本的ie没办法用此方法，还有就是最近我想应用到微信小程序中，发现小程序目前还不可以将图片转换为base64. 以下是我的代码 HTML代码：1&lt;input accept=&quot;image/*&quot; name=&quot;img&quot; id=&quot;upload_file&quot; type=&quot;file&quot;&gt; JS代码：123456var file = document.getElementById(&quot;upload_file&quot;).files[0];var r = new FileReader(); //本地预览r.onload = function()&#123; console.log(r.result);//图片的base64&#125;r.readAsDataURL(file); //Base64 2.通过form表单提交。 form表单提交图片会刷新页面，也可以是form绑定到一个隐藏的iframe上，可以实现无刷新提交数据。 HTML代码：1&lt;input accept=&quot;image/*&quot; name=&quot;img&quot; id=&quot;upload_file&quot; type=&quot;file&quot;&gt; JS代码：1234import axios from &apos;axios&apos;var file = document.getElementById(&quot;upload_file&quot;).files[0];var formdata1=new FormData();// 创建form对象formdata1.append(&apos;img&apos;,file,file.name);// 通过append向form对象添加数据,可以通过append继续添加数据//或formdata1.append(‘img’,file);123456let config = &#123; headers:&#123;&apos;Content-Type&apos;:&apos;multipart/form-data&apos;&#125;&#125;; //添加请求头axios.post(&apos;/xapi/upimage&apos;,formdata1,config).then(response)=&gt;&#123; //这里的/xapi/upimage为接口 console.log(response.data);&#125;) 这里注意的是，设置 的==Content-Type==查看是否成功：按F12-network-点击对应的那个请求可以看到","categories":[{"name":"图片上传","slug":"图片上传","permalink":"https://93qlin.github.io/categories/图片上传/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"}]},{"title":"单页面多路由","slug":"单页面多路由","date":"2019-02-28T03:12:12.517Z","updated":"2019-02-28T03:12:12.517Z","comments":true,"path":"2019/02/28/单页面多路由/","link":"","permalink":"https://93qlin.github.io/2019/02/28/单页面多路由/","excerpt":"","text":"“单页面多路由区域操作”，实际需求是这样的，在一个页面里我们有2个以上区域，我们通过配置路由的js文件，来操作这些区域的内容。例如我们在src/App.vue里加上两个标签。我们用vue-cli建立了新的项目，并打开了src目录下的App.vue文件，在下面新写了两行标签,并加入了些CSS样式。 123&lt;router-view &gt;&lt;/router-view&gt;&lt;router-view name=&quot;left&quot; style=&quot;float:left;width:50%;background-color:#ccc;height:300px;&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;right&quot; style=&quot;float:right;width:50%;background-color:#c0c;height:300px;&quot;&gt;&lt;/router-view&gt; 现在的页面中有了三个标签，也就是说我们需要在路由里配置这三个区域，配置主要是在components字段里进行。12345678910111213141516171819202122232425262728import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import Hello from &apos;@/components/Hello&apos;import Hi1 from &apos;@/components/Hi1&apos;import Hi2 from &apos;@/components/Hi2&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; default:Hello, left:Hi1, right:Hi2 &#125; &#125;,&#123; path: &apos;/Hi&apos;, components: &#123; default:Hello, left:Hi2, right:Hi1 &#125; &#125; ]&#125;) 上边的代码我们编写了两个路径，一个是默认的‘/’，另一个是’/Hi’.在两个路径下的components里面，我们对三个区域都定义了显示内容。定义好后，我们需要在component文件夹下，新建Hi1.vue和Hi2.vue页面就可以了。1234567891011121314151617Hi1.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;hi1&apos;, data () &#123; return &#123; msg: &apos;I am Hi1 page.&apos; &#125; &#125;&#125;&lt;/script&gt; 1234567891011121314151617Hi2.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;hi2&apos;, data () &#123; return &#123; msg: &apos;I am Hi2 page.&apos; &#125; &#125;&#125;&lt;/script&gt; 最后在App.vue中配置我们的就可以了 ` 首页 Hi页面","categories":[{"name":"单页面多路由","slug":"单页面多路由","permalink":"https://93qlin.github.io/categories/单页面多路由/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://93qlin.github.io/tags/vue/"}]},{"title":"判断数据类型","slug":"判断数据类型","date":"2019-02-28T03:12:12.517Z","updated":"2019-02-28T03:12:12.517Z","comments":true,"path":"2019/02/28/判断数据类型/","link":"","permalink":"https://93qlin.github.io/2019/02/28/判断数据类型/","excerpt":"","text":"使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下：1.判断基本类型：12345Object.prototype.toString.call(null);//”[object Null]”Object.prototype.toString.call(undefined);//”[object Undefined]”Object.prototype.toString.call(“abc”);//”[object String]”Object.prototype.toString.call(123);//”[object Number]”Object.prototype.toString.call(true);//”[object Boolean]” 2.判断原生引用类型：函数类型12Function fn()&#123;console.log(“test”);&#125;Object.prototype.toString.call(fn);//”[object Function]” 日期类型12var date = new Date();Object.prototype.toString.call(date);//”[object Date]” 数组类型12var arr = [1,2,3];Object.prototype.toString.call(arr);//”[object Array]” 正则表达式12var reg = /[hbc]at/gi;Object.prototype.toString.call(arr);//”[object Array]” 自定义类型123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person(&quot;Rose&quot;, 18);Object.prototype.toString.call(arr); //”[object Object]” 很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示：console.log(person instanceof Person);//输出结果为true3.判断原生JSON对象： var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON);console.log(isNativeJSON);//输出结果为”[object JSON]”说明JSON是原生的，否则不是； 注意：Object.prototype.toString()本身是允许被修改的，而我们目前所讨论的关于Object.prototype.toString()这个方法的应用都是假设toString()方法未被修改为前提的。","categories":[{"name":"判断数据类型","slug":"判断数据类型","permalink":"https://93qlin.github.io/categories/判断数据类型/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"}]},{"title":"基础1.1:变量（变量提升,暂时性死区）、执行环境、执行栈","slug":"基础1.2：变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链","date":"2019-02-28T03:12:12.517Z","updated":"2019-04-14T13:36:57.110Z","comments":true,"path":"2019/02/28/基础1.2：变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链/","link":"","permalink":"https://93qlin.github.io/2019/02/28/基础1.2：变量（变量提升,暂时性死区）、执行（上下文）环境、执行栈、事件循环机制、作用域、作用域链/","excerpt":"","text":"一·变量提升首先两个打印例子123a = &apos;ghostwu&apos;;var a;console.log( a ); //ghostwu 12console.log( a );var a = &apos;ghostwu&apos;; //undefined why? 首先:明确两点 javascript代码并不是一行一行往下执行的. javascript执行分为2个步骤:1.编译(词法解释/预解释) 2.执行 其次:当我们碰到 var a = “ghostwu” 定义一个变量的时候， 其实js把这句话看成是2个阶段的事, var a 发生在==编译==阶段， a = ‘ghostwu’发生在执行阶段. 然后 var a会被提升到当前作用域的最前面, a = ‘ghostwu’留在原地==等待执行==阶段，所以： 1234567a = &apos;ghostwu&apos;;var a;console.log( a );// 上面这段代码经过编译之后，变成下面这样var a; //被提升到当前作用域的最前面a = &apos;ghostwu&apos;; //留在原地，等待执行console.log( a ); 123456console.log( a );var a = &apos;ghostwu&apos;;//上面这段代码,经过编译之后，变成下面这样var a;console.log( a );a = &apos;ghostwu&apos;; 明确函数定义的两种方式 12345678//函数声明, 形如:function show()&#123; console.log( &apos;函数声明方式&apos; );&#125;//函数表达式, 形如:var show = function()&#123; console.log( &apos;表达式方式&apos; );&#125; 因为表达式和函数声明，在编译阶段，会产生不同的解释效果。12345show(); //undefinedfunction show()&#123; console.log( a ); var a = &apos;ghostwu&apos;;&#125; 函数声明会被提升 所以，上面的代码，经过编译之后，就变成了下面这样： 123456function show()&#123; //函数声明被提升到 当前作用域的最前面 var a; //var声明被提升到当前作用域的最前面, 注意，它不会提升到函数的外面, 因为当前的作用域是在函数中 console.log( a ); a = &apos;ghostwu&apos;;&#125;show(); 函数表达式，是不会提升的, 看下面的例子:123456789show(); //报错,show is not a functionvar show = function()&#123;console.log( &apos;ghostwu&apos; );&#125;//对于上面这段表达式代码，经过编译之后:var show;show(); //执行之后就是 undefined, 所以在表达式定义之前，调用函数报错了show = function()&#123;console.log( &apos;ghostwu&apos; ); 12345678show(); //你好var show;function show()&#123; console.log( &apos;你好&apos; );&#125;show = function()&#123; console.log( &apos;hello&apos; );&#125; 上面的例子为什么是你好？因为： 当出现同名的函数声明，变量声明的时候， 函数声明会被优先提升，变量声明会被忽略。 所以经过编译之后，就变成:12345678function show()&#123; console.log( &apos;你好&apos; );&#125;show(); //你好show = function()&#123; console.log( &apos;hello&apos; );&#125;show();//如果这里在调用一次，就是hello, 因为show函数体在执行阶段 被 重新赋值了 如果有同名的函数声明，后面的会覆盖前面的，如下:1234567891011121314151617181920show(); //how are youvar show;function show()&#123; console.log( &apos;hello&apos; );&#125; show = function()&#123; console.log( &apos;你好&apos; );&#125;function show()&#123; console.log( &apos;how are you!&apos; );&#125;//上面的代码经过编译之后，变成如下形式:function show()&#123; console.log( &apos;how are you!&apos; );&#125;show(); //how are youshow = function()&#123; console.log( &apos;你好&apos; );&#125;show(); //如果在这里再执行一次，结果：你好 暂时性死区我们都知道，var声明的变量会有变量提升的作用，如下1234console.log(a); //1var a=1;console.log(b); //undefinedvar b; 可以看出，虽然代码中console调用a在前，声明a在后，但是由于在js中，函数及变量的声明都将被提升到函数的最顶部，也就是说（var声明的）变量可以先使用再声明。 然后，使用let，const（后面会提及）声明的变量却不存在变量提升。12345console.log(foo); // Uncaught ReferenceError: foo is not definedlet foo = 2;console.log(foo1); // Uncaught ReferenceError: foo1 is not definedlet foo1; ES6明确规定，如果区块中存在let命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。所以在代码块内，使用let,const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 注：“暂时性死区”也意味着typeof不再是一个百分之百安全的操作，因为会使typeof报错。 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let和 const的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。let不允许在相同作用域内，重复声明同一个变量。1234567891011121314if (true) &#123; let aa; let aa; // Uncaught SyntaxError: Identifier &apos;aa&apos; has already been declared&#125;if (true) &#123; var _aa; let _aa; // Uncaught SyntaxError: Identifier &apos;_aa&apos; has already been declared&#125;if (true) &#123; let aa_; var aa_; // Uncaught SyntaxError: Identifier &apos;aa_&apos; has already been declared&#125; 全局变量 vs 全局对象的属性 ES5中全局对象的属性与全局变量基本是等价的，但是也有区别，比如通过var声明的全局变量不能使用delete从 window/global （ global是针对与node环境）上删除，不过在变量的访问上基本等价。 ES6 中做了严格的区分，使用 var 和 function 声明的全局变量依旧作为全局对象的属性，使用 let, const 命令声明的全局变量不属于全局对象的属性。1234567let let_test = &apos;test&apos;;console.log(window.let_test); // undefinedconsole.log(this.let_test); // undefinedvar var_test = &apos;test&apos;;console.log(window.var_test); // testconsole.log(this.var_test); // test const 除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（常量）。使用const声明变量的时候，必须同时赋值，否则会报错。并且之后任何试图修改值的操作都会引起错误.1const data; //Uncaught SyntaxError: Missing initializer in const declaration 12345678if (true) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常 ! b = 4; // Uncaught TypeError: Assignment to constant variable.&#125;console.log( a ); // 3console.log( b ); // Uncaught ReferenceError: b is not defined 注：复合类型const变量保存的是引用。因为复合类型的常量不指向数据，而是指向数据(heap)所在的地址(stack)，所以通过 const 声明的复合类型只能保证其地址引用不变，但不能保证其数据不变。12345const arr= [1, 2];// 修改数据而不修改引用地址，正确执行arr.push(3); // [1, 2, 3]// 修改 arr 常量所保存的地址的值，报错arr = []; // Uncaught TypeError: Assignment to constant variable. 简单的使用const无法完成对象的冻结。可以通过Object.freeze()方法实现对对象的冻结。使用Object.freeze()方法返回的对象将不能对其属性进行配置(definedProperty()不可用)同时不能添加新的属性和移除(remove)已有属性。彻底冻结对象时需要递归的对它的对象属性进行冻结。12345678910111213141516171819let obj = &#123; a: 1, b: &#123; b1: 2 &#125;&#125;;obj.b.b1 = 3;console.log(obj.b.b1 ); //3function freeze(obj)&#123; Object.freeze(obj); Object.values(obj).forEach(function (value,index) &#123; if(typeof value === &apos;object&apos;)&#123; freeze(value); &#125; &#125;)&#125;freeze(obj);obj.b.b1 = 4;console.log(obj.b.b1); //3 二：执行环境什么是js的”执行环境”？ 执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其它数据，决定了各自的行为。每个执行环境中包含这三部分：变量对象/活动对象，作用域链，this的值,当JavaScript代码执行的时候，会进入不同的执行环境，这些不同的执行环境就构成了执行环境栈。 执行环境的类型 执行环境总共有三种类型1.全局执行环境：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。2.函数执行环境：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行环境。3.Eval 函数执行环境： 指的是运行在 eval 函数中的代码，不用很少用而且不建议使用。 执行栈 用于存储在代码执行期间创建的所有执行环境。 JavaScript解释器在浏览器中是单线程的（下面再说进程和线程），这意味着浏览器在同一时间内只执行一个事件，对于其他的事件我们把它们排队在一个称为 执行栈的地方。下表是一个单线程栈的抽象视图。 当浏览器第一次加载你的script，它默认的进了全局执行环境。如果在你的全局代码中你调用了一个函数，那么顺序流就会进入到你调用的函数当中，创建一个新的执行环境并且把这个环境添加到执行栈的顶部。如果在当前的函数中调用了其他函数，同样的事会再次发生。执行流进入内部函数，并且创建一个新的执行环境，把它添加到已经存在的执行栈的顶部。浏览器始终执行当前在栈顶部的执行环境。一旦函数完成了当前的执行环境，它就会被弹出栈的顶部, 把控制权返回给当前执行环境的下个执行环境。下面例子展示了一个递归函数和该程序的执行栈：12345678(function foo(i) &#123;if (i === 3) &#123;return;&#125;else &#123;foo(++i);&#125;&#125;(0)); 这段代码简单地调用了自己三次，由1递增i的值。每次函数foo被调用，一个新的执行环境就会被调用。一旦一个环境完成了执行，它就会被弹出执行栈并且把控制权返回给当前执行环境的下个执行环境直到再次到达全局执行环境。 记住执行栈，有五个关键点 单线程 同步执行 一个全局环境 无限的函数环境 函数被调用就会创建一个新的执行环境，甚至调用自己。 执行环境的详情 一个函数被调用就会创建一个新的执行环境。然而解释器的内部，每次调用执行环境会有两个阶段： 创建阶段 当函数被调用，但是为执行内部代码之前: 创建一个作用域链。 创建变量，函数和参数。 确定this的值。 激活/代码执行阶段 赋值，引用函数，解释/执行代码。这可能意味着每个执行环境在概念上作为一个对象并带有三个属性1234567executionContextObj = &#123;scopeChain: &#123; /* variableObject + all parent execution context's variableObject */ &#125;,//作用域链：&#123;变量对象＋所有父执行环境的变量对象&#125;variableObject: &#123; /* function arguments / parameters, inner variable and function declarations */ &#125;,//变量对象:&#123;函数形参＋内部的变量＋函数声明(但不包含表达式)&#125;this: &#123;&#125;&#125; 活动／变量 对象(AO/VO)当函数被调用，executionContextObj就被创建，该对象在实际函数执行前就已创建。这就是已知的第一个阶段创建阶段.在第一阶段，解释器创建了executionContextObj对象，通过扫描函数，传递形参，函数声明和局部变量声明。扫描的结果成为了变量对象在executionContextObj中。 这有一个解释器是如何评估代码的伪概述： 找到一些代码来调用函数 在执行函数代码前，创建执行环境 进入创建阶段： 初始化作用域链 创建变量对象: 创建arguments对象，检查环境中的参数，初始化名和值，创建一个参考副本 扫描环境中内的函数声明： 某个函数被发现，在变量对象创建一个属性，它是函数的确切名。它是一个指针在内存中，指向这个函数。 如果这个函数名已存在，这个指针的值将会重写。 扫描环境内的变量声明 某个变量声明被发现，在变量对象中创建一个属性，他是变量的名，初始化它的值为undefined。 如果变量名在变量对象中已存在，什么也不做，继续扫描。 在环境中确定this的值。 激活/代码执行阶段：在当前环境上运行/解释函数代码，并随着代码一行行执行指派变量的值 看下面例子：1234567891011function foo(i) &#123;var a = &apos;hello&apos;;var b = function privateB() &#123;&#125;;function c() &#123;&#125;&#125;foo(22); 12On calling foo(22), the creation stage looks as follows:在调用foo(22)时，创建阶段像下面这样： fooExecutionContext = {scopeChain: { … },variableObject: {arguments: {0: 22,length: 1},i: 22,c: pointer to function c()a: undefined,b: undefined},this: { … }}1正如你看到的，创建阶段处理了定义属性的名，但是并不把值赋给变量，不包括形参和实参。一旦创建阶段完成,执行流进入函数并且激活/代码执行阶段,在函数执行结束之后，看起来像这样： fooExecutionContext = {scopeChain: { … },variableObject: {arguments: {0: 22,length: 1},i: 22,c: pointer to function c()a: ‘hello’,b: pointer to function privateB()},this: { … }}123**进阶一言**你可以在网上找到大量的术语来描述JavaScript进阶。解释变量和函数声明被提升到它们函数作用域的顶端。然而，没有一个详细的解释为什么这样， 现在你配备了关于解释器怎么创建活动对象的新知识，这会很明白这是为什么。看看下面例子： ​(function() { console.log(typeof foo); // function pointerconsole.log(typeof bar); // undefined var foo = ‘hello’,bar = function() {return ‘world’;}; function foo() {return ‘hello’;} }());​`现在我们能解答的问题有： 为什么在声明foo之前我们就可以调用?如果我们按照创建阶段进行，我们知道变量在激活/执行阶段之前已经被创建了。因此，在函数流开始执行，foo已经在活动对象中被定义了。foo被声明了两次, 为什么foo展现出来的是functiton，而不是undefined或者string我们从创建阶段知道,尽管foo被声明了两次，函数在活动对象中是在变量之前被创建的，并且如果属性名在活动对象已经存在,我们会简单地绕过这个声明。 所以，引用函数foo（）是在活动对象上第一次被创建的， 当我们解释到 var foo的时候，我们发现属性名foo已经存在，所以代码不会做任何处理，只是继续进行 为什么bar是undefined？ bar确实是一个变量，并且值是一个函数。我们知道变量是在创建阶段被创建的，但是它们的值被初始化为undefined。 事件循环 事件循环机制：上面讲了执行栈中的所有任务从顶向下同步执行；但当遇到一些需要异步执行的任务，如ajax、setTimeout等时，会立即返回函数，然后将异步操作交给浏览器内核中的其他模块处理（如timer、network、DOM Binding模块），接着主线程继续往下执行 栈中的任务。 当上面说的异步操作完成后如ajax接受完响应、setTimeout到达指定延时；这些任务 即回调函数会被放入到任务队列中。一般不同的异步任务的回调函数会放入不同的任务队列之中。（分为宏任务和微任务；优先执行微任务队列） 只有当执行栈为空时，执行引擎才会去看任务队列有无可执行的任务；如果有，就取一个放入到执行栈中执行。执行完后，执行栈为空，便又去检查任务队列。 不断地循环重复上述过程的机制，就是“事件循环”。","categories":[{"name":"基础1.1:变量（变量提升,暂时性死区）、执行环境、执行栈","slug":"基础1-1-变量（变量提升-暂时性死区）、执行环境、执行栈","permalink":"https://93qlin.github.io/categories/基础1-1-变量（变量提升-暂时性死区）、执行环境、执行栈/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"原型和闭包","slug":"原型和闭包","date":"2019-02-28T03:12:12.517Z","updated":"2019-02-28T03:12:12.517Z","comments":true,"path":"2019/02/28/原型和闭包/","link":"","permalink":"https://93qlin.github.io/2019/02/28/原型和闭包/","excerpt":"","text":"==1.一切（引用类型）都是对象，对象是属性的集合。==2.函数和对象的关系 ==函数就是对象的一种==12var fn = function () &#123; &#125;;console.log(fn instanceof Object); // true 函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂 ==对象可以通过函数来创建,也可以说对象都是通过函数创建的==12345function Fn() &#123; this.name = &apos;张三&apos;; this.year = 1988;&#125;var fn1 = new Fn(); 123456789// var obj = &#123; a: 10, b: 20 &#125;;// var arr = [5, &apos;x&apos;, true];var obj = new Object();obj.a = 10;obj.b = 20;var arr = new Array();arr[0] = 5;arr[1] = &apos;x&apos;;arr[2] = true; 而其中的 Object 和 Array 都是函数：12console.log(typeof (Object)); // functionconsole.log(typeof (Array)); // function 问题来了 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系==?== 3.prototype原型 函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。javascript默认的给函数一个属性——prototype。每个函数都有一个属性叫做prototype。==这个prototype的属性值是一个对象（属性的集合，强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。== SuperType是是一个函数，右侧的方框就是它的原型,即，每个对象都有一个proto属性，指向创建该对象的函数的prototype。那么上图中的“Object prototype”也是一个对象，==它的proto指向哪里==？ 原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如 有些方法怎么似曾相似？可以在自己自定义的方法的prototype中新增自己的属性12345function Fn() &#123; &#125; Fn.prototype.name = &apos;张三&apos;; Fn.prototype.getYear = function () &#123; return 1988;&#125;; 这样就变成了12345678function Fn() &#123; &#125;Fn.prototype.name = &apos;张三&apos;;Fn.prototype.getYear = function () &#123; return 1988;&#125;;var fn = new Fn();console.log(fn.name);console.log(fn.getYear()); Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。因为每个对象都有一个隐藏的属性proto，这个属性引用了创建这个对象的函数的prototype。即：fn.__proto__ === Fn.prototype这里的proto成为“隐式原型”， 4.隐式原型 上节已经提到，==每个函数function都有一个prototype，即原型。这里再加一句话——每个对象都有一个proto，可成为隐式原型。== 上面图看来，obj.proto和Object.prototype的属性一样！ obj这个对象本质上是被Object函数创建的，==因此obj.__proto__ === Object.prototype==我们可以用一个图来表示。 即，每个对象都有一个proto属性，指向创建该对象的函数的prototype。 ==那么上图中的“Object prototype”也是一个对象，它的proto指向哪里==？ 在说明“Object prototype”之前，先说一下自定义函数的prototype。==自定义函数的prototype本质上就是和 var obj = {} 是一样的，都是被Object创建，所以它的proto指向的就是Object.==prototype(prototype也是一个对象)====。但是Object.prototype确实一个==特例==——它的proto指向的是null，切记切记！ ==函数也是一种对象，函数也有proto吗==？ 又一个好问题！——当然有。函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——==Function==——注意这个大写的“F”。且看如下代码。 以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建 根据上面说的一句话——对象的proto指向的是创建它的函数的prototype，就会出现：Object.__proto__ === Function.prototype。用一个图来表示。 很明显的标出了：自定义函数Foo.proto指向Function.prototype，Object.proto指向Function.prototype，唉，怎么还有一个……Function.proto指向Function.prototype？这不成了循环引用了？对！是一个环形结构。其实稍微想一下就明白了。Function也是一个函数，函数是一种对象，也有proto属性。既然是函数，那么它一定是被Function创建。==所以——Function是被自身创建的==。所以它的proto指向了自身的Prototype。 问题：Function.prototype指向的对象，==它的proto是不是也指向Object.prototype？== 答案是肯定的。因为Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则。 5.instanceof 对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。这个时候就需要用到instanceof。例如： 上图中，f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢？instanceof判断的规则根据以上代码看下图： Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。 Instanceof的==判断规则==是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。按照以上规则，“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。 通过上以规则，你可以解释很多比较怪异的现象，例如： 这些看似很混乱的东西，答案却都是true，这是为何？正好，这里也接上了咱们上一节说的“乱”。上一节贴了好多的图片，其实那些图片是可以联合成一个整体的，即： ==问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？==重点就这样被这位老朋友给引出来了——==继承==——==原型链==。即，instanceof表示的就是一种继承关系，或者原型链的结构。请看下节分解。 6.继承继承是通过原型链来体现的 ==原型链==： 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。 上图中，访问f1.b时，f1的基本属性中没有b，于是沿着proto找到了Foo.prototype.b。 我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？——==hasOwnProperty==，特别是在for…in…循环中，一定要注意。 f1的这个hasOwnProperty方法是从哪里来的？ f1本身没有，==Foo.prototype中也没有，哪儿来的？==好问题。它是从Object.prototype中来的，请看图： 对象的原型链是沿着proto这条线走的，因此在查找f1.hasOwnProperty属性时，就会顺着原型链一直查找到Object.prototype。由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。==这就是所谓的“继承”。==当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。 说一个函数的例子吧。 我们都知道每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的。函数由Function函数创建，因此继承的Function.prototype中的方法。不信可以请微软的Visual Studio老师给我们验证一下：看到了吧，有call、length等这些属性。那怎么还有hasOwnProperty呢？——==那是Function.prototype继承自Object.prototype的方法==。有疑问可以看看上一节将instanceof时候那个大图，看看Function.prototype.proto是否指向Object.prototype。 8简述【执行上下文】上 “执行上下文”（也叫做“执行上下文环境”） 第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。 在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟： 下面还有。先来个简单的。 有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。 与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一 下面还有。。。第三种情况。 在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。 看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。 没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。 好了，“准备工作”介绍完毕。我们==总结==一下，在“准备工作”中完成了哪些工作：1231.变量、函数表达式——变量声明，默认赋值为undefined；2.this——赋值；3.函数声明——赋值 这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。 其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分==三种情况——全局代码，函数体，eval代码==。 这里解释一下为什么代码段分为这三种。 所谓“代码段”就是一段文本形式的代码。 首先，全局代码是一种，这个应该没有非议，本来就是手写文本到标签里面的。 其次，eval代码接收的也是一段文本形式的代码。 最后，==函数体是代码段==是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。","categories":[{"name":"原型和闭包","slug":"原型和闭包","permalink":"https://93qlin.github.io/categories/原型和闭包/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"}]},{"title":"webpack","slug":"webpack","date":"2019-02-28T03:12:12.516Z","updated":"2019-02-28T03:12:12.516Z","comments":true,"path":"2019/02/28/webpack/","link":"","permalink":"https://93qlin.github.io/2019/02/28/webpack/","excerpt":"","text":"webpack基础1 .初始化： npm init2 .安装： npm install webpack –save-dev webpack处理js文件命令： webpack ./hello.js hello.bunder.js（生成的文件名） webpack处理css文件需要安装loader: npm install css-loader style-loader -s注意在其他文件引入时： require(‘style-loader!css-loader!./style.css’)css-loader: 处理css文件style-loader： 把处理的css文件新建style标签插入html –module-bind：如果每引入一个css文件都加前面几句麻烦，也可以在命令行直接里利用参数：–module-bind使用（注意双引号）： webpack ./hello.js hello.bunder.js –module-bind “css=style-loader!css-loader” –watch解决每一次改变文件都要运行命令麻烦 webpack ./hello.js hello.bunder.js –module-bind “css=style-loader!css-loader” –watch –progress(打包过程) –display-modules(打包模块) –display-reasons(打包理由) –colors(彩色字体) 构建项目npm init npm install webpack --save-dev mkdir src(建文件夹) 。。。 建立webpack.config.js文件配置（也可以别的名字但是要使用 webpack --config 文件名） 运行 webpack webpack时可以加参数（在packagejson/scripts定义：&quot;webpack&quot;: &quot;webpack --config webpack.config.js --progress --display-modules --color --display-reasons&quot;） entry改为数组或对象entry: [‘./src/script/main.js’,’./src/script/a.js’],entry: {main: ‘./src/script/main.js’,a: ‘./src/script/a.js’},对象的话filename会覆盖解决方式 filename: ‘[name].js’,[name] is replaced by the name of the chunk.[hash] is replaced by the hash of the compilation.[chunkhash] is replaced by the hash of the chunk.（每个chunk不一样，当chunk改变其跟着也会改变） html-webpack-plugin(生成html可以避免每次都要改路径比如用的chunkhash)npm install html-webpack-plugin –save-devvar htmlWebpackPlugin = require(‘html-webpack-plugin’)。。。。plugins: [ new htmlWebpackPlugin() ] 此时生成了html而且关联了相关js文件，但还是无法和根目录的index.html相关联所以加个参数相关联index.html改变生成的html也会改变12345plugins: [ new htmlWebpackPlugin(&#123; template: &apos;index.html&apos; &#125;) ] 改变路径可以做到html和js文件分离1234output: &#123; path: __dirname + &apos;/dist&apos;, filename: &apos;js/[name]-[chunkhash].js&apos; &#125;, 可以指定生成文件名和脚本放置位置1234567plugins: [ new htmlWebpackPlugin(&#123; filename: &apos;index-[hash].html&apos;, template: &apos;index.html&apos;, inject: &apos;head&apos; //把脚本放在heed标签里，默认放在body里 &#125;) ] 配置模板123456789 plugins: [ new htmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: &apos;head&apos;, //把脚本放在heed标签里，默认放在body里 title: &apos;标题1&apos;, date: new Date() &#125;)] 模板写法以及遍历123456789101112 &lt;%= %&gt;取值 &lt;% %&gt;执行js代码 在index.html&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;body&gt; &lt;%= htmlWebpackPlugin.options.date %&gt; &lt;% for (var key in htmlWebpackPlugin.files) &#123; %&gt; &lt;%= key %&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.files[key]) %&gt; &lt;% &#125; %&gt; &lt;% for (var key in htmlWebpackPlugin.options) &#123; %&gt; &lt;%= key %&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.options[key]) %&gt; &lt;% &#125; %&gt;&lt;/body&gt; 在webpack./config.js123456789plugins: [ new htmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: &apos;head&apos;, //把脚本放在heed标签里，默认放在body里 title: &apos;标题1&apos;, date: new Date() &#125;) ] 设置引入js文件的位置或body或head在模板index.html里设置script的属性（注意把inject设为false）12345678910&lt;script src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.a.entry %&gt;&quot;&gt;&lt;/script&gt;plugins: [ new htmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: false, //&apos;head&apos;把脚本放在heed标签里，默认放在body里 title: &apos;标题1&apos;, date: new Date() &#125;) ] 上线路径（publicPath）output: { path: __dirname + &apos;/dist&apos;, filename: &apos;js/[name]-[chunkhash].js&apos;, publicPath: &apos;http://xxx.com/&apos; } 压缩html（minify）plugins: [ new htmlWebpackPlugin({ filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: false,//&apos;head&apos;把脚本放在heed标签里，默认放在body里 title: &apos;标题1&apos;, date: new Date(), minify: { removeComments: true, //删除注释 collapseWhitespace: true //删除空格 } }) ] 多页面配置（chunks,excludeChunks）chunks(包含XXX)123456789101112new htmlWebpackPlugin(&#123; filename: &apos;b.html&apos;, template: &apos;index.html&apos;, inject: &apos;body&apos;,//&apos;head&apos;把脚本放在heed标签里，默认放在body里 title: &apos;标题b&apos;, date: new Date(), chunks: [&apos;b&apos;], minify: &#123; removeComments: true, //删除注释 collapseWhitespace: true //删除空格 &#125; &#125;) excludeChunks(除了XXX都包含)123456789101112new htmlWebpackPlugin(&#123; filename: &apos;b.html&apos;, template: &apos;index.html&apos;, inject: &apos;body&apos;, //&apos;head&apos;把脚本放在heed标签里，默认放在body里 title: &apos;标题b&apos;, date: new Date(), excludeChunks: [&apos;a&apos;, &apos;c&apos;], minify: &#123; removeComments: true, //删除注释 collapseWhitespace: true //删除空格 &#125; &#125;) 设置了publicPath: http://…..则生成的文件就会加巨http请求。inline引入(模板html)123 &lt;script&gt; &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source()%&gt;&lt;/script&gt; webpack配置123456789new htmlWebpackPlugin(&#123; filename: &apos;a.html&apos;, template: &apos;index.html&apos;, inject: false, //&apos;head&apos;把脚本放在heed标签里，默认放在body里,false关闭 title: &apos;标题a&apos;, date: new Date(), /*chunks: [&apos;main&apos;,&apos;a&apos;], //指定生成的js*/ excludeChunks: [&apos;b&apos;, &apos;c&apos;] &#125;), index.html最终版1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;script&gt; &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source()%&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;% for (var key in htmlWebpackPlugin.files.chunks) &#123; %&gt; &lt;% if (key != &apos;main&apos;) &#123; %&gt; &lt;script src=&quot;&lt;%= htmlWebpackPlugin.files.chunks[key].entry %&gt;&quot;&gt;&lt;/script&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt;&lt;/body&gt;&lt;/html&gt; loader(处理资源文件，es6,7 less,图片，，，，)babel-loader:12345678910111213141516npm install --save-dev babel-loader babel-corenpm install --save-dev babel-preset-latest(es5,6,7,,,)module: &#123; rules: [ &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, exclude: &apos;/node_modules/&apos;, //排除打包文件优化打包时间 include: &apos;/src/&apos;, //定义打包文件 query: &#123; &apos;presets&apos;: [&apos;latest&apos;] &#125; &#125; ] &#125; postcss-loader;（处理css）123npm install postcss-loader --save-devnpm install autoprefixer --save-dev(加前缀)npm install postcss-import --save-dev(解决import css文件时生成多个style) less-loader12npm i less --save-devnpm i less-loader --save-dev 处理模板文件(html,ejs,,,,,,)npm install html-loader --save-dev","categories":[{"name":"webpack","slug":"webpack","permalink":"https://93qlin.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://93qlin.github.io/tags/webpack/"}]},{"title":"vue问题，技巧提升","slug":"vue问题，技巧提升","date":"2019-02-28T03:12:12.516Z","updated":"2019-02-28T03:12:12.516Z","comments":true,"path":"2019/02/28/vue问题，技巧提升/","link":"","permalink":"https://93qlin.github.io/2019/02/28/vue问题，技巧提升/","excerpt":"","text":"用了vue已有将近两年了，一直没做过总结只知道做项目，遇到类似的问题不记得有时还得去翻之前的项目，偶然看见别人在做了一个项目就做了总结很是汗颜，所以想着写一篇博客来总结（当然也有许多地方是复制粘贴别人的） timeago.js将时间戳转换成“几天前”“几分钟前”等格式第一步：安装timeago.js1npm install timeago.js 或cnpm install timeago.js(推荐)第二步：引入timeago.js1import timeago from &apos;timeago.js&apos;; 第三步：使用本例中讲述如何在vue中使用//1.在vue分过滤器中定义changeTime方法12345678filters: &#123; //timeago.js插件 //计算时间，类似于几分钟前，几小时前，几天前等 changeTime(val)&#123; let time = new Date(val); //先将接收到的json格式的日期数据转换成可用的js对象日期 return new timeago().format(time, &apos;zh_CN&apos;); //转换成类似于几天前的格式 &#125;&#125; //2.在template中使用，例如：12//time是需要转换的时间戳，changeTime是过滤器中定义的方法&lt;span&gt;&#123;&#123;time | changeTime&#125;&#125;&lt;/span&gt; 路由传参vue传参方式有：query、params+动态路由传参。说下两者的区别： 1.query通过path切换路由，params通过name切换路由// query通过path切换路由123&lt;router-link :to=&quot;&#123;path: &apos;Detail&apos;, query: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;// params通过name切换路由&lt;router-link :to=&quot;&#123;name: &apos;Detail&apos;, params: &#123; id: 1 &#125;&#125;&quot;&gt;前往Detail页面&lt;/router-link&gt;","categories":[{"name":"vue问题，技巧提升","slug":"vue问题，技巧提升","permalink":"https://93qlin.github.io/categories/vue问题，技巧提升/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://93qlin.github.io/tags/vue/"}]},{"title":"redux和react-redux深入理解","slug":"redux和react-redux深入理解","date":"2019-02-28T03:12:12.516Z","updated":"2019-02-28T03:12:12.516Z","comments":true,"path":"2019/02/28/redux和react-redux深入理解/","link":"","permalink":"https://93qlin.github.io/2019/02/28/redux和react-redux深入理解/","excerpt":"","text":"context 帮助理解react-redux 某个组件只要往自己的 context 里面放了某些状态，这个组件之下的所有子组件都直接访问这个状态而不需要通过中间组件的传递。一个组件的 context 只有它的子组件能够访问。 123456789101112131415161718192021222324252627282930313233// app.jsimport React, &#123; Component &#125; from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;import Header from &apos;./header&apos;;import Main from &apos;./main&apos;;import &apos;./App.css&apos;;class App extends Component &#123; static childContextTypes = &#123; themeColor :PropTypes.string &#125; constructor () &#123; super() this.state = &#123; themeColor : &apos;red&apos; &#125; &#125; getChildContext () &#123; return &#123; themeColor : this.state.themeColor &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt; ) &#125;&#125;export default App; 123456789101112//title.jsclass Title extends Component &#123; static contextTypes = &#123; themeColor: PropTypes.string &#125; render () &#123; return ( &lt;h1 style=&#123;&#123; color: this.context.themeColor &#125;&#125;&gt;React.js 小书标题&lt;/h1&gt; ) &#125;&#125; 一个组件可以通过 getChildContext 方法返回一个对象，这个对象就是子树的 context，提供 context 的组件必须提供 childContextTypes 作为 context 的声明和验证。 如果一个组件设置了 context，那么它的子组件都可以直接访问到里面的内容，它就像这个组件为根的子树的全局变量。任意深度的子组件都可以通过 contextTypes 来声明你想要的 context 里面的哪些状态，然后可以通过 this.context 访问到那些状态。 context 打破了组件和组件之间通过 props 传递数据的规范，极大地增强了组件之间的耦合性。而且，就如全局变量一样，context 里面的数据能被随意接触就能被随意修改，每个组件都能够改 context 里面的内容会导致程序的运行不可预料。 动手实现Redux Redux 和 React-redux 并不是同一个东西。Redux 是一种架构模式（Flux 架构的一种变种），它不关注你到底用什么库，你可以把它应用到 React 和 Vue，甚至跟 jQuery 结合都没有问题。==而 React-redux 就是把 Redux 这种架构模式和 React.js 结合起来的一个库==，就是 Redux 架构在 React.js 中的体现。这节主要讲如何自己手动实现一个redux模式 用 create-react-app 新建一个项目：react-redux-demo2：1create-react-app react-redux-demo2 修改 public/index.html 里面的 body 结构为：1234&lt;body&gt; &lt;div id=&apos;title&apos;&gt;&lt;/div&gt; &lt;div id=&apos;content&apos;&gt;&lt;/div&gt;&lt;/body&gt; 删除 src/index.js 里面所有的代码，添加下面代码，代表我们应用的状态：12345678910const appState = &#123; title: &#123; text: &apos;this is title&apos;, color: &apos;red&apos;, &#125;, content: &#123; text: &apos;this is content&apos;, color: &apos;blue&apos; &#125;&#125; 我们新增几个渲染函数，它会把上面状态的数据渲染到页面上：1234567891011121314151617function renderApp (appState) &#123; renderTitle(appState.title) renderContent(appState.content)&#125;function renderTitle (title) &#123; const titleDOM = document.getElementById(&apos;title&apos;) titleDOM.innerHTML = title.text titleDOM.style.color = title.color&#125;function renderContent (content) &#123; const contentDOM = document.getElementById(&apos;content&apos;) contentDOM.innerHTML = content.text contentDOM.style.color = content.color&#125;renderApp(appState) 很简单，renderApp 会调用 rendeTitle 和 renderContent，而这两者会把 appState 里面的数据通过原始的 DOM 操作更新到页面上。 这里的矛盾就是：“模块（组件）之间需要共享数据”，和“数据可能被任意修改导致不可预料的结果”之间的矛盾。 解决方法：定义一个函数，叫 dispatch，它专门负责数据的修改：123456789101112function dispatch (action) &#123; switch (action.type) &#123; case &apos;UPDATE_TITLE_TEXT&apos;: appState.title.text = action.text break case &apos;UPDATE_TITLE_COLOR&apos;: appState.title.color = action.color break default: break &#125;&#125; 所有对数据的操作必须通过 dispatch 函数。它接受一个参数 action，这个 action 是一个普通的 JavaScript 对象，里面必须包含一个 type 字段来声明你到底想干什么。dispatch 在 swtich 里面会识别这个 type 字段，能够识别出来的操作才会执行对 appState 的修改。 任何的模块如果想要修改 appState.title.text，必须大张旗鼓地调用 dispatch：12dispatch(&#123; type: &apos;UPDATE_TITLE_TEXT&apos;, text: &apos;this is dispatch&apos; &#125;) // 修改标题文本dispatch(&#123; type: &apos;UPDATE_TITLE_COLOR&apos;, color: &apos;blue&apos; &#125;) // 修改标题颜色 构建共享状态仓库上一节我们有了 appState 和 dispatch，现在我们把它们集中到一个地方，给这个地方起个名字叫做 store，然后构建一个函数 createStore，用来专门生产这种 state 和 dispatch 的集合，这样别的 App 也可以用这种模式了：12345function createStore (state, stateChanger) &#123; const getState = () =&gt; state const dispatch = (action) =&gt; stateChanger(state, action) return &#123; getState, dispatch &#125;&#125; createStore 接受两个参数，一个是表示应用程序状态的 state；另外一个是 stateChanger，它来描述应用程序状态会根据 action 发生什么变化，其实就是相当于本节开头的 dispatch 代码里面的内容。 createStore 会返回一个对象，这个对象包含两个方法 getState 和 dispatch。getState 用于获取 state 数据，其实就是简单地把 state 参数返回。 dispatch 用于修改数据，和以前一样会接受 action，然后它会把 state 和 action 一并传给 stateChanger，那么 stateChanger 就可以根据 action 来修改 state 了。 现在有了 createStore，我们可以这么修改原来的代码，保留原来所有的渲染函数不变，修改数据生成的方式：12345678910111213141516171819202122232425262728293031let appState = &#123; title: &#123; text: &apos;this is title&apos;, color: &apos;red&apos;, &#125;, content: &#123; text: &apos;this is content&apos;, color: &apos;blue&apos; &#125;&#125;function stateChanger (state, action) &#123; switch (action.type) &#123; case &apos;UPDATE_TITLE_TEXT&apos;: state.title.text = action.text break case &apos;UPDATE_TITLE_COLOR&apos;: state.title.color = action.color break default: break &#125;&#125;const store = createStore(appState, stateChanger)renderApp(store.getState()) // 首次渲染页面store.dispatch(&#123; type: &apos;UPDATE_TITLE_TEXT&apos;, text: &apos;this is dispatch&apos; &#125;) // 修改标题文本store.dispatch(&#123; type: &apos;UPDATE_TITLE_COLOR&apos;, color: &apos;blue&apos; &#125;) // 修改标题颜色renderApp(store.getState()) // 把新的数据渲染到页面上针对每个不同的 App，我们可以给 createStore 传入初始的数据 appState，和一个描述数据变化的函数 stateChanger，然后生成一个 store。需要修改数据的时候通过 store.dispatch，需要获取数据的时候通过 store.getState。 监控数据变化上面代码有个问题，就是每次dispatch修改数据的时候，其实只是数据发生了变化，如果我们不手动调用renderApp，页面不会发生变化。==如何数据变化的时候程序能够智能一点地自动重新渲染数据，而不是手动调用？== 往 dispatch里面加 renderApp 就好了，但是这样 createStore 就不够通用了。我们希望用一种通用的方式“监听”数据变化，然后重新渲染页面，这里要用到==观察者模式==。修改 createStore：12345678910function createStore (state, stateChanger) &#123; const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; stateChanger(state, action) listeners.forEach((listener) =&gt; listener()) &#125; return &#123; getState, dispatch, subscribe &#125;&#125; 我们在 createStore 里面定义了一个数组 listeners，还有一个新的方法 subscribe，可以通过 store.subscribe(listener) 的方式给 subscribe 传入一个监听函数，这个函数会被 push 到数组当中。每当 dispatch 的时候，监听函数就会被调用，这样我们就可以在每当数据变化时候进行重新渲染：12const store = createStore(appState, stateChanger)store.subscribe(() =&gt; renderApp(store.getState())) renderApp(store.getState()) // 首次渲染页面store.dispatch({ type: ‘UPDATE_TITLE_TEXT’, text: ‘this is dispatch’ }) // 修改标题文本store.dispatch({ type: ‘UPDATE_TITLE_COLOR’, color: ‘blue’ }) // 修改标题颜色// …后面不管如何 store.dispatch，都不需要重新调用 renderApp 共享结构的对象来提高性能 其实我们之前的例子当中是有比较严重的性能问题的。我们在每个渲染函数的开头打一些 Log 看看：12345678910111213141516171819function renderApp (appState) &#123; console.log(&apos;render app...&apos;) renderTitle(appState.title) renderContent(appState.content)&#125;function renderTitle (title) &#123; console.log(&apos;render title...&apos;) const titleDOM = document.getElementById(&apos;title&apos;) titleDOM.innerHTML = title.text titleDOM.style.color = title.color&#125;function renderContent (content) &#123; console.log(&apos;render content...&apos;) const contentDOM = document.getElementById(&apos;content&apos;) contentDOM.innerHTML = content.text contentDOM.style.color = content.color&#125; 依旧执行一次初始化渲染，和两次更新，这里代码保持不变：123renderApp(store.getState()) // 首次渲染页面store.dispatch(&#123; type: &apos;UPDATE_TITLE_TEXT&apos;, text: &apos;this is dispatch&apos; &#125;) // 修改标题文本store.dispatch(&#123; type: &apos;UPDATE_TITLE_COLOR&apos;, color: &apos;blue&apos; &#125;) // 修改标题颜色 可以看到问题就是，每当更新数据就重新渲染整个 App，但其实我们两次更新都没有动到 appState 里面的 content 字段的对象，而动的是 title 字段。其实并不需要重新 renderContent，它是一个多余的更新操作，现在我们需要优化它。 这里提出的解决方案是，在每个渲染函数执行渲染操作之前先做个判断，判断传入的新数据和旧的数据是不是相同，相同的话就不渲染了。123456789101112131415161718192021222324252627282930313233343536373839404142434445function renderApp (newAppState, oldAppState = &#123;&#125;) &#123; // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = &#123;&#125;if (newAppState === oldAppState) return // 数据没有变化就不渲染了 console.log(&apos;render app...&apos;) renderTitle(newAppState.title, oldAppState.title) renderContent(newAppState.content, oldAppState.content)&#125;function renderTitle (newTitle, oldTitle = &#123;&#125;) &#123; if (newTitle === oldTitle) return // 数据没有变化就不渲染了 console.log(&apos;render title...&apos;) const titleDOM = document.getElementById(&apos;title&apos;) titleDOM.innerHTML = newTitle.text titleDOM.style.color = newTitle.color&#125;function renderContent (newContent, oldContent = &#123;&#125;) &#123; if (newContent === oldContent) return // 数据没有变化就不渲染了 console.log(&apos;render content...&apos;) const contentDOM = document.getElementById(&apos;content&apos;) contentDOM.innerHTML = newContent.text contentDOM.style.color = newContent.color&#125;然后我们用一个 oldState 变量保存旧的应用状态，在需要重新渲染的时候把新旧数据传进入去：const store = createStore(appState, stateChanger)let oldState = store.getState() // 缓存旧的 statestore.subscribe(() =&gt; &#123; const newState = store.getState() // 数据可能变化，获取新的 state renderApp(newState, oldState) // 把新旧的 state 传进去渲染 oldState = newState // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染&#125;)...function stateChanger (state, action) &#123; switch (action.type) &#123; case &apos;UPDATE_TITLE_TEXT&apos;: state.title.text = action.text break case &apos;UPDATE_TITLE_COLOR&apos;: state.title.color = action.color break default: break &#125;&#125; 其实上面一顿操作根本达不到我们的预期的要求，你会发现还是渲染了content，这些引用指向的还是原来的对象，只是对象内的内容发生了改变。所以即使你在每个渲染函数开头加了那个判断又什么用？就像下面这段代码一样自欺欺人：123456let people = &#123; name:&apos;ddvdd&apos;&#125;const oldPeople = peoplepeople.name = &apos;yjy&apos;oldPeople !== people //false 其实两个引用指向的是同一个对象，我们却希望它们不同。那怎么样才能达到我们要的要求呢？引入共享结构的对象概念：123const obj = &#123; a: 1, b: 2&#125;const obj2 = &#123; ...obj &#125; // =&gt; &#123; a: 1, b: 2 &#125;const obj2 = &#123; ...obj &#125; 其实就是新建一个对象 obj2，然后把 obj 所有的属性都复制到 obj2 里面，相当于对象的浅复制。上面的 obj 里面的内容和 obj2 是完全一样的，但是却是两个不同的对象。除了浅复制对象，还可以覆盖、拓展对象属性：12const obj = &#123; a: 1, b: 2&#125;const obj2 = &#123; ...obj, b: 3, c: 4&#125; // =&gt; &#123; a: 1, b: 3, c: 4 &#125;，覆盖了 b，新增了 c 我们可以把这种特性应用在 appstate 的更新上，我们禁止直接修改原来的对象，一旦你要修改某些东西，你就得把修改路径上的所有对象复制一遍。我们修改 stateChanger，让它修改数据的时候，并不会直接修改原来的数据 state，而是产生上述的共享结构的对象：12345678910111213141516171819202122function stateChanger (state, action) &#123; switch (action.type) &#123; case &apos;UPDATE_TITLE_TEXT&apos;: return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, text: action.text &#125; &#125; case &apos;UPDATE_TITLE_COLOR&apos;: return &#123; // 构建新的对象并且返回 ...state, title: &#123; ...state.title, color: action.color &#125; &#125; default: return state // 没有修改，返回原来的对象 &#125;&#125; 因为 stateChanger 不会修改原来对象了，而是返回对象，所以我们需要修改一下 createStore。让它用每次 stateChanger(state, action) 的调用结果覆盖原来的 state：12345678910function createStore (state, stateChanger) &#123; const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; state = stateChanger(state, action) // 覆盖原对象 listeners.forEach((listener) =&gt; listener()) &#125; return &#123; getState, dispatch, subscribe &#125;&#125; 好了，我们在运行下看看结果是不是变成我们预期的那样了？ 我就喜欢叫它 “reducer” 经过了这么多节的优化，我们有了一个很通用的 createStore，主要传入appState、stateChanger就能使用。那么appState和stateChanger是否可以合并到一起去呢？显然可以：12345678910111213141516171819202122232425262728293031323334function stateChanger (state, action) &#123; if (!state) &#123; return &#123; title: &#123; text: &apos;this is title&apos;, color: &apos;red&apos;, &#125;, content: &#123; text: &apos;this is content&apos;, color: &apos;blue&apos; &#125; &#125; &#125; switch (action.type) &#123; case &apos;UPDATE_TITLE_TEXT&apos;: return &#123; ...state, title: &#123; ...state.title, text: action.text &#125; &#125; case &apos;UPDATE_TITLE_COLOR&apos;: return &#123; ...state, title: &#123; ...state.title, color: action.color &#125; &#125; default: return state &#125;&#125; stateChanger 现在既充当了获取初始化数据的功能，也充当了生成更新数据的功能。如果有传入 state 就生成更新数据，否则就是初始化数据。这样我们可以优化 createStore 成一个参数，因为 state 和 stateChanger 合并到一起了：123456789101112function createStore (stateChanger) &#123; let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; state = stateChanger(state, action) listeners.forEach((listener) =&gt; listener()) &#125; dispatch(&#123;&#125;) // 初始化 state return &#123; getState, dispatch, subscribe &#125;&#125; createStore 内部的 state 不再通过参数传入，而是一个局部变量 let state = null。createStore 的最后会手动调用一次 dispatch({})，dispatch 内部会调用 stateChanger，这时候的 state 是 null，所以这次的 dispatch 其实就是初始化数据了。createStore 内部第一次的 dispatch 导致 state 初始化完成，后续外部的 dispatch 就是修改数据的行为了。 我们给 stateChanger 这个玩意起一个通用的名字：reducer，不要问为什么，它就是个名字而已，修改 createStore 的参数名字：123456789101112function createStore (reducer) &#123; let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; state = reducer(state, action) listeners.forEach((listener) =&gt; listener()) &#125; dispatch(&#123;&#125;) // 初始化 state return &#123; getState, dispatch, subscribe &#125;&#125; 这是一个最终形态的 createStore，它接受的参数叫 reducer，reducer 是一个函数，细心的朋友会发现，它其实是一个纯函数（Pure Function）。 Redux在React当中的实践==搭建工程== 前面我们在react.js的context中提出，我们可用把共享状态放到父组件的 context 上，这个父组件下所有的组件都可以从 context 中直接获取到状态而不需要一层层地进行传递了。但是直接从 context 里面存放、获取数据增强了组件的耦合性；并且所有组件都可以修改 context 里面的状态就像谁都可以修改共享状态一样，导致程序运行的不可预料。 既然这样，为什么不把 context 和 store 结合起来？毕竟 store 的数据不是谁都能修改，而是约定只能通过 dispatch 来进行修改，这样的话每个组件既可以去 context 里面获取 store 从而获取状态，又不用担心它们乱改数据了。我们还是以“主题色”这个例子来讲解，假设我们有这么一颗组件树： Header 和 Content 的组件的文本内容会随着主题色的变化而变化，而 Content 下的子组件 ThemeSwitch 有两个按钮，可以切换红色和蓝色两种主题，按钮的颜色也会随着主题色的变化而变化。 用 create-react-app 新建一个工程react-redux-demo3： create-react-app react-redux-demo3安装好后在 src/ 目录下新增三个文件：Header.js、Content.js、ThemeSwitch.js。12345678910111213//./src/Header.jsimport React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;class Header extends Component &#123; render () &#123; return ( &lt;h1&gt;this is header&lt;/h1&gt; ) &#125;&#125;export default Header 1234567891011121314151617//./src/Content.jsimport React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;import ThemeSwitch from &apos;./ThemeSwitch&apos;class Content extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;p&gt;this is content&lt;/p&gt; &lt;ThemeSwitch /&gt; &lt;/div&gt; ) &#125;&#125;export default Content 12345678910111213141516//./src/ThemeSwitch.jsimport React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;class ThemeSwitch extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;button&gt;Red&lt;/button&gt; &lt;button&gt;Blue&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default ThemeSwitch 1234567891011121314151617181920//修改app.jsimport React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;import ReactDOM from &apos;react-dom&apos;import Header from &apos;./Header&apos;import Content from &apos;./Content&apos;import &apos;./index.css&apos;class App extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ) &#125;&#125;export default App 这样我们就简单地把整个组件树搭建起来了，用 npm start 启动工程，然后可以看到页面上显示： 结合 context 和 store 既然要把 store 和 context 结合起来，我们就先在 src目下创建store.js 和 reducer.js俩文件：123456789101112131415//store.jsfunction createStore (reducer) &#123; let state = null const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const getState = () =&gt; state const dispatch = (action) =&gt; &#123; state = reducer(state, action) listeners.forEach((listener) =&gt; listener()) &#125; dispatch(&#123;&#125;) // 初始化 state return &#123; getState, dispatch, subscribe &#125;&#125;export default createStore 12345678910111213//reducer.jsconst themeReducer = (state, action) =&gt; &#123; if (!state) return &#123; themeColor: &apos;red&apos; &#125; switch (action.type) &#123; case &apos;CHANGE_COLOR&apos;: return &#123; ...state, themeColor: action.themeColor &#125; default: return state &#125;&#125;export default themeReducer themeReducer 定义了一个表示主题色的状态 themeColor，并且规定了一种操作 CHNAGE_COLOR，只能通过这种操作修改颜色。现在我们把 store 放到 App 的 context 里面，这样每个子组件都可以获取到 store 了，修改 src/App.js 里面的 App：12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;import ReactDOM from &apos;react-dom&apos;import Header from &apos;./Header&apos;import Content from &apos;./Content&apos;import createStore from &apos;./store&apos;import themeReducer from &apos;./reducer&apos;const store = createStore(themeReducer)class App extends Component &#123; static childContextTypes = &#123; store: PropTypes.object &#125; getChildContext () &#123; return &#123; store &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ) &#125;&#125;export default App 然后修改 src/Header.js、Content.js、ThemeSwitch.js，让它从 App 的 context 里面获取 store，并且获取里面的 themeColor 状态来设置自己的颜色：123456789101112131415161718192021222324252627//header.jsclass Header extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; themeColor: &apos;&apos; &#125; &#125; componentWillMount () &#123; this._updateThemeColor() &#125; _updateThemeColor () &#123; const &#123; store &#125; = this.context const state = store.getState() this.setState(&#123; themeColor: state.themeColor &#125;) &#125; render () &#123; return ( &lt;h1 style=&#123;&#123; color: this.state.themeColor &#125;&#125;&gt;this is header&lt;/h1&gt; ) &#125;&#125; 123456789101112131415161718192021222324252627282930//content.jsclass Content extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; themeColor: &apos;&apos; &#125; &#125; componentWillMount () &#123; this._updateThemeColor() &#125; _updateThemeColor () &#123; const &#123; store &#125; = this.context const state = store.getState() this.setState(&#123; themeColor: state.themeColor &#125;) &#125; render () &#123; return ( &lt;div&gt; &lt;p style=&#123;&#123; color: this.state.themeColor &#125;&#125;&gt;this is content&lt;/p&gt; &lt;ThemeSwitch /&gt; &lt;/div&gt; ) &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243//themeswitch.jsclass ThemeSwitch extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; themeColor: &apos;&apos; &#125; &#125; componentWillMount () &#123; this._updateThemeColor() &#125; _updateThemeColor () &#123; const &#123; store &#125; = this.context const state = store.getState() this.setState(&#123; themeColor: state.themeColor &#125;) &#125; // dispatch action 去改变颜色 handleSwitchColor (color) &#123; const &#123; store &#125; = this.context store.dispatch(&#123; type: &apos;CHANGE_COLOR&apos;, themeColor: color &#125;) &#125; render () &#123; return ( &lt;div&gt; &lt;button style=&#123;&#123; color: this.state.themeColor &#125;&#125; onClick=&#123;this.handleSwitchColor.bind(this, &apos;red&apos;)&#125;&gt;Red&lt;/button&gt; &lt;button style=&#123;&#123; color: this.state.themeColor &#125;&#125; onClick=&#123;this.handleSwitchColor.bind(this, &apos;blue&apos;)&#125;&gt;Blue&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 我们在 constructor 里面初始化了组件自己的 themeColor 状态。然后在生命周期中 componentWillMount 调用 _updateThemeColor，_updateThemeColor 会从 context 里面把 store 取出来，然后通过 store.getState() 获取状态对象，并且用里面的 themeColor 字段设置组件的 state.themeColor。 然后在 render 函数里面获取了 state.themeColor 来设置标题的样式，页面上就会显示： 我们给两个按钮都加上了 onClick 事件监听，并绑定到了 handleSwitchColor 方法上，两个按钮分别给这个方法传入不同的颜色 red 和 blue，handleSwitchColor 会根据传入的颜色 store.dispatch 一个 action 去修改颜色。 当然你现在点击按钮还是没有反应的。因为点击按钮的时候，只是更新 store 里面的 state，而并没有在 store.state 更新以后去重新渲染数据，我们其实就是忘了 store.subscribe 了。 给 Header.js、Content.js、ThemeSwitch.js 的 componentWillMount 生命周期都加上监听数据变化重新渲染的代码：1234567... componentWillMount () &#123; const &#123; store &#125; = this.context this._updateThemeColor() store.subscribe(() =&gt; this._updateThemeColor()) &#125;... 通过 store.subscribe，在数据变化的时候重新调用 _updateThemeColor，而 _updateThemeColor 会去 store 里面取最新的 themeColor 然后通过 setState 重新渲染组件，这时候组件就更新了。现在可以自由切换主题色了： 顺利地==把 store 和 context 结合起来，这是 Redux 和 React.js 的==第一次胜利会师，当然还有很多需要优化的地方。 connect 和 mapStateToProps观察一下刚写下的这几个组件，可以轻易地发现它们有两个重大的问题： 有大量重复的逻辑：它们基本的逻辑都是，取出 context，取出里面的 store，然后用里面的状态设置自己的状态，这些代码逻辑其实都是相同的。对 context 依赖性过强：这些组件都要依赖 context 来取数据，使得这个组件复用性基本为零。想一下，如果别人需要用到里面的 ThemeSwitch 组件，但是他们的组件树并没有 context 也没有 store，他们没法用这个组件了。 对于第一个问题我们可以用高阶组件（==高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。==）来解决，可以把一些可复用的逻辑放在高阶组件当中，高阶组件包装的新组件和原来组件之间通过 props 传递信息，减少代码的重复程度。 对于第二个问题，我们得弄清楚一件事情，到底什么样的组件才叫复用性强的组件。如果一个组件对外界的依赖过于强，那么这个组件的移植性会很差，就像这些严重依赖 context 的组件一样。 如果一个组件的渲染只依赖于外界传进去的 props 和自己的 state，而并不依赖于其他的外界的任何数据，也就是说像纯函数一样，给它什么，它就吐出（渲染）什么出来。这种组件的复用性是最强的，别人使用的时候根本不用担心任何事情，只要看看 PropTypes 它能接受什么参数，然后把参数传进去控制它就行了。 我们把这种组件叫做 ==Pure Component==，因为它就像纯函数一样，可预测性非常强，对参数（props）以外的数据零依赖，也不产生副作用。这种组件也叫 Dumb Component，因为它们呆呆的，让它干啥就干啥。写组件的时候尽量写 ==Dumb Component== 会提高我们的组件的可复用性。 到这里思路慢慢地变得清晰了，我们需要高阶组件帮助我们从 context 取数据，我们也需要写 Dumb 组件帮助我们提高组件的复用性。所以我们尽量多地写 Dumb 组件，然后用高阶组件把它们包装一层，==高阶组件和 context 打交道，把里面数据取出来通过 props 传给 Dumb 组件==。 我们把这个高阶组件起名字叫 connect，因为它把 Dumb 组件和 context 连接（connect）起来了：123456789101112131415161718import React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;export connect = (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; // TODO: 如何从 store 取数据？ render () &#123; return &lt;WrappedComponent /&gt; &#125; &#125; return Connect&#125; connect 函数接受一个组件 WrappedComponent 作为参数，把这个组件包含在一个新的组件 Connect 里面，Connect 会去 context 里面取出 store。现在要把 store 里面的数据取出来通过 props 传给 WrappedComponent。 ==但是==每个传进去的组件需要 store 里面的数据都不一样的，所以除了给高阶组件传入 Dumb 组件以外，还需要告诉高级组件我们需要什么数据，高阶组件才能正确地去取数据。为了解决这个问题，我们可以给高阶组件传入类似下面这样的函数：12345678const mapStateToProps = (state) =&gt; &#123; return &#123; themeColor: state.themeColor, themeName: state.themeName, fullName: `$&#123;state.firstName&#125; $&#123;state.lastName&#125;` ... &#125;&#125; 这个函数会接受 store.getState() 的结果作为参数，然后返回一个对象，这个对象是根据 state 生成的。mapStateTopProps 相当于告知了 Connect 应该如何去 store 里面取数据，然后可以把这个函数的返回结果传给被包装的组件：12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;export const connect = (mapStateToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; render () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps(store.getState()) // &#123;...stateProps&#125; 意思是把从store里面所需要的属性拿出来全部通过 `props` 方式传递进去 return &lt;WrappedComponent &#123;...stateProps&#125; /&gt; &#125; &#125; return Connect&#125; 1234567891011function add(a) &#123; return function(b) &#123; return a + b &#125;&#125;var add3 = add(3)add3(4) === 3 + 4 //trueadd 函数 在 es6 里的写法等价为let add = a =&gt; b =&gt; a + b 好了既然有了connect这个高阶组件，我们来看看之前的代码怎么改造？我们把上面 connect 的函数代码单独分离到一个模块当中，在 src/ 目录下新建一个 react-redux.js，把上面的 connect 函数的代码复制进去，然后就可以在 src/Header.js 里面使用了：123456789101112131415161718192021222324import React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;import &#123; connect &#125; from &apos;./react-redux&apos;class Header extends Component &#123; static propTypes = &#123; themeColor: PropTypes.string &#125; render () &#123; return ( &lt;h1 style=&#123;&#123; color: this.props.themeColor &#125;&#125;&gt;this is header&lt;/h1&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; themeColor: state.themeColor &#125;&#125;Header = connect(mapStateToProps)(Header)export default Header 可以看到 Header 删掉了大部分关于 context 的代码，它除了 props 什么也不依赖，它是一个 Pure Component，然后通过 connect 取得数据。我们不需要知道 connect 是怎么和 context 打交道的，只要传一个 mapStateToProps 告诉它应该从store里面取哪些数据就可以了。同样的方式修改 src/Content.js，这里不贴了，留给大家自己去完成。 现在的 connect 还没有监听数据变化然后重新渲染，所以现在点击按钮只有按钮会变颜色。我们给 connect 的高阶组件增加监听数据变化重新渲染的逻辑，稍微重构一下 connect：1234567891011121314151617181920212223242526272829303132333435export const connect = (mapStateToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps(store.getState(), this.props) // 额外传入 props，让获取数据更加灵活方便 this.setState(&#123; allProps: &#123; // 整合普通的 props 和从 state 生成的 props ...stateProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125; 为了让 connect 返回新组件和被包装的组件使用参数保持一致，我们会把所有传给 Connect 的 props 原封不动地传给 WrappedComponent。所以在 _updateProps 里面会把 stateProps 和 this.props 合并到 this.state.allProps 里面，再通过 render 方法把所有参数都传给 WrappedComponent。 mapStateToProps 也发生点变化，它现在可以接受两个参数了，我们会把传给 Connect 组件的 props 参数也传给它，那么它生成的对象配置性就更强了，我们可以根据 store 里面的 state 和外界传入的 props 生成我们想传给被包装组件的参数。 现在已经很不错了，Header.js 和 Content.js 的代码都大大减少了，并且这两个组件 connect 之前都是 Dumb 组件。接下来会继续重构 ThemeSwitch。 mapDispatchToProps在重构 ThemeSwitch 的时候我们发现，ThemeSwitch 除了需要 store 里面的数据以外，还需要 store 来 dispatch：12345678910... // dispatch action 去改变颜色 handleSwitchColor (color) &#123; const &#123; store &#125; = this.context store.dispatch(&#123; type: &apos;CHANGE_COLOR&apos;, themeColor: color &#125;) &#125;... 目前版本的 connect 是达不到这个效果的，我们需要改进它。 想一下，既然可以通过给 connect 函数传入 mapStateToProps 来告诉它如何获取、整合状态，我们也可以想到，可以给它传入另外一个参数来告诉它我们的组件需要如何触发 dispatch。我们把这个参数叫 mapDispatchToProps：1234567const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onSwitchColor: (color) =&gt; &#123; dispatch(&#123; type: &apos;CHANGE_COLOR&apos;, themeColor: color &#125;) &#125; &#125;&#125; 和 mapStateToProps 一样，它返回一个对象，这个对象内容会同样被 connect 当作是 props 参数传给被包装的组件。不一样的是，这个函数不是接受 state 作为参数，而是 dispatch，你可以在返回的对象内部定义一些函数，这些函数会用到 dispatch 来触发特定的 action。 调整 connect 让它能接受这样的 mapDispatchToProps：123456789101112131415161718192021222324252627282930313233343536373839404142export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props) : &#123;&#125; // 防止 mapStateToProps 没有传入 let dispatchProps = mapDispatchToProps ? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; // 防止 mapDispatchToProps 没有传入 this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125; 和 mapStateToProps 一样，它返回一个对象，这个对象内容会同样被 connect 当作是 props 参数传给被包装的组件。不一样的是，这个函数不是接受 state 作为参数，而是 dispatch，你可以在返回的对象内部定义一些函数，这些函数会用到 dispatch 来触发特定的 action。 调整 connect 让它能接受这样的 mapDispatchToProps：123456789101112131415161718192021222324252627282930313233343536373839404142export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props) : &#123;&#125; // 防止 mapStateToProps 没有传入 let dispatchProps = mapDispatchToProps ? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; // 防止 mapDispatchToProps 没有传入 this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125; 在 _updateProps 内部，我们把store.dispatch 作为参数传给 mapDispatchToProps ，它会返回一个对象 dispatchProps。接着把 stateProps、dispatchProps、this.props 三者合并到 this.state.allProps 里面去，这三者的内容都会在 render 函数内全部传给被包装的组件。 这时候我们就可以重构 ThemeSwitch，让它摆脱 store.dispatch：123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;import &#123; connect &#125; from &apos;./react-redux&apos;class ThemeSwitch extends Component &#123; static propTypes = &#123; themeColor: PropTypes.string, onSwitchColor: PropTypes.func &#125; handleSwitchColor (color) &#123; if (this.props.onSwitchColor) &#123; this.props.onSwitchColor(color) &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;button style=&#123;&#123; color: this.props.themeColor &#125;&#125; onClick=&#123;this.handleSwitchColor.bind(this, &apos;red&apos;)&#125;&gt;Red&lt;/button&gt; &lt;button style=&#123;&#123; color: this.props.themeColor &#125;&#125; onClick=&#123;this.handleSwitchColor.bind(this, &apos;blue&apos;)&#125;&gt;Blue&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; themeColor: state.themeColor &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onSwitchColor: (color) =&gt; &#123; dispatch(&#123; type: &apos;CHANGE_COLOR&apos;, themeColor: color &#125;) &#125; &#125;&#125;ThemeSwitch = connect(mapStateToProps, mapDispatchToProps)(ThemeSwitch)export default ThemeSwitch 这时候这三个组件的重构都已经完成了，代码大大减少、不依赖 context，并且功能和原来一样。 Provider我们要把 context 相关的代码从所有业务组件中清除出去，现在的代码里面还有一个地方是被污染的。那就是 src/App.js 里面的 App：1234567891011121314151617181920...class Index extends Component &#123; static childContextTypes = &#123; store: PropTypes.object &#125; getChildContext () &#123; return &#123; store &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/div&gt; ) &#125;&#125;... 其实它要用 context 就是因为要把 store 存放到里面，好让子组件 connect 的时候能够取到 store。我们可以额外构建一个组件来做这种脏活，然后让这个组件成为组件树的根节点，那么它的子组件都可以获取到 context 了。 我们把这个组件叫 Provider，因为它提供（provide）了 store，把它放在react-redux.js：12345678910111213141516171819202122export class Provider extends Component &#123; static propTypes = &#123; store: PropTypes.object, children: PropTypes.any &#125; static childContextTypes = &#123; store: PropTypes.object &#125; getChildContext () &#123; return &#123; store: this.props.store &#125; &#125; render () &#123; return ( &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; ) &#125;&#125; Provider 做的事情也很简单，它就是一个容器组件，会把嵌套的内容原封不动作为自己的子组件渲染出来。它还会把外界传给它的 props.store 放到 context，这样子组件 connect 的时候都可以获取到。 可以用它来重构我们的 src/index.js:1234567891011121314import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &apos;./index.css&apos;;import App from &apos;./App&apos;;import createStore from &apos;./store&apos;import &#123; Provider &#125; from &apos;./react-redux&apos;import themeReducer from &apos;./reducer&apos;const store = createStore(themeReducer)ReactDOM.render(&lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt;&lt;/Provider&gt;, document.getElementById(&apos;root&apos;)); 这样我们就把所有关于 context 的代码从组件里面删除了。做完这些你其实已经自己动手完成了一个react-redux的开发，不信？怎么可能那么简单？至今为止都没用react-redux。。。那么现在来看一件神奇的事情，把 src/ 目录下 Header.js、ThemeSwitch.js、Content.js 的模块中的./react-redux 导入的 connect 改成从第三方 react-redux 模块中导入。1import &#123; connect &#125; from &apos;./react-redux&apos; //改成1import &#123; connect &#125; from &apos;react-redux&apos; 删除自己写的 createStore，改成使用第三方模块 redux 的 createStore；Provider 本来从本地的 ./react-redux 引入，改成从第三方 react-redux 模块中引入。其余代码保持不变。123import &#123; createStore &#125; from &apos;redux&apos;import &#123; Provider &#125; from &apos;react-redux&apos; 接着删除 src/react-redux.js，它的已经用处不大了。最后启动工程 npm start：根据地址（https://segmentfault.com/a/1190000012976767#articleHeader6）梳理","categories":[{"name":"redux和react-redux深入理解","slug":"redux和react-redux深入理解","permalink":"https://93qlin.github.io/categories/redux和react-redux深入理解/"}],"tags":[{"name":"react","slug":"react","permalink":"https://93qlin.github.io/tags/react/"},{"name":"es6","slug":"es6","permalink":"https://93qlin.github.io/tags/es6/"}]},{"title":"函数式编程","slug":"函数式编程","date":"2019-02-28T03:12:12.516Z","updated":"2019-02-28T03:12:12.517Z","comments":true,"path":"2019/02/28/函数式编程/","link":"","permalink":"https://93qlin.github.io/2019/02/28/函数式编程/","excerpt":"","text":"一.本质上它是一种数学运算，原始目的就是求值二。函数式编程有两个最基本的运算：合成和柯里化。 1.合成：如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。1234567891011const compose = function (f, g) &#123; return function (x) &#123; return f(g(x)); &#125;;&#125;必须满足结合律compose(f, compose(g, h))// 等同于compose(compose(f, g), h)// 等同于compose(f, g, h) 2 柯里化: 把一个多参数的函数，转化为单参数函数。1234567891011121314f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。这时就需要函数柯里化了。所谓&quot;柯里化&quot;，就是把一个多参数的函数，转化为单参数函数.// 柯里化之前function add(x, y) &#123; return x + y;&#125;add(1, 2) // 3// 柯里化之后function addX(y) &#123; return function (x) &#123; return x + y; &#125;;&#125;addX(2)(1) // 3 三.函子 函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。1 函子的概念函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。2 函子的代码实现任何具有map方法的数据结构，都可以当作函子的实现。12345678class Functor &#123; constructor(val) &#123; this.val = val; &#125; map(f) &#123; return new Functor(f(this.val)); &#125;&#125; 上面代码中，Functor是一个函子，它的map方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（f(this.val)）。 一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。下面是一些用法的示例。12345678910(new Functor(2)).map(function (two) &#123; return two + 2;&#125;);// Functor(4)(new Functor(&apos;flamethrowers&apos;)).map(function(s) &#123; return s.toUpperCase();&#125;);// Functor(&apos;FLAMETHROWERS&apos;)(new Functor(&apos;bombs&apos;)).map(_.concat(&apos; away&apos;)).map(_.prop(&apos;length&apos;));// Functor(10) 上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器—-函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。==因此，学习函数式编程，实际上就是学习函子的各种运算==。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。 四、of 方法 新的函子的时候，用了new命令。这实在==太不像==函数式编程了，因为new命令是面向对象编程的标志。函数式编程一般约定，函子有一个of方法，用来生成新的容器。下面就用of方法替换掉new。12345678Functor.of = function(val) &#123; return new Functor(val);&#125;;然后，前面的例子就可以改成下面这样。Functor.of(2).map(function (two) &#123; return two + 2;&#125;);// Functor(4) 这就更像函数式编程了。 五、Maybe 函子 函子接受各种函数，处理容器内部的值。==这里就有一个问题，容器内部的值可能是一个空值（比如null）==，而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。1234Functor.of(null).map(function (s) &#123; return s.toUpperCase();&#125;);// TypeError 上面代码中，函子里面的值是null，结果小写变成大写的时候就出错了。Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查12345class Maybe extends Functor &#123; map(f) &#123; return this.val ? Maybe.of(f(this.val)) : Maybe.of(null); &#125;&#125; 有了 Maybe 函子，处理空值就不会出错了。1234Maybe.of(null).map(function (s) &#123; return s.toUpperCase();&#125;);// M 六、Either 函子 条件运算if…else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。1234567891011121314class Either extends Functor &#123; constructor(left, right) &#123; this.left = left; this.right = right; &#125; map(f) &#123; return this.right ? Either.of(this.left, f(this.right)) : Either.of(f(this.left), this.right); &#125;&#125;Either.of = function (left, right) &#123; return new Either(left, right);&#125;; 下面是用法。var addOne = function (x) { return x + 1;};1234Either.of(5, 6).map(addOne);// Either(5, 7);Either.of(1, null).map(addOne);// Either(2, null); 上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。Either 函子的常见用途是提供默认值。下面是一个例子。1Either.of(&#123;address: &apos;xxx&apos;&#125;, currentUser.address).map(updateField); 上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。Either 函子的另一个用途是代替try…catch，使用左值表示错误。1234567function parseJSON(json) &#123; try &#123; return Either.of(null, JSON.parse(json)); &#125; catch (e: Error) &#123; return Either.of(e, null); &#125;&#125; 上面代码中，左值为空，就表示没有出错，否则左值会包含一个错误对象e。一般来说，所有可能出错的运算，都可以返回一个 Either 函子 七、ap 函子 函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。12345function addTwo(x) &#123; return x + 2;&#125;const A = Functor.of(2);const B = Functor.of(addTwo) 上面代码中，函子A内部的值是2，函子B内部的值是函数addTwo。有时，我们想==让函子B内部的函数，可以使用函子A内部的值进行运算==。这时就需要用到 ap 函子。 ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。12345class Ap extends Functor &#123; ap(F) &#123; return Ap.of(this.val(F.val)); &#125;&#125; ==注意，ap方法的参数不是函数==，而是另一个函子。 因此，前面例子可以写成下面的形式。12Ap.of(addTwo).ap(Functor.of(2))// Ap(4) ap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。1234567function add(x) &#123; return function (y) &#123; return x + y; &#125;;&#125;Ap.of(add).ap(Maybe.of(2)).ap(Maybe.of(3));// Ap(5) 上面代码中，函数add是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。1Ap.of(add(2)).ap(Maybe.of(3)); 八、Monad 函子 函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。12345Maybe.of( Maybe.of( Maybe.of(&#123;name: &apos;Mulburry&apos;, number: 8402&#125;) )) 上面这个函子，一共有三个Maybe嵌套。如果要取出内部的值，就要连续取三次this.val。这当然很不方便，因此就出现了 Monad 函子。 ==Monad 函子的作用是，总是返回一个单层的函子==。它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。12345678class Monad extends Functor &#123; join() &#123; return this.val; &#125; flatMap(f) &#123; return this.map(f).join(); &#125;&#125; 上面代码中，如果函数f返回的是一个函子，那么this.map(f)就会生成一个嵌套的函子。所以，==join方法保证了flatMap方法总是返回一个单层的函子==。这意味着嵌套的函子会被铺平（flatten）。 九、IO 操作 Monad 函子的重要应用，就是实现 I/O （输入输出）操作。 I/O 是不纯的操作，普通的函数式编程没法做，这时就需要把 IO 操作写成Monad函子，通过它来完成。123456789101112var fs = require(&apos;fs&apos;);var readFile = function(filename) &#123; return new IO(function() &#123; return fs.readFileSync(filename, &apos;utf-8&apos;); &#125;);&#125;;var print = function(x) &#123; return new IO(function() &#123; console.log(x); return x; &#125;);&#125; 上面代码中，读取文件和打印本身都是不纯的操作，但是readFile和print却是纯函数，因为它们总是返回 IO 函子。 如果 IO 函子是一个Monad，具有flatMap方法，那么我们就可以像下面这样调用这两个函数。12readFile(&apos;./user.txt&apos;).flatMap(print) 这就是神奇的地方，上面的代码完成了不纯的操作，但是因为flatMap返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。 由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，flatMap方法被改名成chain。123456789101112var tail = function(x) &#123; return new IO(function() &#123; return x[x.length - 1]; &#125;);&#125;readFile(&apos;./user.txt&apos;).flatMap(tail).flatMap(print)// 等同于readFile(&apos;./user.txt&apos;).chain(tail).chain(print) 上面代码读取了文件user.txt，然后选取最后一行输出。","categories":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://93qlin.github.io/categories/函数式编程/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"},{"name":"体会","slug":"体会","permalink":"https://93qlin.github.io/tags/体会/"}]},{"title":"事件绑定、事件监听、事件委托（事件代理）","slug":"事件绑定、事件监听、事件委托（事件代理）","date":"2019-02-28T03:12:12.516Z","updated":"2019-02-28T03:12:12.516Z","comments":true,"path":"2019/02/28/事件绑定、事件监听、事件委托（事件代理）/","link":"","permalink":"https://93qlin.github.io/2019/02/28/事件绑定、事件监听、事件委托（事件代理）/","excerpt":"","text":"事件绑定、事件监听、事件委托（事件代理）(http://www.jb51.net/article/93752.htm)事件绑定 要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。在JavaScript中，有三种常用的绑定事件的方法：在DOM元素中直接绑定；在JavaScript代码中绑定；绑定事件监听函数。在DOM中直接绑定事件我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。好多不一一列出了。如果想知道更多事件类型请查看， DOM事件 。123456789101112&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;hello()&quot;&gt;&lt;script&gt;function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;hello()&quot;&gt;&lt;script&gt;function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 在JavaScript代码中绑定事件在JavaScript代码中（即 script 标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。123456&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn&quot;).onclick = function()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; ##使用事件监听绑定事件 绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。下面详细介绍，事件监听。事件监听关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范。W3C规范语法：element.addEventListener(event, function, useCapture)event : （必需）事件名，支持所有 DOM事件 。function：（必需）指定要事件触发时执行的函数。useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。注：IE8以下不支持。1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn1&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn1&quot;).addEventListener(&quot;click&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; IE标准 语法：element.attachEvent(event, function)event：（必需）事件类型。需加“on“，例如：onclick。function：（必需）指定要事件触发时执行的函数。1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn2&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn2&quot;).attachEvent(&quot;onclick&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 事件监听的优点1、可以绑定多个事件。12345678910&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn3&quot;&gt;&lt;script&gt;var btn3 = document.getElementById(&quot;btn3&quot;);btn3.onclick = function()&#123; alert(&quot;hello 1&quot;); //不执行&#125;btn3.onclick = function()&#123; alert(&quot;hello 2&quot;); //执行&#125;&lt;/script&gt; 常规的事件绑定只执行最后绑定的事件。12345678910111213&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn4&quot;&gt;&lt;script&gt;var btn4 = document.getElementById(&quot;btn4&quot;);btn4.addEventListener(&quot;click&quot;,hello1);btn4.addEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 两个事件都执行了。 2、可以解除相应的绑定12345678910111213&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;&lt;script&gt;var btn5 = document.getElementById(&quot;btn5&quot;);btn5.addEventListener(&quot;click&quot;,hello1);//执行了btn5.addEventListener(&quot;click&quot;,hello2);//不执行btn5.removeEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 封装事件监听&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt; ####绑定监听事件1234567function addEventHandler(target,type,fn)&#123; if(target.addEventListener)&#123; target.addEventListener(type,fn); &#125;else&#123; target.attachEvent(&quot;on&quot;+type,fn); &#125;&#125; //移除监听事件1234567function removeEventHandler(target,type,fn)&#123; if(target.removeEventListener)&#123; target.removeEventListener(type,fn); &#125;else&#123; target.detachEvent(&quot;on&quot;+type,fn); &#125;&#125; //测试1234var btn5 = document.getElementById(&quot;btn5&quot;);addEventHandler(btn5,&quot;click&quot;,hello1);//添加事件hello1addEventHandler(btn5,&quot;click&quot;,hello2);//添加事件hello2removeEventHandler(btn5,&quot;click&quot;,hello1);//移除事件hello1 事件委托事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。123456789&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn6&quot;&gt;var btn6 = document.getElementById(&quot;btn6&quot;);document.onclick = function(event)&#123; event = event || window.event; var target = event.target || event.srcElement; if(target == btn6)&#123; alert(btn5.value); &#125;&#125; 上面只是个例子，代码尽可能的简化了。在实际的代码中 我们可能用到jQuery的live()、delegate()、bind()、on()等。事件委托优点1、提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。 实例分析JavaScript中的事件委托和事件绑定 ，这篇文章写得还不错。传统写法12345678910111213141516171819&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);item1.onclick = function()&#123; alert(&quot;hello item1&quot;);&#125;item2.onclick = function()&#123; alert(&quot;hello item2&quot;);&#125;item3.onclick = function()&#123; alert(&quot;hello item3&quot;);&#125;&lt;/script&gt; 事件委托1234567891011121314151617181920&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target == item1)&#123; alert(&quot;hello item1&quot;); &#125;else if(target == item2)&#123; alert(&quot;hello item2&quot;); &#125;else if(target == item3)&#123; alert(&quot;hello item3&quot;); &#125;&#125;)&lt;/script&gt; 2、动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。传统写法1234567891011121314151617181920&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);var item = list.getElementsByTagName(&quot;li&quot;);for(var i=0;i&lt;item.length;i++)&#123; (function(i)&#123; item[i].onclick = function()&#123; alert(item[i].innerHTML); &#125; &#125;)(i)&#125;var node=document.createElement(&quot;li&quot;);var textnode=document.createTextNode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。 事件委托123456789101112131415161718&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target.nodeName == &quot;LI&quot;)&#123; alert(target.innerHTML); &#125;&#125;)var node=document.createElement(&quot;li&quot;);var textnode=document.createTextNode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt;","categories":[{"name":"事件绑定、事件监听、事件委托（事件代理）","slug":"事件绑定、事件监听、事件委托（事件代理）","permalink":"https://93qlin.github.io/categories/事件绑定、事件监听、事件委托（事件代理）/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"}]},{"title":"算法","slug":"js算法","date":"2019-02-28T03:12:12.515Z","updated":"2019-02-28T03:12:12.515Z","comments":true,"path":"2019/02/28/js算法/","link":"","permalink":"https://93qlin.github.io/2019/02/28/js算法/","excerpt":"","text":"JS实现的数组全排列输出算法 从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。1234567891011121314151617181920function permute(input) &#123; var permArr = [], usedChars = []; function main(input)&#123; var i, ch; for (i = 0; i &lt; input.length; i++) &#123; ch = input.splice(i, 1)[0]; usedChars.push(ch); if (input.length == 0) &#123; permArr.push(usedChars.slice()); &#125; main(input); input.splice(i, 0, ch); usedChars.pop(); &#125; return permArr &#125; return main(input);&#125;;console.log(permute([5, 3, 7, 1])); 判断一个单词是否是回文？回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider .123function checkPalindrom(str) &#123; return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;);&#125; 去掉一组整型数组重复的值比如 输入: [1,13,24,11,11,14,1,2]， 输出: [1,13,24,11,14,2] ，需要去掉重复的11 和 1 这两个元素。123456789101112function(arr) &#123; let hashTable = &#123;&#125;; let data = []; for(let i=0,l=arr.length;i&lt;l;i++) &#123; if(!hashTable[arr[i]]) &#123; hashTable[arr[i]] = true; data.push(arr[i]); &#125; &#125; return data&#125; 随机生成指定长度的字符串实现一个算法，随机生成指制定长度的字符窜。12345678910function randomString(n) &#123; let str = &apos;abcdefghijklmnopqrstuvwxyz9876543210&apos;; let tmp = &apos;&apos;, i = 0, l = str.length; for (i = 0; i &lt; n; i++) &#123; tmp += str.charAt(Math.floor(Math.random() * l)); &#125; return tmp;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://93qlin.github.io/categories/算法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://93qlin.github.io/tags/算法/"}]},{"title":"react基础","slug":"react基础","date":"2019-02-28T03:12:12.515Z","updated":"2019-02-28T03:12:12.515Z","comments":true,"path":"2019/02/28/react基础/","link":"","permalink":"https://93qlin.github.io/2019/02/28/react基础/","excerpt":"","text":"react基础121.npm install -g create-react-app2.create-react-app 项目名称 redux1管理数据源和所有状态，负责展示的组件都可以采用无状态函数式的写法 组件类别有状态，无状态（也叫函数式组件），1有状态（state）:相同输入相同，输出结果可能不同。 1234567无状态组件：无生命周期，只负责根据传入的props来展示，不涉及到要state状态的操作，相同输入，必定输出相同***何时使用：1.无需state,即不处理用户输入，组件所有数据都依赖props传入2.不需要用到生命周期函数***好处：1.不需要生命类，避免大量的extends或constuctor这样的代码，简洁2.不需要显示声明this,函数式声明的好处不需要像es6那样声明中将this绑定到当前作用域 写法3种：12345678910111213141516171819202122232425262728293031323334351.早期es5的写法 react.createClass(&#123;...&#125;)2.es6写法（有状态组件用比较好）: react.Componentexport default class Home extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; age: props.age, status: 0 &#125; setTimeout(() =&gt; &#123; this.setState(&#123; status: 1 &#125;) &#125;, 3000) &#125; onMakeOlder() &#123; this.age += 3; this.setState(&#123; age: this.state.age + 3 &#125;) &#125;......3.无状态写法import React from &apos;react&apos;;const Header = (pros) =&gt; &#123; return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col-xs-1 col-xs-offset-11&quot;&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )&#125;;export default Header; 用法1 .闭合2.不闭合(父组件可以传内容过去)1234&lt;Home name=&#123;&quot;max&quot;&#125; age=&#123;12&#125; user=&#123;user&#125;/&gt;&lt;Home name=&#123;&quot;max&quot;&#125; age=&#123;12&#125; user=&#123;user&#125;&gt; &lt;p&gt;I am child&lt;/p&gt;&lt;/Home&gt; 动态输出数据1表达式： &#123;&#125;只能在一行 组件间数据传递定义类型：123456789101112131415161718192021222324import React, &#123; Component &#125; from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;export default class Home extends Component &#123; render() &#123; return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col-xs-1 col-xs-offset-11&quot;&gt; &lt;h1&gt; Home, name is &#123; this.props.name&#125;, age is &#123;this.props.age &#125;&lt;/h1&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((habby,index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;habby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;Home.propTypes = &#123; name: PropTypes.string, age: PropTypes.number, user: PropTypes.object&#125;; 1.父传子：传值1234&lt;Home name=&#123;&quot;max&quot;&#125; age=&#123;12&#125; user=&#123;user&#125;/&gt;&lt;Home name=&#123;&quot;max&quot;&#125; age=&#123;12&#125; user=&#123;user&#125;&gt; &lt;p&gt;I am child&lt;/p&gt;&lt;/Home&gt; 传方法 父组件定义方法1234567父：class App extends Component &#123; onGreet() &#123; alert(&quot;hello!&quot;); &#125; render() &#123; const user ..... 2.1父：&lt;Home name=&#123;&quot;max&quot;&#125; age=&#123;12&#125; user=&#123;user&#125; greet=&#123;this.onGreet&#125;/&gt; 3.1子： &lt;button className=&quot;btn btn-primary&quot; onClick=&#123;this.props.greet&#125;&gt;&lt;/button&gt; 3.121.兄弟或无关组件： eventEmitter(npm 包)2.发布订阅模式 2.子传父：….. 3.子传子 过程：子 =&gt; 父 =&gt; 子 首先父组件定义一个方法来改变当前的state，然后把事件传给一个子组件，当这个子组件触发这个事件并传值改变父组件的state，然后另一个子组件拿的那个父组件的值也相应更改 虚拟DOM（体现性能高） 改变该改变的地方，不用重新渲染 每操作一遍都会生成一个虚拟的DOM和之前的作比较（diff运算，找到改变的地方重新渲染） 看怎么改变局部 f12 =&gt;…=&gt; more tools =&gt; rending =&gt; paint flashing打钩 事件123456789101112131415161718192021222324252627282930export default class Home extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; age: props.age &#125; this.age = this.props.age; &#125; onMakeOlder() &#123; this.age += 3; this.setState(&#123; age: this.state.age + 3 &#125;) &#125; render() &#123; return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col-xs-1 col-xs-offset-11&quot;&gt; &lt;h1&gt; Home, name is &#123; this.props.name&#125;, age is &#123;this.state.age &#125;&lt;/h1&gt; &#123;/* &lt;ul&gt; &#123;this.props.user.hobbies.map((habby,index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;habby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; */&#125; &lt;button onClick=&#123;this.onMakeOlder.bind(this)&#125; className=&quot;btn btn-primary&quot;&gt;Make me older&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125; 组件的生命周期 1.Mounting(被挂载时) 12componentWillMount 在渲染前调用,在客户端也在服务端。componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。 2.Updating(更新时) 12345componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。shouldComponentUpdate（可以发送请求） 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。 3.Unmounting(移除时) 1componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。","categories":[{"name":"react","slug":"react","permalink":"https://93qlin.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://93qlin.github.io/tags/react/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"}]},{"title":"react+dva+mock","slug":"react+dva+mock.js","date":"2019-02-28T03:12:12.515Z","updated":"2019-02-28T03:12:12.515Z","comments":true,"path":"2019/02/28/react+dva+mock.js/","link":"","permalink":"https://93qlin.github.io/2019/02/28/react+dva+mock.js/","excerpt":"","text":"mock.js1.在.roadhogrc.mock.js文件下（https://github.com/sorrycc/roadhog）roadhog使用文档12345678910export default &#123; // Support type as Object and Array &apos;GET /api/users&apos;: &#123; users: [1,2] &#125;, // Method like GET or POST can be omitted &apos;/api/users/1&apos;: &#123; id: 1 &#125;, // Support for custom functions, the API is the same as express@4 &apos;POST /api/users/create&apos;: (req, res) =&gt; &#123; res.end(&apos;OK&apos;); &#125;, &#125;; 2.就可使用 12345678910111213141516171819202122 import React from &apos;react&apos;;import &#123; connect &#125; from &apos;dva&apos;;import styles from &apos;./IndexPage.css&apos;;import axios from &apos;axios&apos;function IndexPage() &#123; return ( &lt;div className=&#123;styles.normal&#125;&gt; &lt;button onClick=&#123;() =&gt; axios.get(&apos;/api/users&apos;)&#125;&gt;click me&lt;/button&gt; &lt;h1 className=&#123;styles.title&#125;&gt;Yay! Welcome to dva!&lt;/h1&gt; &lt;div className=&#123;styles.welcome&#125; /&gt; &lt;ul className=&#123;styles.list&#125;&gt; &lt;li&gt;To get started, edit &lt;code&gt;src/index.js&lt;/code&gt; and save to reload.&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/dvajs/dva-docs/blob/master/v1/en-us/getting-started.md&quot;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );&#125;IndexPage.propTypes = &#123;&#125;;export default connect()(IndexPage); 优化,在mock文件夹下统一维护1.mock文件夹下新建users.js等1234module.exports = &#123; &apos;GET /api/users&apos;: &#123; users: [1,2] &#125;,&#125; 2..roadhogrc.mock.js文件改为1234export default &#123; ...require(&apos;./mock/users&apos;), ...require(&apos;./mock/posts&apos;), &#125;; 就可以了 另一种roadhogrc.mock.js文件处理方式 12345678910import fs from &apos;fs&apos;;import path from &apos;path&apos;;const mock = &#123;&#125;fs.readdirSync(path.join(__dirname + &apos;/mock&apos;)).forEach(function (file) &#123; if (file.match(/\\.js$/)) &#123; Object.assign(mock, require(&apos;./mock/&apos; + file)) &#125;&#125;)export default mock 可以接回调函数12345module.exports = &#123; // &apos;GET /api/users&apos;: &#123; users: [1,2] &#125;, &apos;GET /api/users&apos;: (req, res) =&gt; &#123;res.status(200).json(&#123;users: [1,2,3]&#125;) &#125;,&#125; 返回一个jsonuser.json1234[ &#123;&quot;a&quot;: 11&#125;, &#123;&quot;b&quot;:1&#125;] 然后:1234567891011// const data = [// &#123;a: 1&#125;,// &#123;b:1&#125;// ]const data = require(&apos;./user.json&apos;)module.exports = &#123; // &apos;GET /api/users&apos;: &#123; users: [1,2] &#125;, // &apos;GET /api/users&apos;: (req, res) =&gt; &#123;res.status(200).json(&#123;users: [1,2,3]&#125;) &#125;, &apos;GET /api/users&apos;: (req, res) =&gt; &#123;res.status(200).json(&#123;users: data&#125;) &#125;,&#125; 生成随机数据（https://github.com/nuysoft/Mock/wiki/Getting-Started）1234567891011121314const Mock = require(&apos;mockjs&apos;)module.exports = &#123; // &apos;GET /api/users&apos;: &#123; users: [1,2] &#125;, &apos;GET /api/users&apos;: (req, res) =&gt; &#123;res.status(200).json(&#123;users: Mock.mock(&#123; // 属性 list 的值是一个数组，其中含有 1 到 10 个元素 &apos;list|1-10&apos;: [&#123; // 属性 id 是一个自增数，起始值为 1，每次增 1 &apos;id|+1&apos;: 1 &#125;] &#125;) &#125;) &#125;,&#125; 得到：1&#123;&quot;users&quot;:&#123;&quot;list&quot;:[&#123;&quot;id&quot;:1&#125;,&#123;&quot;id&quot;:2&#125;,&#123;&quot;id&quot;:3&#125;,&#123;&quot;id&quot;:4&#125;,&#123;&quot;id&quot;:5&#125;,&#123;&quot;id&quot;:6&#125;,&#123;&quot;id&quot;:7&#125;,&#123;&quot;id&quot;:8&#125;,&#123;&quot;id&quot;:9&#125;,&#123;&quot;id&quot;:10&#125;]&#125;&#125; 数据模板定义(https://github.com/nuysoft/Mock/wiki/Syntax-Specification)(再对照官网) // 属性名 name// 生成规则 rule// 属性值 value‘name|rule’: value 数据占位符（https://github.com/nuysoft/Mock/wiki/Mock.Random）1234567var Random = Mock.RandomRandom.email()// =&gt; &quot;n.clark@miller.io&quot;Mock.mock(&apos;@email&apos;)// =&gt; &quot;y.lee@lewis.org&quot;Mock.mock( &#123; email: &apos;@email&apos; &#125; )// =&gt; &#123; email: &quot;v.lewis@hall.gov&quot; &#125; 123456789101112const Mock = require(&apos;mockjs&apos;)module.exports = &#123; // &apos;GET /api/users&apos;: &#123; users: [1,2] &#125;, &apos;GET /api/users&apos;: (req, res) =&gt; &#123;res.status(200).json(&#123;users: Mock.mock(&#123; &apos;email|10&apos;: [ &apos;@email&apos; ] &#125;) &#125;) &#125;,&#125; 得到：1&#123;&quot;users&quot;:&#123;&quot;email&quot;:[&quot;h.stwgfmvr@pbwcf.bs&quot;,&quot;i.njzexjrvwn@onrwqm.as&quot;,&quot;k.cslhnnq@vpreuhdvxc.tv&quot;,&quot;u.owivlgrc@bji.ar&quot;,&quot;t.pulpiwanp@ubh.aq&quot;,&quot;f.qcea@cxwgvt.vn&quot;,&quot;d.hcmz@iihjjr.ee&quot;,&quot;i.xsqtdssbw@cmvfjqmf.fm&quot;,&quot;c.jleblu@uidou.hr&quot;,&quot;q.hobb@dks.ye&quot;]&#125;&#125; 最后去别人的项目看别人怎么玩的 https://github.com/bowencool/dva-antd-admin/blob/master/mock/list.js https://github.com/LANIF-UI/dva-boot-admin/blob/master/src/utils/packMock.js https://github.com/Mesamo/dva-admin/blob/master/.roadhogrc.mock.js https://github.com/bj75326/B-A/blob/master/mock/notices.js https://github.com/zuiidea/antd-admin/blob/master/mock/user.js https://github.com/liuxx001/bird-front/blob/master/mock/common.js","categories":[{"name":"react+dva+mock","slug":"react-dva-mock","permalink":"https://93qlin.github.io/categories/react-dva-mock/"}],"tags":[{"name":"react","slug":"react","permalink":"https://93qlin.github.io/tags/react/"},{"name":"mock.js","slug":"mock-js","permalink":"https://93qlin.github.io/tags/mock-js/"}]},{"title":"redux-saga","slug":"redux-saga","date":"2019-02-28T03:12:12.515Z","updated":"2019-02-28T03:12:12.516Z","comments":true,"path":"2019/02/28/redux-saga/","link":"","permalink":"https://93qlin.github.io/2019/02/28/redux-saga/","excerpt":"","text":"记录学习redux-saga(https://flaviocopes.com/redux-saga/) generator的使用12345678910111213141516171819function* gen() &#123;var posts= yield $.getJSON(&quot;http://jsonplaceholder.typicode.com/posts&quot;)console.log(posts[0]); var users= yield $.getJSON(&quot;http://jsonplaceholder.typicode.com/users&quot;)console.log(users[0]);&#125;run(gen)function run(generator)&#123;var mygen = generator();function handle(yielded) &#123; if(!yielded.done)&#123; yielded.value.then(function(data)&#123; return handle(mygen.next(data)) &#125;) &#125;&#125;return handle(mygen.next())&#125; (https://flaviocopes.com/redux-saga/)Basic HelperstakeEvery()takeLatest()take()put()call()Running effects in parallelall()race() 123456789101112131415161718192021222324252627282930313233// import &#123;INCREMENT_ASYNC&#125; from &apos;../constants/counter&apos;import &#123; takeEvery ,call,put,all&#125; from &apos;redux-saga/effects&apos;import axios from &apos;axios&apos;import &#123; delay&#125; from &apos;redux-saga&apos;// import &#123;increment&#125; from &apos;../actions/counter&apos;// const delay = (ms) =&gt; new Promise(resolve =&gt; setTimeout(resolve,ms))function* incrementAsync() &#123; // yield delay(2000); yield call(delay,2000); //yield put(increment()) yield put(&#123;type:&apos;INCREMENT&apos;&#125;)&#125;function* fetchUser() &#123; const user = yield call(axios.get,&apos;http://jsonplaceholder.typicode.com/users&apos;) // const [todos,user] = yield all([ // call(axios.get,&apos;http://jsonplaceholder.typicode.com/todos&apos;), // call(axios.get,&apos;http://jsonplaceholder.typicode.com/users&apos;), // ]) // console.log(todos) console.log(user)&#125;function* watchIncrementAsync()&#123; yield takeEvery(&quot;INCREMENT_ASYNC&quot;, incrementAsync);&#125;function* watchFetchUser()&#123; yield takeEvery(&quot;FETCH_USER_REQUEST&quot;, fetchUser);&#125;export default function* rootSaga()&#123; yield all([ //并发任务，同时执行不必等待 watchIncrementAsync(), watchFetchUser() ])&#125; 组织代码不用一个个导入方式1123456789101112131415161718import &#123; all, fork&#125; from &apos;redux-saga/effects&apos;// import &#123; watchIncrementAsync &#125; from &apos;./counter&apos;// import &#123; watchFetchUser,watchFetchTodos &#125; from &apos;./user&apos;import * as counterSagas from &apos;./counter&apos;import * as userSagas from &apos;./user&apos;export default function* rootSaga()&#123; // yield all([ //并发任务，同时执行不必等待 // watchIncrementAsync(), // watchFetchUser(), // watchFetchTodos() // ]) yield all([ //并发任务，同时执行不必等待 ...Object.values(counterSagas), ...Object.values(userSagas) ].map(fork))&#125; 组织代码不用一个个导入方式2直接在各自文件最后export const counterSaga = [watchFetchUser(),watchFetchTodos()]","categories":[{"name":"redux-saga","slug":"redux-saga","permalink":"https://93qlin.github.io/categories/redux-saga/"}],"tags":[{"name":"react","slug":"react","permalink":"https://93qlin.github.io/tags/react/"},{"name":"es6","slug":"es6","permalink":"https://93qlin.github.io/tags/es6/"},{"name":"redux-saga","slug":"redux-saga","permalink":"https://93qlin.github.io/tags/redux-saga/"},{"name":"递归","slug":"递归","permalink":"https://93qlin.github.io/tags/递归/"}]},{"title":"hook","slug":"react钩子 hook","date":"2019-02-28T03:12:12.515Z","updated":"2019-02-28T03:12:12.515Z","comments":true,"path":"2019/02/28/react钩子 hook/","link":"","permalink":"https://93qlin.github.io/2019/02/28/react钩子 hook/","excerpt":"","text":"` hook","categories":[{"name":"hook","slug":"hook","permalink":"https://93qlin.github.io/categories/hook/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://93qlin.github.io/tags/JavaScript/"},{"name":"hook","slug":"hook","permalink":"https://93qlin.github.io/tags/hook/"}]},{"title":"接口和多态","slug":"java接口和多态","date":"2019-02-28T03:12:12.515Z","updated":"2019-02-28T03:12:12.515Z","comments":true,"path":"2019/02/28/java接口和多态/","link":"","permalink":"https://93qlin.github.io/2019/02/28/java接口和多态/","excerpt":"","text":"接口1.1接口概念 ==接口是功能的集合==，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。请记住：==一切事物均有功能，即一切事物均有接口==。 1.2接口定义 与定义类的class不同，接口定义时需要使用interface关键字。定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。这点可以让我们将接口看做是一种只包含了功能声明的特殊类。定义格式：public interface 接口名 { &nbsp;&nbsp;&nbsp;&nbsp;抽象方法1; &nbsp;&nbsp;&nbsp;&nbsp;抽象方法2; &nbsp;&nbsp;&nbsp;&nbsp;抽象方法3;}使用interface代替了原来的class，其他步骤与定义类相同： ==接口中的方法均为公共访问的抽象方法== ==接口中无法定义普通的成员变量==。","categories":[{"name":"接口和多态","slug":"接口和多态","permalink":"https://93qlin.github.io/categories/接口和多态/"}],"tags":[{"name":"java","slug":"java","permalink":"https://93qlin.github.io/tags/java/"},{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"}]},{"title":"Show Time","slug":"hello-world","date":"2019-02-28T03:12:12.515Z","updated":"2019-02-28T03:12:12.515Z","comments":true,"path":"2019/02/28/hello-world/","link":"","permalink":"https://93qlin.github.io/2019/02/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy tags_title: Tagsarchives_title: Archivescategories_title: CategoriesMore info: Deployment","categories":[],"tags":[]},{"title":"dva","slug":"dva","date":"2019-02-28T03:12:12.514Z","updated":"2019-02-28T03:12:12.515Z","comments":true,"path":"2019/02/28/dva/","link":"","permalink":"https://93qlin.github.io/2019/02/28/dva/","excerpt":"","text":"connect mapStateToProps两种写法1.// const mapStateToProps = (state) =&gt; {// return {// counter: state.counter// }// }2.const mapStateToProps = ({ counter }) =&gt; ({ counter, }) export default connect(mapStateToProps)(CounterPage) 向子组件传值方式1，可以将所有的props包含siapach,路由信息等传过去，也许子组件用到12345678910const CounterPage = (props) =&gt; &#123; return( &lt;div&gt; &lt;div&gt;Counter&lt;/div&gt; &lt;Counter &#123; ...props &#125;/&gt; &lt;/div&gt; )&#125; 方式212345678910const CounterPage = (&#123;counter&#125;) =&gt; &#123; return( &lt;div&gt; &lt;div&gt;Counter&lt;/div&gt; &lt;Counter counter=&#123;counter&#125;/&gt; &lt;/div&gt; )&#125; 触发action dispath： 命名空间 + ‘/‘+ 要触发的子组件123456789const Counter = (&#123;counter,dispatch&#125;) =&gt; &#123; // console.log(props.counter) return ( &lt;div&gt; &lt;h1&gt;&#123;counter.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/add&apos;&#125;)&#125;&#125;&gt;+&lt;/button&gt; 找到counte并触发add,不用维护常量 &lt;/div&gt; )&#125; counter的add1234567reducers: &#123; add(state, action) &#123; return &#123; count: state.count + 1 &#125; &#125; &#125;, 还可以这样写1&lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/login/start&apos;&#125;)&#125;&#125;&gt;+&lt;/button&gt; 项目复杂，有层次感1234567reducers: &#123; &apos;login/start&apos;(state, action) &#123; return &#123; count: state.count + 1 &#125; &#125; &#125;, 处理异步1&lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; 12345678910import &#123;delay&#125; from &apos;dva/saga&apos;effects: &#123; const counter = yield select(state =&gt; state.counter) // ** selset的作用 **取出state的值 // const counter = yield select(state =&gt; state.counter) //const &#123;counter&#125; = yield select(_ =&gt; _) // const counter = yield select((&#123;counter&#125;) =&gt; counter) // ** 四种写法 ** yield call(delay,1000) yield put(&#123; type: &apos;add&apos; &#125;); &#125;, &#125; 统一处理model里的文件不用一个个写：之前在index文件里123// 3. Modelapp.model(require(&apos;./models/counter&apos;).default);app.model(require(&apos;./models/example&apos;).default); 现在在model文件夹里新建index文件遍历其他文件利用webpack的 require.context 12345const context = require.context(&apos;./&apos;,false,/\\.js$/);export default context .keys() .filter(item =&gt; item !== &apos;./index.js&apos;) .map(key =&gt; context(key)) 1require(&apos;./models&apos;).default.forEach(key =&gt; app.model(key.default)) 在dva里使用redux-action,解决多个文件dispatch的问题npm install –save redux-actions yarn add redux-actions 1.src下新建actions文件夹，新建index文件123import &#123;createAction&#125; from &apos;redux-actions&apos;export const counterAdd=createAction(&apos;counter/add&apos;)export const counterAsyncAdd=createAction(&apos;counter/asyncAdd&apos;) 父组件123456789101112131415161718192021222324252627import React from &apos;react&apos;import Counter from &apos;../components/Counter&apos;import &#123;connect&#125; from &apos;dva&apos;import PropTypes from &apos;prop-types&apos;** import &#123;counterAdd, counterAsyncAdd&#125; from &apos;../actions&apos; **const CounterPage = (&#123;counter, dispatch, counterAdd, counterAsyncAdd&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;div&gt;Counter&lt;/div&gt; &lt;Counter counterAdd=&#123;counterAdd&#125; counterAsyncAdd=&#123;counterAsyncAdd&#125; counter=&#123;counter&#125; dispatch=&#123;dispatch&#125;/&gt; &lt;/div&gt; )&#125;Counter.prototypes = &#123; counter: PropTypes.object&#125;// const mapStateToProps = (state) =&gt; &#123; return &#123; counter: state.counter// &#125; &#125;const mapStateToProps = (&#123;counter&#125;) =&gt; (&#123;counter&#125;)export default connect(mapStateToProps, &#123;counterAdd, counterAsyncAdd&#125;)(CounterPage) 子组件123456789101112131415161718192021import React from &apos;react&apos;import &#123;connect&#125; from &apos;dva&apos; // eslint-disable-lineimport PropTypes from &apos;prop-types&apos; // eslint-disable-lineconst Counter = (&#123;counter,dispatch, counterAdd, counterAsyncAdd&#125;) =&gt; &#123; // console.log(props.counter) console.log(counterAsyncAdd); return ( &lt;div&gt; &lt;h1&gt;&#123;counter.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/add&apos;,name: &apos;action1&apos;&#125;)&#125;&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAdd()&#125;&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAsyncAdd()&#125;&#125;&gt;+ async&lt;/button&gt; &lt;/div&gt; )&#125;export default Counter 路由跳转五种方式1.一层层跳转router.js1234567891011121314151617import React from &apos;react&apos;;import &#123; Router, Route, Switch &#125; from &apos;dva/router&apos;;import IndexPage from &apos;./routes/IndexPage&apos;;import CounterPage from &apos;./routes/CounterPage&apos;;function RouterConfig(&#123; history &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125; /&gt; &lt;Route path=&quot;/counter&quot; exact component=&#123;CounterPage&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;export default RouterConfig; 父组件12345678910111213141516171819202122232425262728import React from &apos;react&apos;import Counter from &apos;../components/Counter&apos;import &#123;connect&#125; from &apos;dva&apos;import PropTypes from &apos;prop-types&apos;import &#123;counterAdd, counterAsyncAdd&#125; from &apos;../actions&apos;const CounterPage = (&#123;counter, dispatch, counterAdd, counterAsyncAdd,history&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;div&gt;Counter&lt;/div&gt; &lt;Counter counterAdd=&#123;counterAdd&#125; counterAsyncAdd=&#123;counterAsyncAdd&#125; counter=&#123;counter&#125; dispatch=&#123;dispatch&#125; history = &#123;history&#125;/&gt; &lt;/div&gt; )&#125;Counter.prototypes = &#123; counter: PropTypes.object&#125;// const mapStateToProps = (state) =&gt; &#123; return &#123; counter: state.counter// &#125; &#125;const mapStateToProps = (&#123;counter&#125;) =&gt; (&#123;counter&#125;)export default connect(mapStateToProps, &#123;counterAdd, counterAsyncAdd&#125;)(CounterPage) 子组件12345678910111213141516171819202122import React from &apos;react&apos;import &#123;connect&#125; from &apos;dva&apos; // eslint-disable-lineimport PropTypes from &apos;prop-types&apos; // eslint-disable-lineconst Counter = (&#123;counter,dispatch, counterAdd, counterAsyncAdd,history&#125;) =&gt; &#123; // console.log(props.counter) // console.log(counterAsyncAdd); return ( &lt;div&gt; &lt;h1&gt;&#123;counter.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; history.push(&apos;./&apos;)&#125;&gt;GO HOME&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAdd()&#125;&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAsyncAdd()&#125;&#125;&gt;+ async&lt;/button&gt; &lt;/div&gt; )&#125;export default Counter 2.withRouter(解决不是父子关系，难以一层层传递history的问题) 传统：import {withRouter} from ‘react-router-dom’ 在dva中：import {withRouter} from ‘dva/router’ 在需要的组件中包裹一下 12345678910111213141516171819202122 import React from &apos;react&apos;import &#123;connect&#125; from &apos;dva&apos; // eslint-disable-lineimport PropTypes from &apos;prop-types&apos; // eslint-disable-lineimport &#123;withRouter&#125; from &apos;dva/router&apos;const Counter = (&#123;counter,dispatch, counterAdd, counterAsyncAdd,history&#125;) =&gt; &#123; // console.log(props.counter) // console.log(counterAsyncAdd); return ( &lt;div&gt; &lt;h1&gt;&#123;counter.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; history.push(&apos;./&apos;)&#125;&gt;GO HOME&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAdd()&#125;&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAsyncAdd()&#125;&#125;&gt;+ async&lt;/button&gt; &lt;/div&gt; )&#125;export default withRouter(Counter) 3.Link方式1234567891011121314151617181920212223import React from &apos;react&apos;import &#123;connect&#125; from &apos;dva&apos; // eslint-disable-lineimport PropTypes from &apos;prop-types&apos; // eslint-disable-lineimport &#123;withRouter,Link&#125; from &apos;dva/router&apos;const Counter = (&#123;counter,dispatch, counterAdd, counterAsyncAdd,history&#125;) =&gt; &#123; // console.log(props.counter) // console.log(counterAsyncAdd); return ( &lt;div&gt; &lt;h1&gt;&#123;counter.count&#125;&lt;/h1&gt; &lt;Link to=&apos;/&apos;&gt;home page&lt;/Link&gt; &lt;button onClick=&#123;() =&gt; history.push(&apos;./&apos;)&#125;&gt;GO HOME&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAdd()&#125;&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAsyncAdd()&#125;&#125;&gt;+ async&lt;/button&gt; &lt;/div&gt; )&#125;export default withRouter(Counter) 四.上下文123456789101112131415161718192021222324252627import React from &apos;react&apos;import &#123;connect&#125; from &apos;dva&apos; // eslint-disable-lineimport PropTypes from &apos;prop-types&apos; // eslint-disable-lineimport &#123;withRouter,Link&#125; from &apos;dva/router&apos;const Counter = (&#123;counter,dispatch, counterAdd, counterAsyncAdd,history&#125;,context) =&gt; &#123; // console.log(props.counter) // console.log(counterAsyncAdd); return ( &lt;div&gt; &lt;h1&gt;&#123;counter.count&#125;&lt;/h1&gt; &lt;Link to=&apos;/&apos;&gt;home page&lt;/Link&gt; &lt;button onClick=&#123;() =&gt; context.router.history.push(&apos;./&apos;)&#125;&gt;context go back&lt;/button&gt; &lt;button onClick=&#123;() =&gt; history.push(&apos;./&apos;)&#125;&gt;GO HOME&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/add&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAdd()&#125;&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;counterAsyncAdd()&#125;&#125;&gt;+ async&lt;/button&gt; &lt;/div&gt; )&#125;Counter.contextType = &#123; router: PropTypes&#125;export default withRouter(Counter) 五.routerRedux dispatch1234567891011121314151617181920212223242526import React from &apos;react&apos;import &#123;connect&#125; from &apos;dva&apos; // eslint-disable-lineimport PropTypes from &apos;prop-types&apos; // eslint-disable-lineimport &#123;withRouter,Link,routerRedux&#125; from &apos;dva/router&apos;const Counter = (&#123;counter,dispatch,history&#125;,context) =&gt; &#123; // console.log(props.counter) // console.log(counterAsyncAdd); return ( &lt;div&gt; &lt;h1&gt;&#123;counter.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; dispatch(routerRedux.push(&apos;./&apos;))&#125;&gt;routerRedux back&lt;/button&gt; &lt;Link to=&apos;/&apos;&gt;home page&lt;/Link&gt; &lt;button onClick=&#123;() =&gt; context.router.history.push(&apos;./&apos;)&#125;&gt;context go back&lt;/button&gt; &lt;button onClick=&#123;() =&gt; history.push(&apos;./&apos;)&#125;&gt;GO HOME&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/add&apos;&#125;)&#125;&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: &apos;counter/asyncAdd&apos;&#125;)&#125;&#125;&gt;+ async&lt;/button&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; )&#125;Counter.contextType = &#123; router: PropTypes.object&#125;export default withRouter(Counter) 所以可以在异步中处理（effect）1234567891011121314151617181920212223242526272829303132333435import &#123;delay&#125; from &apos;dva/saga&apos;import &#123;routerRedux&#125; from &apos;dva/router&apos;export default &#123; namespace: &apos;counter&apos;, //命名空间相当于scoped state: &#123; //可以定义很多类型 state: 1 count: 2 &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; // eslint-disable-line &#125;, &#125;, effects: &#123; *asyncAdd(&#123; payload &#125;, &#123; call, put, select &#125;) &#123; // eslint-disable-line //const counter = yield select(state =&gt; state.counter) //const counter = yield select(_ =&gt; _.counter) //const &#123;counter&#125; = yield select(_ =&gt; _) const counter = yield select((&#123;counter&#125;) =&gt; counter) // eslint-disable-line yield call(delay,1000) yield put(&#123; type: &apos;add&apos; &#125;); yield put(routerRedux.push(&apos;/&apos;)); &#125;, &#125;, reducers: &#123; add(state, action) &#123; return &#123; count: state.count + 1 &#125; &#125;, // &apos;login/start&apos;(state, action) &#123; // return &#123; // count: state.count + 1 // &#125; // &#125; &#125;,&#125;; 也可以这样写1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123;delay&#125; from &apos;dva/saga&apos;import &#123;routerRedux&#125; from &apos;dva/router&apos;export default &#123; namespace: &apos;counter&apos;, //命名空间相当于scoped state: &#123; //可以定义很多类型 state: 1 count: 2 &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; // eslint-disable-line &#125;, &#125;, effects: &#123; *asyncAdd(&#123; payload &#125;, &#123; call, put, select &#125;) &#123; // eslint-disable-line //const counter = yield select(state =&gt; state.counter) //const counter = yield select(_ =&gt; _.counter) //const &#123;counter&#125; = yield select(_ =&gt; _) const counter = yield select((&#123;counter&#125;) =&gt; counter) // eslint-disable-line yield call(delay,1000) yield put(&#123; type: &apos;add&apos; &#125;); yield put(routerRedux.push(&#123; pathname: &apos;/&apos;, hash: &apos;hello&apos; &#125;)); &#125;, &#125;, reducers: &#123; add(state, action) &#123; return &#123; count: state.count + 1 &#125; &#125;, // &apos;login/start&apos;(state, action) &#123; // return &#123; // count: state.count + 1 // &#125; // &#125; &#125;,&#125;; http://localhost:8000/#hello还可以这样写先装个插件npm install query-string作用转换查询字符串等等123456789101112console.log(location.hash);//=&gt; &apos;#token=bada55cafe&apos;const parsedHash = queryString.parse(location.hash);console.log(parsedHash);//=&gt; &#123;token: &apos;bada55cafe&apos;&#125;parsed.foo = &apos;unicorn&apos;;parsed.ilike = &apos;pizza&apos;;const stringified = queryString.stringify(parsed);//=&gt; &apos;foo=unicorn&amp;ilike=pizza&apos; 1234567891011121314151617181920212223242526272829303132333435import &#123;delay&#125; from &apos;dva/saga&apos;import &#123;routerRedux&#125; from &apos;dva/router&apos;import querySting from &apos;query-string&apos;export default &#123; namespace: &apos;counter&apos;, //命名空间相当于scoped state: &#123; //可以定义很多类型 state: 1 count: 2 &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; // eslint-disable-line &#125;, &#125;, effects: &#123; *asyncAdd(&#123; payload &#125;, &#123; call, put, select &#125;) &#123; // eslint-disable-line //const counter = yield select(state =&gt; state.counter) //const counter = yield select(_ =&gt; _.counter) //const &#123;counter&#125; = yield select(_ =&gt; _) const counter = yield select((&#123;counter&#125;) =&gt; counter) // eslint-disable-line yield call(delay,1000) yield put(&#123; type: &apos;add&apos; &#125;); yield put(routerRedux.push(&#123; pathname: &apos;/&apos;, search: querySting.stringify(&#123; from: &apos;深圳&apos; &#125;) &#125;)); &#125;, &#125;, reducers: &#123; add(state, action) &#123; return &#123; count: state.count + 1 &#125; &#125;&#125;; 得到 http://localhost:8000/?from=深圳 订阅 subscriptions （history,库正则匹配路径path-to-regexp(https://github.com/pillarjs/path-to-regexp), ） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import &#123;delay&#125; from &apos;dva/saga&apos;import &#123;routerRedux&#125; from &apos;dva/router&apos;import querySting from &apos;query-string&apos;import pathToRegexp from &apos;path-to-regexp&apos;export default &#123; namespace: &apos;counter&apos;, //命名空间相当于scoped state: &#123; //可以定义很多类型 state: 1 count: 2 &#125;, //通俗理解就是监听函数,里面的函数可以随便定义名称然后依次执行 subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; // eslint-disable-line window.onresize=() =&gt; &#123; dispatch(&#123; type:&apos;add&apos; &#125;) &#125; &#125;, onclick(&#123; dispatch, history &#125;) &#123; // eslint-disable-line document.addEventListener(&apos;click&apos;,()=&gt;&#123; dispatch(&#123;type: &apos;add&apos;&#125;); &#125;) &#125;, setupHistory(&#123; dispatch, history &#125;) &#123; // eslint-disable-line history.listen((location)=&gt;&#123; // if(location.pathname === &apos;/counter&apos;)&#123; // dispatch(&#123;type: &apos;add&apos;&#125;); // &#125; const match = pathToRegexp(&apos;/counter&apos;).exec(location.pathname) if(match)&#123; dispatch(&#123;type: &apos;add&apos;&#125;); &#125; &#125;) &#125;, &#125;, effects: &#123; *asyncAdd(&#123; payload &#125;, &#123; call, put, select &#125;) &#123; // eslint-disable-line //const counter = yield select(state =&gt; state.counter) //const counter = yield select(_ =&gt; _.counter) //const &#123;counter&#125; = yield select(_ =&gt; _) const counter = yield select((&#123;counter&#125;) =&gt; counter) // eslint-disable-line yield call(delay,1000) yield put(&#123; type: &apos;add&apos; &#125;); console.log(querySting,12) yield put(routerRedux.push(&#123; pathname: &apos;/&apos;, search: querySting.stringify(&#123; from: &apos;深圳&apos; &#125;) &#125;)); &#125;, &#125;, reducers: &#123; add(state, action) &#123; return &#123; count: state.count + 1 &#125; &#125;, // &apos;login/start&apos;(state, action) &#123; // return &#123; // count: state.count + 1 // &#125; // &#125; &#125;,&#125;; 实现一个简单的ajax1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import axios from &apos;axios&apos;export default &#123; namespace: &apos;user&apos;, state: &#123; isFetching: false, error: null, user: null &#125;, subscriptions: &#123; setup(&#123; dispatch, history &#125;) &#123; // eslint-disable-line &#125;, &#125;, effects: &#123; *fetch(_, &#123; call, put &#125;) &#123; // eslint-disable-line yield put(&#123; type: &apos;fetch/start&apos; &#125;); try &#123; const user = yield call(axios.get,&apos;http://jsonplaceholder.typicode.com/users&apos;) yield put(&#123;type:&apos;fetch/success&apos;,user:user&#125;) &#125;catch(e)&#123; yield put(&#123;type: &apos;fetch/error&apos;,error:e.message&#125;) &#125; &#125;, &#125;, reducers: &#123; &apos;fetch/start&apos;(state, action) &#123; return &#123; isFetching: true, error: null, user: null &#125; &#125;, &apos;fetch/success&apos;(state, action) &#123; return &#123; isFetching: false, error: null, user: action.user &#125; &#125;, &apos;fetch/error&apos;(state, action) &#123; return &#123; isFetching: false, error: action.error, user: null &#125; &#125;, &#125;,&#125;; 12345678910111213141516171819202122232425262728import React from &apos;react&apos;import PropTypes from &apos;prop-types&apos; // eslint-disable-lineimport &#123;connect&#125; from &apos;dva&apos;const User = (props) =&gt; &#123; const &#123;isFetching, error, user&#125; = props.user const&#123;dispatch&#125; = props let data if (error) &#123; data = error &#125; else if(isFetching)&#123; data= &apos;loading...&apos; &#125;else&#123; data = user&amp;&amp;user.data[0].name &#125; return ( &lt;div&gt; &lt;h1&gt;&#123;data&#125;&lt;/h1&gt; &lt;button onClick = &#123;() =&gt; &#123;dispatch(&#123;type:&apos;user/fetch&apos;&#125;)&#125;&#125;&gt;get user&lt;/button&gt; &lt;/div&gt; )&#125;User.propTypes = &#123;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123;user: state.user&#125;&#125;export default connect(mapStateToProps)(User) dva-loading(You don’t need to write showLoading and hideLoading any more.)1.npm install dva-loading –save 2.index.js里import createLoading from ‘dva-loading’;const app = dva();app.use(createLoading(opts)); 有异步动作的时候1234567const mapStateToProps = (state) =&gt; &#123; return &#123; user: state.user, loading: state.loading, &#125;&#125;export default connect(mapStateToProps)(User) console.log(props.loading);得到1234&#123;global: false, models: &#123;…&#125;, effects: &#123;…&#125;&#125;effects: &#123;&#125;__proto__: Objectglobal: falsemodels: &#123;&#125;__proto__: ObjectUserpage.js:5 &#123;global: true, models: &#123;…&#125;, effects: &#123;…&#125;&#125;effects: &#123;user/fetch: true&#125;global: truemodels: &#123;user: true&#125;__proto__: ObjectUserpage.js:5 &#123;global: true, models: &#123;…&#125;, effects: &#123;…&#125;&#125;Userpage.js:5 &#123;global: false, models: &#123;…&#125;, effects: &#123;…&#125;&#125; 好处是不用一个个model写 hideLoading,也可以单独控制，只要connect进来1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;import PropTypes from &apos;prop-types&apos; // eslint-disable-lineimport &#123;connect&#125; from &apos;dva&apos;const User = (props) =&gt; &#123; console.log(props.loading.global); // 全局设置只要有异步就会有变化 const &#123; error, user&#125; = props.user const&#123;dispatch&#125; = props let isFetching = props.loading.effects[&apos;user/fetch&apos;] let data if (error) &#123; data = error &#125; else if(isFetching)&#123; data= &apos;loading...&apos; &#125;else&#123; data = user&amp;&amp;user.data[0].name &#125; return ( &lt;div&gt; &lt;h1&gt;&#123;data&#125;&lt;/h1&gt; &lt;button onClick = &#123;() =&gt; &#123;dispatch(&#123;type:&apos;user/fetch&apos;&#125;)&#125;&#125;&gt;get user&lt;/button&gt; &lt;/div&gt; )&#125;User.propTypes = &#123;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; user: state.user, loading: state.loading, &#125;&#125;export default connect(mapStateToProps)(User) 传递app给RouterConfig123456789101112131415161718import React from &apos;react&apos;;import &#123; Router, Route, Switch &#125; from &apos;dva/router&apos;;import IndexPage from &apos;./routes/IndexPage&apos;;import CounterPage from &apos;./routes/CounterPage&apos;;import UserPage from &apos;./routes/Userpage&apos;function RouterConfig(&#123; history,app &#125;) &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Switch&gt; &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125; /&gt; &lt;Route path=&quot;/counter&quot; exact component=&#123;CounterPage&#125; /&gt; &lt;Route path=&quot;/user&quot; exact component=&#123;UserPage&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; );&#125;export default RouterConfig; onAction(fn | fn[])(在 action 被 dispatch 时触发，用于注册 redux 中间件。支持函数或函数数组格式)通过 redux-logger 打印日志：1234567891011121314151617181920212223242526272829303132333435363738import dva from &apos;dva&apos;;import &apos;./index.css&apos;;import &#123;createBrowserHistory as createHistory&#125; from &apos;history&apos;;import createLoading from &apos;dva-loading&apos;;import &#123; createLogger &#125; from &apos;redux-logger&apos;const logger = store =&gt; next =&gt; action =&gt; &#123; console.log(&apos;dispathing&apos;,action); let result = next(action) console.log(&apos;next state&apos;, store.getState()); return result&#125; // 自己写的中间件const error = store =&gt; next =&gt; action =&gt; &#123; try &#123; console.log(&apos;error&apos;); next(action) &#125; catch (e) &#123; console.log(&apos;error&apos;+ e); &#125;&#125; // 自己写的中间件// // 1. Initialize// const app = dva();const app = dva(&#123; history: createHistory(), onAction: [createLogger(),error]&#125;);// 2. Plugins// app.use(&#123;&#125;);app.use(createLoading());// 3. Model// app.model(require(&apos;./models/counter&apos;).default);// app.model(require(&apos;./models/example&apos;).default);require(&apos;./models&apos;).default.forEach(key =&gt; app.model(key.default))// 4. Routerapp.router(require(&apos;./router&apos;).default);// 5. Startapp.start(&apos;#root&apos;); extraReducers（可以解决提供reducer的插件在dva中的使用，也可以自定义） 放在index添假额外的数据，全局性的state,打开调试工具可以看到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import dva from &apos;dva&apos;;import &apos;./index.css&apos;;import &#123;createBrowserHistory as createHistory&#125; from &apos;history&apos;;import createLoading from &apos;dva-loading&apos;;import &#123; createLogger &#125; from &apos;redux-logger&apos;const logger = store =&gt; next =&gt; action =&gt; &#123; console.log(&apos;dispathing&apos;,action); let result = next(action) console.log(&apos;next state&apos;, store.getState()); return result&#125; // 自己写的中间件const error = store =&gt; next =&gt; action =&gt; &#123; try &#123; console.log(&apos;error&apos;); next(action) &#125; catch (e) &#123; console.log(&apos;error&apos;+ e); &#125;&#125; // 自己写的中间件const extraReducer = &#123; form (state=false,action)&#123; //form是命名空间namespace，类似user switch (action.type) &#123; case &apos;SHOW&apos;: return true; case &apos;HIDE&apos;: return false; default: return state &#125; &#125;&#125;// // 1. Initialize// const app = dva();const app = dva(&#123; history: createHistory(), onAction: [createLogger(),error], extraReducers: extraReducer&#125;);// 2. Plugins// app.use(&#123;&#125;);app.use(createLoading());// 3. Model// app.model(require(&apos;./models/counter&apos;).default);// app.model(require(&apos;./models/example&apos;).default);require(&apos;./models&apos;).default.forEach(key =&gt; app.model(key.default))// 4. Routerapp.router(require(&apos;./router&apos;).default);// 5. Startapp.start(&apos;#root&apos;); onEffect1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import dva from &apos;dva&apos;;import &apos;./index.css&apos;;import &#123;createBrowserHistory as createHistory&#125; from &apos;history&apos;;import createLoading from &apos;dva-loading&apos;;import &#123; createLogger &#125; from &apos;redux-logger&apos;const logger = store =&gt; next =&gt; action =&gt; &#123; console.log(&apos;dispathing&apos;,action); let result = next(action) console.log(&apos;next state&apos;, store.getState()); return result&#125; // 自己写的中间件const error = store =&gt; next =&gt; action =&gt; &#123; try &#123; console.log(&apos;error&apos;); next(action) &#125; catch (e) &#123; console.log(&apos;error&apos;+ e); &#125;&#125; // 自己写的中间件const extraReducer = &#123; form (state=false,action)&#123; //form是命名空间namespace，类似user switch (action.type) &#123; case &apos;SHOW&apos;: return true; case &apos;HIDE&apos;: return false; default: return state &#125; &#125;&#125;const onEffect = (effect,&#123;put&#125;,model,key) =&gt; &#123; return function*(...args)&#123; yield put(&#123;type: &apos;SHOW&apos;&#125;) yield effect(...args) yield put(&#123;type: &apos;HIDE&apos;&#125;) &#125;&#125;// // 1. Initialize// const app = dva();const app = dva(&#123; history: createHistory(), onAction: [createLogger(),error], extraReducers: extraReducer, onEffect: onEffect&#125;);// 2. Plugins// app.use(&#123;&#125;);app.use(createLoading());// 3. Model// app.model(require(&apos;./models/counter&apos;).default);// app.model(require(&apos;./models/example&apos;).default);require(&apos;./models&apos;).default.forEach(key =&gt; app.model(key.default))// 4. Routerapp.router(require(&apos;./router&apos;).default);// 5. Startapp.start(&apos;#root&apos;); 提供reducer的插件在dva中的使用（redux-form·react-intl-redux）","categories":[{"name":"dva","slug":"dva","permalink":"https://93qlin.github.io/categories/dva/"}],"tags":[{"name":"react","slug":"react","permalink":"https://93qlin.github.io/tags/react/"},{"name":"es6","slug":"es6","permalink":"https://93qlin.github.io/tags/es6/"},{"name":"dva","slug":"dva","permalink":"https://93qlin.github.io/tags/dva/"}]},{"title":"dva+roadhog","slug":"dva+roadhog","date":"2019-02-28T03:12:12.514Z","updated":"2019-02-28T03:12:12.514Z","comments":true,"path":"2019/02/28/dva+roadhog/","link":"","permalink":"https://93qlin.github.io/2019/02/28/dva+roadhog/","excerpt":"","text":"全局装个插件看dist文件夹里的内容（https://github.com/zeit/serve）然后进到dist文件夹运行serve命令就可以看到 配置多页面入口文件（https://github.com/sorrycc/roadhog） entry1.src下新建个counter.js12345678import React from &apos;react&apos;;import ReactDom from &apos;react-dom&apos;;const Counter = (props) =&gt; &#123; return ( &lt;div&gt;hi.counter&lt;/div&gt; )&#125;ReactDom.render(&lt;Counter /&gt;,document.getElementById(&apos;counter&apos;)) 2.在webpackrc里123456&#123; &quot;entry&quot;: &#123; &quot;index&quot;: &quot;./src/index.js&quot;, &quot;counter&quot;: &quot;./src/counter.js&quot; &#125;&#125; 3.在public新建counter.html文件然后在浏览器（http://localhost:8000/counter.html）就可以看到效果 两种使用css的方式， example.css3123456p&#123; color: red&#125;.yellow&#123; color: yellow&#125; example.js 1234567891011121314import React from &apos;react&apos;;import &apos;./Example.css&apos;import styles from &apos;./Example.css&apos;const Example = () =&gt; &#123; return ( &lt;div&gt; &lt;p&gt;Example&lt;/p&gt; &lt;h3 className=&#123;styles.yellow&#125;&gt;黄色&lt;/h3&gt; &lt;/div&gt; );&#125;;Example.propTypes = &#123;&#125;;export default Example; 使用less和scss1.less默认安装了直接像css那样使用2.scss文档说明了要安装（https://github.com/sorrycc/roadhog） sassConfigure the options for [node-sass] (https://github.com/sass/node-sass#options). Note: node-sass and sass-loader dependencies must be installed in the project directory when using sass.npm install –save dev node-sass sass-loader安装node-sass可能比较慢 代理 处理请求的首先跨域是和浏览器有关的（端口号，协议，或主机等不同），只是被浏览器阻止了，其他工具和程序访问可以访问，通过webpack程序当中间层充当代理 代理即避免浏览器直接访问远程 浏览器 访问 &lt;=&gt; webpack-dev-server 去代理访问 &lt;=&gt; 远程先安装axios之类的插件1.在在webpackrc里12345678910111213&#123; &quot;entry&quot;: &#123; &quot;index&quot;: &quot;./src/index.js&quot;, &quot;counter&quot;: &quot;./src/counter.js&quot; &#125;, &quot;proxy&quot;: &#123; &quot;/api&quot;: &#123; &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com/&quot;, &quot;changeOrigin&quot;: true, &quot;pathRewrite&quot;: &#123; &quot;^/api&quot; : &quot;&quot; &#125; &#125; &#125;&#125; 2.在文件中就可使用1234567891011121314151617181920import React from &apos;react&apos;;import axios from &apos;axios&apos;// import styles from &apos;./Example.css&apos;// import &apos;./Example.css&apos;import &apos;./Example.less&apos;const Example = () =&gt; &#123; return ( &lt;div&gt; &lt;p&gt;Example&lt;/p&gt; &lt;h3&gt;黄色&lt;/h3&gt; &lt;button onClick=&#123;() =&gt; &#123;axios.get(&apos;http://jsonplaceholder.typicode.com/users&apos;)&#125;&#125;&gt;普通请求&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;axios.get(&apos;/api/users&apos;)&#125;&#125;&gt;请求代理&lt;/button&gt; &lt;/div&gt; );&#125;;Example.propTypes = &#123;&#125;;export default Example;","categories":[{"name":"dva+roadhog","slug":"dva-roadhog","permalink":"https://93qlin.github.io/categories/dva-roadhog/"}],"tags":[{"name":"dva+roadhog","slug":"dva-roadhog","permalink":"https://93qlin.github.io/tags/dva-roadhog/"},{"name":"react","slug":"react","permalink":"https://93qlin.github.io/tags/react/"}]},{"title":"2018面试题","slug":"2018大厂面试题","date":"2019-02-28T03:12:12.514Z","updated":"2019-02-28T03:12:12.514Z","comments":true,"path":"2019/02/28/2018大厂面试题/","link":"","permalink":"https://93qlin.github.io/2019/02/28/2018大厂面试题/","excerpt":"","text":"以下是别人面试题汇总(原文没有答案，自己总结的)。 阿里（没有深入研究过node,也不想去研究,以后可能主要精力放在java上.）1.使用过的koa2中间件 2.koa-body原理 3.介绍自己写过的中间件 4.有没有涉及到Cluster 5.介绍pm2 6.master挂了的话pm2怎么处理 7.如何和MySQL进行通信 8.React生命周期及自己的理解 生命周期函数（钩子函数）通俗的说就是在某一时刻会被自动调用执行的函数。 生命周期可以分成四个部分： props,state,render()函数： 1. render()函数会在props,state改变时触发。 2.子组件的render()函数会在父组件render()执行的时候被执行（这会导致一些性能问题，我们可以在子组件的componentshouldupdate函数中进行判断，优化性能） 在render()，创建虚拟dom，进行diff算法，更新dom树。 注意：不要在render中修改state,会导致死循环。 1.初始化 在这里可以初始化props,state 2.挂载 ①：componentWillMount(): 注意：改生命周期在未来17版本中将被弃用(在这里请求异步数据，render可能不会渲染到，因为componentWillMount执行后，render立马执行) 组件被挂载到页面之前调用，整个生命周期中只会调用一次（组件更新时不会再调用）。 注意：在这里可修改state ②：componentDidMount()： 组件被挂载到页面之后调用，整个生命周期只调用一次（组件更新不会调用）。 建议：在这里可以异步请求数据。在这里设置状态会触发重新渲染。但是不推荐在这里使用setState函数，它会触发一次额外的渲染，而且是在浏览器刷新屏幕之前执行，用户看不到这个状态。在这里使用setState函数会导致性能问题。 new: getDerivedStateFromProps(nextProps,prevState) 3.更新 new: getDerivedStateFromProps(nextProps,prevState) 新的静态getDerivedStateFromProps 生命周期在组件实例化以及接收新props(只要父组件重新渲染，那么这个props不论值是否一样都是一个新的props)后调用。它可以返回一个对象来更新state，或者返回null来表示新的props不需要任何state更新。 new:getSnapshotBeforeUpdate() 新的getSnapshotBeforeUpdate 生命周期在更新之前被调用（例如，在DOM被更新之前）。此生命周期的返回值将作为第三个参数传递给componentDidUpdate。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。） ①： componentWillReceiveProps(nextprops): 注意：改生命周期在未来17版本中将被弃用 组件从父组件中接受了新的props(只要父组件重新渲染，那么这个props不论值是否一样都是一个新的props)，并且组件已经存在时调用。（组件初始化时候不调用）。 注意：可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用 ②： shouldComponentUpdate(nextprops,nextstate): 组件更新之前调用（组件接受新的props或者state）。函数会返回一个布尔值，true才会更新组件。 注意：最好判断一下新旧两个props/state是否相同，相同则返回false不要触发更新。这样就不用生成新的dom树和旧的进行diff算法对比，从而优化性能。（因为父组件render()调用会使得子组件render()也被执行，引起性能问题）！ ③：componentWillUpdate(nextprops,nextstate): 注意：改生命周期在未来17版本中将被弃用 组件更新之前（componentshouldupdate返回true）时调用，组件初始化时不调用 注意：在这里可以更改state，nextstate.xxx = xxx,但是在这里不能调用setState函数，这会导致函数调用componentshouldupdate从而进入死循环。 ④：componentDidUpdate(): 组件更新完成之后调用，组件初始化时候不调用。 注意：可以在这里获取dom 4.卸载 ①：componentWillUnmount(): 组件即将被卸载时执行 注意：在这里清除一些不需要的监听和计时器 如何配置React-Router 路由的动态加载模块 服务端渲染SSR 介绍路由的history 介绍Redux数据流的流程 Redux如何实现多个组件之间的通信，多个组件使用相同状态如何进行管理 多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块 使用过的Redux中间件 如何解决跨域的问题 常见Http请求头 移动端适配1px的问题 介绍flex布局 其他css方式设置垂直居中 居中为什么要使用transform（为什么不使用marginLeft/Top） 使用过webpack里面哪些plugin和loader webpack里面的插件是怎么实现的 dev-server是怎么跑起来 项目优化 抽取公共文件是怎么配置的 项目中如何处理安全问题 怎么实现this对象的深拷贝 网易介绍redux，主要解决什么问题 文件上传如何做断点续传 表单可以跨域吗 promise、async有什么区别 搜索请求如何处理（防抖） 搜索请求中文如何请求 介绍观察者模式 介绍中介者模式 观察者和订阅-发布的区别，各自用在哪里 介绍react优化 介绍http2.0 通过什么做到并发请求 http1.1时如何复用tcp连接 介绍service worker 介绍css3中position:sticky redux请求中间件如何处理并发 介绍Promise，异常捕获 介绍position属性包括CSS3新增 浏览器事件流向 介绍事件代理以及优缺点 React组件中怎么做事件代理 React组件事件代理的原理 介绍this各种情况 前端怎么控制管理路由 使用路由时出现问题如何解决 React怎么做数据的检查和变化 滴滴react-router怎么实现路由切换 react-router里的标签和标签有什么区别 标签默认事件禁掉之后做了什么才实现了跳转 React层面的性能优化 整个前端性能提升大致分几类 import { Button } from ‘antd’，打包的时候只打包button，分模块加载，是怎么做到的 使用import时，webpack对node_modules里的依赖会做什么 JS异步解决方案的发展历程以及优缺点 Http报文的请求会有几个部分 cookie放哪里，cookie能做的事情和存在的价值 cookie和token都存放在header里面，为什么只劫持前者 cookie和session有哪些方面的区别 React中Dom结构发生变化后内部经历了哪些变化 React挂载的时候有3个组件，textComponent、composeComponent、domComponent，区别和关系，Dom结构发生变化时怎么区分data的变化，怎么更新，更新怎么调度，如果更新的时候还有其他任务存在怎么处理 key主要是解决哪一类的问题，为什么不建议用索引index（重绘） Redux中异步的请求怎么处理 Redux中间件是什么东西，接受几个参数（两端的柯里化函数） 柯里化函数两端的参数具体是什么东西 中间件是怎么拿到store和action，然后怎么处理 state是怎么注入到组件的，从reducer到组件经历了什么样的过程 koa中response.send、response.rounded、response.json发生了什么事，浏览器为什么能识别到它是一个json结构或是html koa-bodyparser怎么来解析request webpack整个生命周期，loader和plugin有什么区别 介绍AST（Abstract Syntax Tree）抽象语法树 安卓Activity之间数据是怎么传递的 安卓4.0到6.0过程中WebView对js兼容性的变化 WebView和原生是如何通信 跨域怎么解决，有没有使用过Apache等方案 今日头条对async、await的理解，内部原理 介绍下Promise，内部实现 清除浮动 定位问题（绝对定位、相对定位等） 从输入URL到页面加载全过程 tcp3次握手 tcp属于哪一层（1 物理层 -&gt; 2 数据链路层 -&gt; 3 网络层(ip)-&gt; 4 传输层(tcp) -&gt; 5 应用层(http)） redux的设计思想 接入redux的过程 绑定connect的过程 connect原理 webpack介绍 == 和 ===的区别，什么情况下用相等== bind、call、apply的区别 动画的了解 介绍下原型链（解决的是继承问题吗） 对跨域的了解 有赞Linux 754 介绍 介绍冒泡排序，选择排序，冒泡排序如何优化 transform动画和直接使用left、top改变位置有什么优缺点 如何判断链表是否有环 介绍二叉搜索树的特点 介绍暂时性死区 ES6中的map和原生的对象有什么区别 观察者和发布-订阅的区别 react异步渲染的概念,介绍Time Slicing 和 Suspense 16.X声明周期的改变 16.X中props改变后在哪个生命周期中处理 介绍纯函数 前端性能优化 pureComponent和FunctionComponent区别 介绍JSX 如何做RN在安卓和IOS端的适配 RN为什么能在原生中绘制成原生组件（bundle.js） 介绍虚拟DOM 如何设计一个localStorage，保证数据的实效性 如何设计Promise.all() 介绍高阶组件 sum(2, 3)实现sum(2)(3)的效果 react性能优化 两个对象如何比较 挖财JS的原型 变量作用域链 call、apply、bind的区别 防抖和节流的区别 介绍各种异步方案 react生命周期 介绍Fiber 前端性能优化 介绍DOM树对比 react中的key的作用 如何设计状态树 介绍css，xsrf http缓存控制 项目中如何应用数据结构 native提供了什么能力给RN 如何做工程上的优化 shouldComponentUpdate是为了解决什么问题 如何解决props层级过深的问题 前端怎么做单元测试 webpack生命周期 webpack打包的整个过程 常用的plugins pm2怎么做进程管理，进程挂掉怎么处理 不用pm2怎么做进程管理 沪江介绍下浏览器跨域 怎么去解决跨域问题 jsonp方案需要服务端怎么配合 Ajax发生跨域要设置什么（前端） 加上CORS之后从发起到请求正式成功的过程 xsrf跨域攻击的安全性问题怎么防范 使用Async会注意哪些东西 Async里面有多个await请求，可以怎么优化（请求是否有依赖） Promise和Async处理失败的时候有什么区别 Redux在状态管理方面解决了React本身不能解决的问题 Redux有没有做过封装 react生命周期，常用的生命周期 对应的生命周期做什么事 遇到性能问题一般在哪个生命周期里解决 怎么做性能优化（异步加载组件…） 写react有哪些细节可以优化 React的事件机制（绑定一个事件到一个组件上） 介绍下事件代理，主要解决什么问题 前端开发中用到哪些设计模式 React/Redux中哪些功能用到了哪些设计模式 JS变量类型分为几种，区别是什么 JS里垃圾回收机制是什么，常用的是哪种，怎么处理的 一般怎么组织CSS（Webpack） 饿了么小程序里面开页面最多多少 React子父组件之间如何传值 Emit事件怎么发，需要引入什么 介绍下React高阶组件，和普通组件有什么区别 一个对象数组，每个子对象包含一个id和name，React如何渲染出全部的name 在哪个生命周期里写 其中有几个name不存在，通过异步接口获取，如何做 渲染的时候key给什么值，可以使用index吗，用id好还是index好 webpack如何配sass，需要配哪些loader 配css需要哪些loader 如何配置把js、css、html单独打包成一个文件 div垂直水平居中（flex、绝对定位） 两个元素块，一左一右，中间相距10像素 上下固定，中间滚动布局如何实现 [1, 2, 3, 4, 5]变成[1, 2, 3, a, b, 5] 取数组的最大值（ES5、ES6） apply和call的区别 ES5和ES6有什么区别 some、every、find、filter、map、forEach有什么区别 上述数组随机取数，每次返回的值都不一样 如何找0-5的随机数，95-99呢 页面上有1万个button如何绑定事件 如何判断是button 页面上生成一万个button，并且绑定事件，如何做（JS原生操作DOM） 循环绑定时的index是多少，为什么，怎么解决 页面上有一个input，还有一个p标签，改变input后p标签就跟着变化，如何处理 监听input的哪个事件，在什么时候触发 携程对React看法，有没有遇到一些坑 对闭包的看法，为什么要用闭包 手写数组去重函数 手写数组扁平化函数 介绍下Promise的用途和性质 Promise和Callback有什么区别 React生命周期 两道手写算法题 喜马拉雅ES6新的特性 介绍Promise Promise有几个状态 说一下闭包 React的生命周期 componentWillReceiveProps的触发条件是什么 React16.3对生命周期的改变 介绍下React的Filber架构 画Filber渲染树 介绍React高阶组件 父子组件之间如何通信 Redux怎么实现属性传递，介绍下原理 React-Router版本号 网站SEO怎么处理 介绍下HTTP状态码 403、301、302是什么 缓存相关的HTTP请求头 介绍HTTPS HTTPS怎么建立安全通道 前端性能优化（JS原生和React） 用户体验做过什么优化 对PWA有什么了解 对安全有什么了解 介绍下数字签名的原理 前后端通信使用什么方案 RESTful常用的Method 介绍下跨域 Access-Control-Allow-Origin在服务端哪里配置 csrf跨站攻击怎么解决 前端和后端怎么联调 兑吧localStorage和cookie有什么区别 CSS选择器有哪些 盒子模型，以及标准情况和IE下的区别 如何实现高度自适应 prototype和——proto——区别 _construct是什么 new是怎么实现的 promise的精髓，以及优缺点 如何实现H5手机端的适配 rem、flex的区别（root em） em和px的区别 React声明周期 如何去除url中的#号 Redux状态管理器和变量挂载到window中有什么区别 webpack和gulp的优缺点 如何实现异步加载 如何实现分模块打包（多入口） 前端性能优化（1js css；2 图片；3 缓存预加载； 4 SSR； 5 多域名加载；6 负载均衡） 并发请求资源数上限（6个） base64为什么能提升性能，缺点 介绍webp这个图片文件格式 介绍koa2 Promise如何实现的 异步请求，低版本fetch如何低版本适配 ajax如何处理跨域 CORS如何设置 jsonp为什么不支持post方法 介绍同源策略 React使用过的一些组件 介绍Immuable 介绍下redux整个流程原理 介绍原型链 如何继承 微医介绍JS数据类型，基本数据类型和引用数据类型的区别 Array是Object类型吗 数据类型分别存在哪里 var a = {name: “前端开发”}; var b = a; a = null那么b输出什么 var a = {b: 1}存放在哪里 var a = {b: {c: 1}}存放在哪里 栈和堆的区别 垃圾回收时栈和堆的区别 数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少 栈和堆具体怎么存储 介绍闭包以及闭包为什么没清除 闭包的使用场景 JS怎么实现异步 异步整个执行周期 Promise的三种状态 Async/Await怎么实现 Promise和setTimeout执行先后的区别 JS为什么要区分微任务和宏任务 Promise构造函数是同步还是异步执行，then呢 发布-订阅和观察者模式的区别 JS执行过程中分为哪些阶段 词法作用域和this的区别 平常是怎么做继承 深拷贝和浅拷贝 loadsh深拷贝实现原理 ES6中let块作用域是怎么实现的 React中setState后发生了什么 setState为什么默认是异步 setState什么时候是同步的 为什么3大框架出现以后就出现很多native（RN）框架（虚拟DOM） 虚拟DOM主要做了什么 虚拟DOM本身是什么（JS对象） 304是什么 打包时Hash码是怎么生成的 随机值存在一样的情况，如何避免 使用webpack构建时有无做一些自定义操作 webpack做了什么 a，b两个按钮，点击aba，返回顺序可能是baa，如何保证是aba（Promise.then） node接口转发有无做什么优化 node起服务如何保证稳定性，平缓降级，重启等 RN有没有做热加载 RN遇到的兼容性问题 RN如何实现一个原生的组件 RN混原生和原生混RN有什么不同 什么是单页项目 遇到的复杂业务场景 Promise.all实现原理 寺库介绍Promise的特性，优缺点 介绍Redux RN的原理，为什么可以同时在安卓和IOS端运行 RN如何调用原生的一些功能 介绍RN的缺点 介绍排序算法和快排原理 堆和栈的区别 介绍闭包 闭包的核心是什么 网络的五层模型 HTTP和HTTPS的区别 HTTPS的加密过程 介绍SSL和TLS 介绍DNS解析 JS的继承方法 介绍垃圾回收 cookie的引用为了解决什么问题 cookie和localStorage的区别 如何解决跨域问题 前端性能优化 宝宝树使用canvas绘图时如何组织成通用组件 formData和原生的ajax有什么区别 介绍下表单提交，和formData有什么关系 介绍redux接入流程 rudux和全局管理有什么区别（数据可控、数据响应） RN和原生通信 介绍MVP怎么组织 介绍异步方案 promise如何实现then处理 koa2中间件原理 常用的中间件 服务端怎么做统一的状态处理 如何对相对路径引用进行优化 node文件查找优先级 npm2和npm3+有什么区别 海康威视knex连接数据库响应回调 介绍异步方案 如何处理异常捕获 项目如何管理模块 前端性能优化 JS继承方案 如何判断一个变量是不是数组 变量a和b，如何交换 事件委托 多个标签生成的Dom结构是一个类数组 类数组和数组的区别 dom的类数组如何转成数组 介绍单页面应用和多页面应用 redux状态树的管理 介绍localstorage的API 蘑菇街html语义化的理解 和的区别 对闭包的理解 工程中闭包使用场景 介绍this和原型 使用原型最大的好处 react设计思路 为什么虚拟DOM比真实DOM性能好 react常见的通信方式 redux整体的工作流程 redux和全局对象之间的区别 Redux数据回溯设计思路 单例、工厂、观察者项目中实际场景 项目中树的使用场景以及了解 工作收获 酷家乐react生命周期 react性能优化 添加原生事件不移除为什么会内存泄露 还有哪些地方会内存泄露 setInterval需要注意的点 定时器为什么是不精确的 setTimeout(1)和setTimeout(2)之间的区别 介绍宏任务和微任务 promise里面和then里面执行有什么区别 介绍pureComponet 介绍Function Component React数据流 props和state的区别 介绍react context 介绍class和ES5的类以及区别 介绍箭头函数和普通函数的区别 介绍defineProperty方法，什么时候需要用到 for..in 和 object.keys的区别 介绍闭包，使用场景 使用闭包特权函数的使用场景 get和post有什么区别 百分点React15/16.x的区别 重新渲染render会做些什么 哪些方法会触发react重新渲染 state和props触发更新的生命周期分别有什么区别 setState是同步还是异步 对无状态组件的理解 介绍Redux工作流程 介绍ES6的功能 let、const以及var的区别 浅拷贝和深拷贝的区别 介绍箭头函数的this 介绍Promise和then 介绍快速排序 算法：前K个最大的元素 海风教育对react看法，它的优缺点 使用过程中遇到的问题，如何解决的 react的理念是什么（拿函数式编程来做页面渲染） JS是什么范式语言(面向对象还是函数式编程) koa原理，为什么要用koa(express和koa对比) 使用的koa中间件 ES6使用的语法 Promise 和 async/await 和 callback的区别 Promise有没有解决异步的问题（promise链是真正强大的地方） Promise和setTimeout的区别（Event Loop） 进程和线程的区别（一个node实例就是一个进程，node是单线程，通过事件循环来实现异步 ） 介绍下DFS深度优先 介绍下观察者模式 观察者模式里面使用的数据结构(不具备顺序 ，是一个list)","categories":[{"name":"2018面试题","slug":"2018面试题","permalink":"https://93qlin.github.io/categories/2018面试题/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://93qlin.github.io/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://93qlin.github.io/tags/面试/"}]},{"title":"JavaScript常用数组操作方法，包含ES6方法","slug":"JavaScript常用数组操作方法，包含ES6方法","date":"2019-02-28T03:12:12.514Z","updated":"2019-02-28T03:12:12.514Z","comments":true,"path":"2019/02/28/JavaScript常用数组操作方法，包含ES6方法/","link":"","permalink":"https://93qlin.github.io/2019/02/28/JavaScript常用数组操作方法，包含ES6方法/","excerpt":"","text":"一、concat() concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，仅会返回被连接数组的一个副本。 12345var arr1 = [1,2,3];var arr2 = [4,5];var arr3 = arr1.concat(arr2);console.log(arr1); //[1, 2, 3]console.log(arr3); //[1, 2, 3, 4, 5] 二、join() join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，默认使用’,’号分割，不改变原数组。 123var arr = [2,3,4];console.log(arr.join()); //2,3,4console.log(arr); //[2, 3, 4] 三、push() push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。末尾添加，返回的是长度，会改变原数组。 12345var a = [2,3,4];var b = a.push(5);console.log(a); //[2,3,4,5]console.log(b); //4push方法可以一次添加多个元素push(data1,data2....) 四、pop() pop() 方法用于删除并返回数组的最后一个元素。返回最后一个元素，会改变原数组。 123var arr = [2,3,4];console.log(arr.pop()); //4console.log(arr); //[2,3] 五、shift() shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。返回第一个元素，改变原数组。 123var arr = [2,3,4];console.log(arr.shift()); //2console.log(arr); //[3,4] 六、unshift() unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。返回新长度，改变原数组。 1234var arr = [2,3,4,5];console.log(arr.unshift(3,6)); //6console.log(arr); //[3, 6, 2, 3, 4, 5]tip:该方法可以不传参数,不传参数就是不增加元素。 七、slice() 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。返回选定的元素，该方法不会修改原数组。 123var arr = [2,3,4,5];console.log(arr.slice(1,3)); //[3,4]console.log(arr); //[2,3,4,5] 八、splice() splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。splice() 方法会直接对数组进行修改。 123456var a = [5,6,7,8];console.log(a.splice(1,0,9)); //[]console.log(a); // [5, 9, 6, 7, 8]var b = [5,6,7,8];console.log(b.splice(1,2,3)); //[6, 7]console.log(b); //[5, 3, 8] 九、substring() 和 substr() 相同点：如果只是写一个参数，两者的作用都一样：都是是截取字符串从当前下标以后直到字符串最后的字符串片段。substr(startIndex);substring(startIndex); 123var str = &apos;123456789&apos;;console.log(str.substr(2)); // &quot;3456789&quot;console.log(str.substring(2)) ;// &quot;3456789&quot; 不同点：第二个参数substr（startIndex,lenth）： 第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）；substring（startIndex, endIndex）： 第二个参数是截取字符串最终的下标 （截取2个位置之间的字符串,‘含头不含尾’）。 12console.log(&quot;123456789&quot;.substr(2,5)); // &quot;34567&quot;console.log(&quot;123456789&quot;.substring(2,5)) ;// &quot;345&quot; 十、sort 排序 按照 Unicode code 位置排序，默认升序 12var fruit = [&apos;cherries&apos;, &apos;apples&apos;, &apos;bananas&apos;];fruit.sort(); // [&apos;apples&apos;, &apos;bananas&apos;, &apos;cherries&apos;] 12var scores = [1, 10, 21, 2];scores.sort(); // [1, 10, 2, 21] 十一、reverse() reverse() 方法用于颠倒数组中元素的顺序。返回的是颠倒后的数组，会改变原数组。 123var arr = [2,3,4];console.log(arr.reverse()); //[4, 3, 2]console.log(arr); //[4, 3, 2] 十二、indexOf 和 lastIndexOf 都接受两个参数：查找的值、查找起始位置不存在，返回 -1 ；存在，返回位置。indexOf 是从前往后查找， lastIndexOf 是从后往前查找。indexOf 1234567var a = [2, 9, 9];a.indexOf(2); // 0a.indexOf(7); // -1if (a.indexOf(7) === -1) &#123; // element doesn&apos;t exist in array&#125; lastIndexOf 1234567var numbers = [2, 5, 9, 2];numbers.lastIndexOf(2); // 3numbers.lastIndexOf(7); // -1numbers.lastIndexOf(2, 3); // 3numbers.lastIndexOf(2, 2); // 0numbers.lastIndexOf(2, -2); // 0numbers.lastIndexOf(2, -1); // 3 十三、every 对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true 1234function isBigEnough(element, index, array) &#123; return element &lt; 10;&#125; [2, 5, 8, 3, 4].every(isBigEnough); // true 十四、some 对数组的每一项都运行给定的函数，任意一项都返回 ture,则返回 true 12345function compare(element, index, array) &#123; return element &gt; 10;&#125; [2, 5, 8, 1, 4].some(compare); // false[12, 5, 8, 1, 4].some(compare); // true 十五、filter 对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组 123456var words = [&quot;spray&quot;, &quot;limit&quot;, &quot;elite&quot;, &quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;, &quot;happy&quot;];var longWords = words.filter(function(word)&#123; return word.length &gt; 6;&#125;);// Filtered array longWords is [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;] 十六、map 对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组 123456var numbers = [1, 5, 10, 15];var doubles = numbers.map(function(x) &#123; return x * 2;&#125;);// doubles is now [2, 10, 20, 30]// numbers is still [1, 5, 10, 15] 十七、forEach 数组遍历12345const items = [&apos;item1&apos;, &apos;item2&apos;, &apos;item3&apos;];const copy = []; items.forEach(function(item)&#123; copy.push(item)&#125;); ES6新增新操作数组的方法1、find()： 传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。 12const arr = [1, &quot;2&quot;, 3, 3, &quot;2&quot;]console.log(arr.find(n =&gt; typeof n === &quot;number&quot;)) // 1 2、findIndex()： 传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。 12const arr = [1, &quot;2&quot;, 3, 3, &quot;2&quot;]console.log(arr.findIndex(n =&gt; typeof n === &quot;number&quot;)) // 0 3、fill()： 用新元素替换掉数组内的元素，可以指定替换下标范围。 1arr.fill(value, start, end) 4、copyWithin()： 选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。 12345678910arr.copyWithin(target, start, end)const arr = [1, 2, 3, 4, 5]console.log(arr.copyWithin(3)) // [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2const arr1 = [1, 2, 3, 4, 5]console.log(arr1.copyWithin(3, 1))// [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3const arr2 = [1, 2, 3, 4, 5]console.log(arr2.copyWithin(3, 1, 2))// [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2 5、from 将类似数组的对象（array-like object）和可遍历（iterable）的对象转为真正的数组 123456const bar = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];Array.from(bar);// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]Array.from(&apos;foo&apos;);// [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;] 6、of 用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。 12345678Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8]Array.of(7); // [7]Array.of(1, 2, 3); // [1, 2, 3]Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3] 7、entries() 返回迭代器：返回键值对12345678910111213141516171819202122//数组const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];for(let v of arr.entries()) &#123; console.log(v)&#125;// [0, &apos;a&apos;] [1, &apos;b&apos;] [2, &apos;c&apos;]//Setconst arr = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);for(let v of arr.entries()) &#123; console.log(v)&#125;// [&apos;a&apos;, &apos;a&apos;] [&apos;b&apos;, &apos;b&apos;] [&apos;c&apos;, &apos;c&apos;]//Mapconst arr = new Map();arr.set(&apos;a&apos;, &apos;a&apos;);arr.set(&apos;b&apos;, &apos;b&apos;);for(let v of arr.entries()) &#123; console.log(v)&#125;// [&apos;a&apos;, &apos;a&apos;] [&apos;b&apos;, &apos;b&apos;] 8、values() 返回迭代器：返回键值对的value12345678910111213141516171819202122//数组const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];for(let v of arr.values()) &#123; console.log(v)&#125;//&apos;a&apos; &apos;b&apos; &apos;c&apos;//Setconst arr = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);for(let v of arr.values()) &#123; console.log(v)&#125;// &apos;a&apos; &apos;b&apos; &apos;c&apos;//Mapconst arr = new Map();arr.set(&apos;a&apos;, &apos;a&apos;);arr.set(&apos;b&apos;, &apos;b&apos;);for(let v of arr.values()) &#123; console.log(v)&#125;// &apos;a&apos; &apos;b&apos; 9、keys() 返回迭代器：返回键值对的key12345678910111213141516171819202122//数组const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];for(let v of arr.keys()) &#123; console.log(v)&#125;// 0 1 2//Setconst arr = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);for(let v of arr.keys()) &#123; console.log(v)&#125;// &apos;a&apos; &apos;b&apos; &apos;c&apos;//Mapconst arr = new Map();arr.set(&apos;a&apos;, &apos;a&apos;);arr.set(&apos;b&apos;, &apos;b&apos;);for(let v of arr.keys()) &#123; console.log(v)&#125;// &apos;a&apos; &apos;b&apos; 10、includes 判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。indexOf 判断元素是否为 NaN，会判断错误。 123var a = [1, 2, 3];a.includes(2); // truea.includes(4); // false 出自(https://segmentfault.com/a/1190000016503330)","categories":[{"name":"JavaScript常用数组操作方法，包含ES6方法","slug":"JavaScript常用数组操作方法，包含ES6方法","permalink":"https://93qlin.github.io/categories/JavaScript常用数组操作方法，包含ES6方法/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://93qlin.github.io/tags/es6/"},{"name":"javascript","slug":"javascript","permalink":"https://93qlin.github.io/tags/javascript/"}]},{"title":"ant-design","slug":"ant-design","date":"2019-02-28T03:12:12.514Z","updated":"2019-02-28T03:12:12.514Z","comments":true,"path":"2019/02/28/ant-design/","link":"","permalink":"https://93qlin.github.io/2019/02/28/ant-design/","excerpt":"","text":"生态圈https://github.com/ant-design/ant-designhttps://ant.design/docs/react/introduce-cnhttps://scaffold.ant.design/#/https://stackoverflow.com/questions/tagged/antdhttps://segmentfault.com/t/antdhttps://codesandbox.io/s/wk04r016q8https://zhuanlan.zhihu.com/antdesignhttp://react-component.github.io/badgeboard/https://github.com/react-component 学习https://github.com/hfpp2012/hello-ant/tree/11_layout_1https://ant.design/components/layout-cn/https://github.com/ant-design/react-tutorialhttps://www.yuque.com/ant-design/coursehttps://github.com/ant-design/ant-design-pro","categories":[{"name":"ant-design","slug":"ant-design","permalink":"https://93qlin.github.io/categories/ant-design/"}],"tags":[{"name":"ant-design","slug":"ant-design","permalink":"https://93qlin.github.io/tags/ant-design/"}]}]}